[{"title":"MoeCTF 2025 Reverse","path":"/MoeCTF 2025-1/","content":"逆向部分 题目speedDid you see my little pony? She runs really fast...附件：speed.zip 运行 speed.exe ，窗口一晃而过 直接使用 IDA Pro 打开，注意到主函数中有 Winmain 函数 跳转到 Winmain 函数 注意到29行 ShowWindow 命令，和32行 DestroyWindow 。就是这个函数让窗口一晃而过。在这下断点，执行。窗口停下。 Base打开程序，提示输入 flag，随便输入一个，程序退出 用 IDA 打开程序 32行，Buffer 认为是输入，v4 是输入长度， v11 是长为16的字符数组 33行，v7 与 一串神秘字符比较，猜测 v7 需要等于这串字符 注意到这串字符 结尾是 =，查看 32 行的函数，可以判断应该是个 base64 编码函数 import base64ciphertext = bW9lY3Rme1kwdV9DNG5fRzAwZF9BdF9CNDVlNjQhIX0=b = base64.b64decode(ciphertext) print(b.decode()) 解码，即得到 flag catch flag db geoi~lq~bcyUcyUkUlkaoUlfkmw,0 enc 是一个很简单的异或函数，一切都很简单，写一个简单的 c++ 程序模拟 #includeiostream#includestringstd::string flag = geoi~lq~bcyUcyUkUlkaoUlfkmw;char enc(char a) return a ^ 0x11;int main() int len = flag.size(); for(int i = 0; i len; i++) flag[i] = enc(flag[i]); std::cout flag std::endl; return 0; 运行结果是： vt~xo`osrhDrhDzDzp~Dwz|f 很显然不是 flag 结合提示 IDA pro 9.0 推出了针对 C++ exception 的优化但是这并不意味着所有的 try catch 都能被正确反编译 这意味着需要读汇编 注意到下面这段汇编代码，有一个比上面的 flag 更像 flag 的字符串 islower， isupper函数表示分大小写需要对字符进行不同处理（特殊字符不处理） 总而言之，重新写一个 c++ 程序 #includeiostream#includestringstd::string flag = zbrpgsF4z3_Ge1px_jvgu_@sybjre_qrfhjn;int main() int len = flag.size(); for(int i = 0; i len; i++) if(islower(flag[i])) flag[i] = (flag[i] - 84) % 26 + a; else if(isupper(flag[i])) flag[i] = (flag[i] - 52) % 26 + A; std::cout flag std::endl; return 0; 运行结果： moectfS4m3_Tr1ck_with_@flower_desuwa moe直接将文件拖入 IDA 发现无法反汇编，使用 upx 脱壳 upx -d moe.exe 然后 moe.exe 就能正常反编译了 使用 fgets 读入一行，存储到 Buffer，然后对Buffer每个字符与 0x21 异或，再与后一个字符异或，得到 v14 重写： #includeiostream#includestringint main() std::string flag; std::cin flag; int len = flag.size(); if(len) for(int i = 0; i len; i++) flag[i] = flag[i] ^ 0x21; if(i len - 1 ) flag[i] = flag[i] ^ flag[i+1]; std::cout flag std::endl; return 0; 看比较部分： 只有当 v14 与 v10 这两个数组 前35 个字符一样时，才不会输出表示失败的字符串 现在看看 v10 是什么，就是一些字节数据 32个63位整数 SSE 指令（_mm_load_si128）加载 128 位数据（xmmword） 到内存。 以十六进制按顺序排列 ：232B2736333C0348640B1D767B100B3A3F65762915371C0A08213E3C3D160B24（小端序） 仔细一看，除了 v10 数组以外，在下面还有 v11 , v12 , v13 分别为 41 , 36 , 86（十进制） 此外提示消息还提到 fget会连同换行符一起读入。换行符 的 ASCII 码值为 0x10 ，与0x21 异或结果为 0x2B 最终应该在原十六进制数后加上 29 24 56 2B 最后是逆向获取 flag 的过程。 从后往前，对每个字符，先与后一个字符异或，再与 0x21 异或 特殊情况：最后一个字符直接与 0x21 异或（也是迭代的第一个字符） # 36 27 2B 23 # 48 03 3C 33 # 76 1D 0B 64 # 3A 0B 10 7B # 29 76 65 3F # 0A 1C 37 15# 3C 3E 21 08# 24 0B 16 3D# 小端序# d41 d36 d86 - 29 24 56# A^21 = 2B fget还会在末尾有 x = 232B2736333C0348640B1D767B100B3A3F65762915371C0A08213E3C3D160B242924562Bs = bytes.fromhex(x)s_list = list(s)length = len(s_list)print(s_list)for i in range(length): if i == 0: s_list[length - i - 1] = s_list[length - i - 1] ^ 0x21 else: s_list[length - i - 1] = s_list[length - i] ^ s_list[length - i - 1] s_list[length - i - 1] = s_list[length - i - 1] ^ 0x21print(s_list)ascii_str = bytes(s_list).decode(ascii) print(ascii_str) 输出结果： moectfY0u_c4n_unp4ck_It_vvith_upx ez3试运行： 现在拖入 IDA 查看，要求是 42 个字符，且符合 moectf...... 的格式 else分支应该是对 v11 ：flag 进行某种变换 注意到 v5 使用在 使用 end 迭代器，且长度为 1 ，猜测与 有关 注意到 v6 使用在 使用 begin 迭代器，且长度为 7 ，猜测与 moectf 有关 那现在很自然可以认为最终 v12 应该是flag 中 内的内容 最终要想输出 OK，需要 v5 1，即 check(v12) 返回 1 查看 check() 函数 a 数组： 现在可以开始求解 flag 了 先重写一下 check 函数 def is_flag(flag): b = [0] * 34 for i in range(34): b[i] = 47806 * (ord(flag[i]) + i) if i != 0: b[i] = b[i] ^ b[i-1] ^ 0x114514 b[i] = b[i] % 51966 if b[i] != ciphertext[i]: return False return True 使用 Z3 求解 from z3 import *ciphertext = [ 0x0B1B0, 0x5678,0x7FF2,0x0A332,0x0A0E8,0x364C,0x2BD4,0x0C8FE,0x4A7C,0x18,0x2BE4,0x4144,0x3BA6,0x0BE8C,0x8F7E,0x35F8,0x61AA,0x2B4A,0x6828,0x0B39E,0x0B542,0x33EC,0x0C7D8,0x448C,0x9310,0x8808,0x0ADD4,0x3CC2,0x796,0x0C940,0x4E32,0x4E2E,0x924A,0x5B5C]# 创建 Z3 求解器solver = Solver()# 定义 flag 字符和中间变量 b，使用 BitVec 类型（32 位）flag = [BitVec(fflag_i, 32) for i in range(34)]b = [BitVec(fb_i, 32) for i in range(34)]# 添加约束：flag 字符在 ASCII 可打印字符范围内 (32 到 126)for i in range(34): solver.add(flag[i] = 32, flag[i] = 126)# 根据 is_flag 函数的逻辑添加约束for i in range(34): temp = 47806 * (flag[i] + i) if i == 0: solver.add(b[i] == temp % 51966) else: temp = temp ^ b[i-1] ^ 0x114514 solver.add(b[i] == temp % 51966) solver.add(b[i] == ciphertext[i])# 存储所有解solutions = []while solver.check() == sat: model = solver.model() # 提取 flag 字符 flag_vals = [model[flag[i]].as_long() for i in range(34)] flag_str = .join(chr(val) for val in flag_vals) solutions.append(flag_str) # 添加排除当前解的约束 solver.add(Or([flag[i] != flag_vals[i] for i in range(34)])) # 可选：限制最大解的数量，避免过多输出 if len(solutions) = 100: # 限制最多 100 个解 break# 输出所有解if solutions: for idx, sol in enumerate(solutions, 1): print(fidx: sol)else: print(无解) 输出： 注意到多个解满足检查，逐个提交，第二个 flag 正确 ezandroid 注意到 44 行，输入 文本，转换成 String ，Base64 编码后需要与 上面这串字符相等 在 Java（以及安卓开发中常见的语言如 Kotlin）中，trim() 是一个字符串方法，用于移除字符串首尾的空白字符，包括空格（ ）、制表符（\\t）、换行符（ ）、回车符（\\r）等。 import base64s = bW9lY3Rme2FuZHJvaWRfUmV2ZXJzZV9JNV9lYXN5fQ==b = base64.b64decode(s) # Base64 解码print(b.decode()) base64 解码，即可 moectfandroid_Reverse_I5_easy flower 花指令 直接拖入 IDA solve 函数无法反编译 格式检查部分： 最下方：右侧是 格式错误分支，左侧是我们需要关心的地方 loc_4048E5: jz short Label jnz short Label call near ptr Label+1Label: lea rax, [rbp+var_59] _Z5solveNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE endp ; sp-analysis failed jz 和 jnz 表示为 0 和不为 0 时均跳转到 Label call 指令不会被执行到，并且在反编译时对反编译器造成干扰，使用 NOP 指令替换 现在能成功反编译 solve函数 现在能发现格式检查部分的逻辑 查看 0x4048F2 地址处的汇编代码 这里看到涉及到 begin (7)和 end (1)的迭代器，可以猜测这里对格式进行处理， 然后将长度与 20h ，即 32比较，可以猜测 flag的 中字符串长度为 32 输出变了，说明猜测正确 现在 想想如何输出 Win 将每个字符使用 encode 函数编码，然后与 enc 比较，不同会输出 Wrong，刚好 32 个十六进制数 enc:4F 1A 59 1F 5B 1D 5D 6F 7B 47 7E 44 6A 07 59 67 0E 52 08 63 5C 1A 52 1F 20 7B 21 77 70 25 74 2B key 23h key 是一个全局变量， 每次执行都会加 1 逆向这个 encode 函数很简单 s = for i in range(min(len(enc), length)): s += chr(enc[i] ^ (key + i)) # 逆向异或 但是仅仅这样的话会输出不可打印字符。 原因是 key 不一定仅仅在这里被使用 ，搜索 key 发现在 main 函数中也被使用，虽然我们没能反编译出。 查看发现 key 会与 0xA 异或，现在 key = 0x23 ^ 0x0A enc = [0x4F ,0x1A ,0x59 ,0x1F ,0x5B ,0x1D ,0x5D ,0x6F ,0x7B ,0x47 ,0x7E ,0x44 ,0x6A ,0x07, 0x59 ,0x67 ,0x0E ,0x52 ,0x08,0x63 ,0x5C ,0x1A ,0x52 ,0x1F ,0x20 ,0x7B ,0x21 ,0x77 ,0x70 ,0x25 ,0x74 ,0x2B]s = for i in range(min(len(enc), length)): s += chr(enc[i] ^ (key + i)) # 逆向flag = moectf + s + print(flag) 输出： moectff0r3v3r_JuMp_1n_7h3_a$m_a9b35c3c 本题中还使用 ptrace ，实现禁止跟踪进程，用于对抗动态调试 A cup of tea TEA 加密 花了半天才找到 主函数 sub_14001109B 函数： 可以看出这是一个 TEA 加密算法，使用 DELTA = 0x114514 逆向这个过程即可 from ctypes import c_uint32def decrypt_block(left, right, k): sum_val = 0x114514 * 32 # sum = DELTA * rounds for _ in range(32): right = c_uint32(right - ((k[3] + (left 5)) ^ (sum_val + left) ^ (k[2] + 16 * left))).value left = c_uint32(left - ((k[1] + (right 5)) ^ (sum_val + right) ^ (k[0] + 16 * right))).value sum_val -= 0x114514 return left, rightv9 = [ 2026214571, # 0x78B1DCAB 578894681, # 0x22849959 1193947460, # 0x472A8944 -229306230, # 0xF29BFC6A 73202484, # 0x045D0374 961145356, # 0x394A0E0C -881456792, # 0xCB4B6B68 358205817, # 0x1559FC79 -554069347, # 0xDEF4F19D 119347883, # 0x071C1F2B]v8 = [ 289739801, # 0x1142CB19 427884820, # 0x19829914 1363251608, # 0x51435998 269567252, # 0x10119914]# 解密 v9 的每个块（5 个块，每个块 8 字节）decrypted = []for i in range(0, 10, 2): left = c_uint32(v9[i]).value # 转换为无符号 32 位整数 right = c_uint32(v9[i + 1]).value dec_left, dec_right = decrypt_block(left, right, v8) decrypted.append(dec_left) decrypted.append(dec_right)# 将解密后的 DWORD 转换为字节flag_bytes = []for val in decrypted: flag_bytes.extend(val.to_bytes(4, byteorder=little))# 转换为 ASCII 字符串flag = bytes(flag_bytes).decode(ascii, errors=ignore)print(Decrypted Flag:, flag) 输出： moectfh3r3_4_cuP_0f_734_f0R_y0U!!!!!! ezpy.pyc pyc文件是 Python 字节码（Bytecode）的编译缓存文件。 使用反编译工具 uncompyle6 pip install uncompyle uncompyle filename # 直接使用 # 加密函数def caesar_cipher_encrypt(text, shift): result = [] for char in text: if char.isalpha(): if char.islower(): new_char = chr((ord(char) - ord(a) + shift) % 26 + ord(a)) else: if char.isupper(): new_char = chr((ord(char) - ord(A) + shift) % 26 + ord(A)) result.append(new_char) else: result.append(char) else: return .join(result) 注意到 小写字母映射到 另一个小写字母，大写字母映射到另一个大写字母，其他字符不变 那这个加密函数的解密就很简单了 plaintext = user_inputshift = 114514encrypted_text = caesar_cipher_encrypt(plaintext, shift)if encrypted_text == wyomdpI0e_Ux0G_zim: print(Correct!!!!) 现在试着写逆向函数： def decrypt(ciphertext,shift): text = [] for char in ciphertext: if char.isalpha(): if char.islower(): old_char = chr((ord(char) - ord(a) - shift) % 26 + ord(a)) else: if char.isupper(): old_char = chr((ord(char) - ord(A) - shift) % 26 + ord(A)) text.append(old_char) else: text.append(char) else: return .join(text) ciphertext = wyomdpI0e_Ux0G_zimshift = 114514plaintext = decrypt(ciphertext,shift)print(plaintext) 输出： moectfY0u_Kn0W_pyc have_fun试运行 拖入 IDA ，查看反编译代码。40~43行非常熟悉，这是在计算 String 的长度 v5，可以看到如果长度 大于 32 就会执行很长一块代码 大于32时会执行很长一串块代码，从前往后循环处理32字节的字符，剩余的字符，分别与 0x2A 异或加密 这就是加密逻辑，那接下来就应该是比较逻辑 注意到 83 行的 break ，这应该是比较中不愿意看到的，触发条件就是加密后的数组需要与 aGeoiLqbj 数组一致（仅需前 len(aGeoiLqbj)部分一致 ） 注意到 87 行 v17，上面提到这个变量会触发 break ，在这行 if条件中又出现，无论如何，不能让这个 if 语句执行，这个语句触发的第二个条件是加密后的数组长度不等于16，所以我们输入的 flag 长度应该为 16 查看 aGeoiLqbj ： 逆向解密： aGeoiLqbj = [0x47,0x45,0x4F,0x49,0x5E,0x4C,0x51,0x62,0x6A,0x5C,0x1E,0x75,0x4C,0x7F,0x44,0x57]length = len(aGeoiLqbj)# 逐字符 XOR 加密# for i in range(length):# encrypted_text[i] = String[i] ^ 0x2A; # 每个字符 XOR 0x2Aplaintext = []for i in range(length): plaintext.append(chr(aGeoiLqbj[i] ^ 0x2A))plaintext = .join(plaintext)print(plaintext) 输出： moectfH@v4_fUn mazegame直接执行： 拖入 IDA 76 行：应该是超出迷宫范围 81行：应该是撞墙逻辑（对应字符串处有 %d，%d，输出两个整数，就是之前截图里的撞墙提示坐标） 86行：到达终点 现在查看这个 byte_140005660 ，发现在 13 行调用过的函数里被初始化过。 bool dfs(int x, int y, std::vectorstd::string maze, std::string path) // 到达目标点 if (x == 32 y == 15) return true; // 标记当前位置为已访问 maze[y][x] = 1; // 四个方向：下、右、左、上 const int dx[] = 0, 1, -1, 0; const int dy[] = 1, 0, 0, -1; const char dir[] = S, D, A, W; // 尝试四个方向 for (int i = 0; i 4; i++) int nx = x + dx[i]; int ny = y + dy[i]; // 检查新位置是否有效且未访问 if (nx = 0 nx maze[0].length() ny = 0 ny maze.size() maze[ny][nx] == 0) path += dir[i]; if (dfs(nx, ny, maze, path)) return true; // 回溯：如果这条路走不通，删除这一步 path.pop_back(); return false;int main() std::vectorstd::string maze = v9; // 复制一份地图，避免修改原始数据 std::string path; if (dfs(1, 1, maze, path)) std::cout 找到路径: path std::endl; std::cout 路径长度: path.length() std::endl; else std::cout 没有找到路径！ std::endl; return 0; upx_revenge使用 upx -d 解压缩： 提示说查看 文件的 UPX 特征 左边是题目的二进制，右边是一个我自己使用 upx 压缩的 exe 文件 对比，发现少了 UPX!，把它补上，就能正常 脱壳 脱壳成功，现在就是逆向代码的过程了。 xor_base64 = .join(chr(ord(c) ^ 0xE) for c in ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/)target = lY7bW=\\\\ck?eyjX7]TZ\\\\CVbh\\\\tOyTH6jH7XmFifG]H7index_map = c: i for i, c in enumerate(xor_base64)flag = i = 0while i len(target): group = target[i:i+4] pad = group.count(=) # 处理填充 chars = [c for c in group if c != =] # 如果有填充，补齐索引 while len(chars) 4: chars.append(xor_base64[0]) try: idx = [index_map[c] for c in chars] value = (idx[0] 18) | (idx[1] 12) | (idx[2] 6) | idx[3] flag += chr((value 16) 0xFF) if pad 2: flag += chr((value 8) 0xFF) if pad 1: flag += chr(value 0xFF) except KeyError as e: print(fError: Character e not in encoding table) break i += 4# 去除末尾多余字符print(fFlag: flag.rstrip(chr(0))) moeaY0u_Re4l1y_G00d_4t_Upx!!!猜测：moectfY0u_Re4l1y_G00d_4t_Upx!!! 工具部分Z3 求解器Z3 求解器： 约束求解（Constraint Solving） 逻辑公式验证（Formal Verification） 符号执行（Symbolic Execution） 程序分析（Program Analysis） pip install z3-solver 使用示例 from z3 import *# 创建变量x = Int(x)y = Int(y)# 添加约束solver = Solver()solver.add(x + y == 10)solver.add(x - y == 2)# 求解if solver.check() == sat: model = solver.model() print(fx = model[x], y = model[y])# 输出: x = 6, y = 4 jadx-gui找到 Source 下的包结构，通常是 com.example.xxx MainActivity：通常是应用的入口 Activity，类似于安卓应用的“主页”。 其 onCreate 方法，是 Activity 启动时执行的初始化逻辑。","categories":["CTF"]},{"title":"CryptoHack 第二部分 模运算","path":"/CryptoHack-2/","content":"介绍模运算及相关概念、算法、定理 最大公约数GCD欧几里得算法计算两个数的最大公约数GCD 扩展欧几里得算法还能找到一组整数解 (x) 和 (y)，满足 $ ax+bygcd⁡(a,b) $ # 欧几里得算法def gcd(a, b): while b != 0: a, b = b, a % b return a# 扩展欧几里得算法（使用递归）def gcd_extended(a, b): if a == 0: return b, 0, 1 gcd, x1, y1 = gcd_extended(b % a, a) x = y1 - (b // a) * x1 y = x1 return gcd, x, y 费马小定理若模 p 为质数，定义一个域 $ F_{p}$ 若模 n 非质数，则只能定义一个环 $ F_{p}$ 表示集合 ${ 0,1,…,p-1 }$ 费马小定理 如果 p 是质数， a 是不被 p 整除的整数，则：$ a^{p−1}≡1(modp) $ 二次剩余例：$ a 11, \\ a^2 \\ 5 \\ mod\\ ( \\ 29\\ ) ,\\ \\ 5的平方根就是11 和 -11（18）$ 当可以在模 p 下 取 x 的平方根时， x 就是二次剩余数Quadratic Residue 计算性质： Quadratic Residue * Quadratic Residue = Quadratic ResidueQuadratic Residue * Quadratic Non-residue = Quadratic Non-residueQuadratic Non-residue * Quadratic Non-residue = Quadratic Residue 勒让德符号Legendre 符号 $(\\frac{a}{p}) ≡ a^{(p−1)2} \\ mod \\ p$ 等于 $ 1$ ：a 是 二次剩余数 等于 $-1$ ：a 是非二次剩余数 等于 $ 0$ ：$a≡0 \\ mod\\ p$ 通过计算 $a^{(p−1)2} \\ mod \\ p$ 即可判断 a 是否为二次剩余数 只可能是这三种情况之一，现在我们能判断 是否为二次剩余数，但是如何求出平方根呢？ 现在假设确定了 a 是二次剩余数，现在求它的平方根，即找到 $x$ 使得 $x^{2} a \\ mod \\ p$， p是质数， Legendre 符号 $(\\frac{a}{p}) ≡ a^{(p−1)2} \\ mod \\ p$ , 先假设 a 是二次剩余数，很自然地让 $ a^{(p−1)2}$乘以 $a$ 再开方，$a^{(p+1)4}$ 就应该是 a 的平方根 $注意到 （a^{(p+1)4})^2 a^{(p+1)2} a^{(p-1)2} × a ，若 a 是二次剩余数，则\\ a^{(p−1)2} 1$ $即（a^{(p+1)4})就是 a 的平方根$ # Now for the flag. # Given the following 1024 bit prime and 10 integers, find the quadratic residue and then calculate its square root; # the square root is your flag. Of the two possible roots, submit the larger one as your answer.# 提示提到 p 满足 p = 3 mod 4 且是质数p = ......ints = [......]power = (p + 1) // 4for i in ints: Legendre_symbol = pow(i,(p-1)//2,p) x = pow(i,power,p) if Legendre_symbol == 1: print(max(x,p-x)) else: print(None) Tonelli-Shanks综上所述，若 a 为二次剩余数，则$（a^{(p+1)4})是 a 的平方根$ 但是这仅适用于 $ a 3 \\ mod \\ 4$ 的情况，还有一种情况 $a 1 \\ mod \\ 4$ 比较复杂，下次再讨论 Sage内置可使用 def Tonelli_Shanks(a,p): Legendre_symbol = pow(a,(p-1)//2,p) if Legendre_symbol == 1: if p % 4 == 3: x = pow(a, (p + 1)//4, p) return min(x,p-x) if p % 4 == 1: # 待解决 return 0 else: return None 中国剩余定理如果一组线性同余式的模互质，则中国剩余定理可以给出它们的唯一解。 已知x满足： x ≡ 2 mod 5 x ≡ 3 mod 11 x ≡ 5 mod 17求：满足 x ≡ a mod (5*11*17) 的 a # 扩展gcd算法def extended_gcd(a, b): if a == 0: return b, 0, 1 gcd, x1, y1 = extended_gcd(b % a, a) x = y1 - (b // a) * x1 y = x1 return gcd, x, y# 求模的逆元def mod_inverse(a, m): gcd, x, y = extended_gcd(a, m) if gcd != 1: return None # 没有逆元 return (x % m + m) % m # 确保结果在 [0, m-1] 范围内# 中国剩余定理def crt(a,m): length = len(m) M = 1 for i in m: M = M * i # 模之积 M_i = [] for i in m: M_i.append(M/i) reverse_M_i = [] for i, j in zip(M_i, m): reverse_M_i.append(mod_inverse(i, j)) sum = 0 for i, j, k in zip(M_i, reverse_M_i, a): sum += i*j*k return sum % Mm = [5,11,17]a = [2,3,5]print(crt(a,m)) 解密加密程序： from random import randinta = 288260533169915p = 1007621497415251FLAG = bcrypto????????????????????def encrypt_flag(flag): ciphertext = [] # bin切换为二进制表示，[2:]去掉 0b前缀，zfill(8)左侧填充0，join将所有字符串拼接 表示之间无间隙 plaintext = .join([bin(i)[2:].zfill(8) for i in flag]) for b in plaintext: e = randint(1, p) n = pow(a, e, p) if b == 1: ciphertext.append(n) else: n = -n % p ciphertext.append(n) return ciphertextprint(encrypt_flag(FLAG)) 加密结果是 很长的一个列表 [67594220461269, 501237540280788, ………] FLAG 中的每个字符都表示成 8位 二进制数，然后拼接成一长串01序列 密文中的每个数 $ n a^e \\ mod \\ p$ ，e 是一个小于 p 的正随机整数。 将01序列转变为数字列表： 为 0，插入 n 为 1，插入 p - n 实际上只需要按顺序检验 数字列表 中的数字 n ，是否存在 e 使得 $ n a^e \\ mod \\ p$ 存在为 1，否则为 0。这样就能恢复二进制序列 然后重新编码成 ASCII 码序列即可 使用 BSGS（Baby Step Giant Step） 求解 $ a^e ≡ n \\ mod\\ p $ 的最小非负整数 e 解密程序： from math import isqrtdef mod_pow(a, e, p): 快速幂取模 return pow(a, e, p)def order(a, p): 模p下a的阶（最小正整数d使得a^d ≡ 1 mod p） d = p - 1 factors = set() x = d # 分解 d 的所有质因子 i = 2 while i*i = x: while x % i == 0: factors.add(i) x //= i i += 1 if x 1: factors.add(x) # 计算阶 for f in sorted(factors): while d % f == 0 and pow(a, d//f, p) == 1: d //= f return ddef is_in_subgroup(a, n, p): 判断 n 是否在 a 生成的子群内 d = order(a, p) return pow(n, d, p) == 1def bsgs(a, n, p): Baby Step Giant Step 求解 a^e ≡ n mod p 的最小非负整数 e a %= p n %= p m = isqrt(p) + 1 # Baby steps value_table = baby = 1 for j in range(m): value_table[baby] = j baby = (baby * a) % p # Giant steps inv_am = pow(a, m * (p - 2), p) # a^-m mod p，费马小定理求逆元 giant = n for i in range(m): if giant in value_table: return i * m + value_table[giant] giant = (giant * inv_am) % p return None # 不存在def discrete_log_exist_and_value(a, n, p): 主函数：判断并输出离散对数 if not is_in_subgroup(a, n, p): return False, None e = bsgs(a, n, p) return True, ea = 288260533169915p = 1007621497415251ciphertext = [67594220461269, 501237540280788, 718316769824518, 296304224247167, 48290626940198, 30829701196032, 521453693392074, 840985324383794, 770420008897119, 745131486581197, 729163531979577, 334563813238599, 289746215495432, 538664937794468, 894085795317163, 983410189487558, 863330928724430, 996272871140947, 352175210511707, 306237700811584, 631393408838583, 589243747914057, 538776819034934, 365364592128161, 454970171810424, 986711310037393, 657756453404881, 388329936724352, 90991447679370, 714742162831112, 62293519842555, 653941126489711, 448552658212336, 970169071154259, 339472870407614, 406225588145372, 205721593331090, 926225022409823, 904451547059845, 789074084078342, 886420071481685, 796827329208633, 433047156347276, 21271315846750, 719248860593631, 534059295222748, 879864647580512, 918055794962142, 635545050939893, 319549343320339, 93008646178282, 926080110625306, 385476640825005, 483740420173050, 866208659796189, 883359067574584, 913405110264883, 898864873510337, 208598541987988, 23412800024088, 911541450703474, 57446699305445, 513296484586451, 180356843554043, 756391301483653, 823695939808936, 452898981558365, 383286682802447, 381394258915860, 385482809649632, 357950424436020, 212891024562585, 906036654538589, 706766032862393, 500658491083279, 134746243085697, 240386541491998, 850341345692155, 826490944132718, 329513332018620, 41046816597282, 396581286424992, 488863267297267, 92023040998362, 529684488438507, 925328511390026, 524897846090435, 413156582909097, 840524616502482, 325719016994120, 402494835113608, 145033960690364, 43932113323388, 683561775499473, 434510534220939, 92584300328516, 763767269974656, 289837041593468, 11468527450938, 628247946152943, 8844724571683, 813851806959975, 72001988637120, 875394575395153, 70667866716476, 75304931994100, 226809172374264, 767059176444181, 45462007920789, 472607315695803, 325973946551448, 64200767729194, 534886246409921, 950408390792175, 492288777130394, 226746605380806, 944479111810431, 776057001143579, 658971626589122, 231918349590349, 699710172246548, 122457405264610, 643115611310737, 999072890586878, 203230862786955, 348112034218733, 240143417330886, 927148962961842, 661569511006072, 190334725550806, 763365444730995, 516228913786395, 846501182194443, 741210200995504, 511935604454925, 687689993302203, 631038090127480, 961606522916414, 138550017953034, 932105540686829, 215285284639233, 772628158955819, 496858298527292, 730971468815108, 896733219370353, 967083685727881, 607660822695530, 650953466617730, 133773994258132, 623283311953090, 436380836970128, 237114930094468, 115451711811481, 674593269112948, 140400921371770, 659335660634071, 536749311958781, 854645598266824, 303305169095255, 91430489108219, 573739385205188, 400604977158702, 728593782212529, 807432219147040, 893541884126828, 183964371201281, 422680633277230, 218817645778789, 313025293025224, 657253930848472, 747562211812373, 83456701182914, 470417289614736, 641146659305859, 468130225316006, 46960547227850, 875638267674897, 662661765336441, 186533085001285, 743250648436106, 451414956181714, 527954145201673, 922589993405001, 242119479617901, 865476357142231, 988987578447349, 430198555146088, 477890180119931, 844464003254807, 503374203275928, 775374254241792, 346653210679737, 789242808338116, 48503976498612, 604300186163323, 475930096252359, 860836853339514, 994513691290102, 591343659366796, 944852018048514, 82396968629164, 152776642436549, 916070996204621, 305574094667054, 981194179562189, 126174175810273, 55636640522694, 44670495393401, 74724541586529, 988608465654705, 870533906709633, 374564052429787, 486493568142979, 469485372072295, 221153171135022, 289713227465073, 952450431038075, 107298466441025, 938262809228861, 253919870663003, 835790485199226, 655456538877798, 595464842927075, 191621819564547]def decrypt_flag(ciphertext): plaintext = for b in ciphertext: exist, e = discrete_log_exist_and_value(a, b, p) if exist: plaintext + 1 print(1,flush=True,end=) else: plaintext + 0 print(0,flush=True,end=) flag = for i in range(0, len(plaintext), 8): binary = plaintext[i:i+8] ascii_value = int(binary, 2) char = chr(ascii_value) flag += char return flagprint(decrypt_flag(ciphertext)) 解密结果： cryptop4tterns_1n_re5idu3s","categories":["CryptoHack"]},{"title":"CryptoHack 第一部分 简介","path":"/CryptoHack-1/","content":"介绍pwntools和编码知识 pwntoolspwntools 是一个开源的 Python 库，主要用于二进制漏洞利用、逆向工程和 CTF 挑战的开发。它抽象了许多底层操作，使得安全研究人员可以专注于漏洞分析和利用逻辑，而无需处理繁琐的细节。 主要功能： 与本地或远程进程交互（如二进制程序、远程服务器）。 处理 ELF 文件、ROP（返回导向编程）链生成。 提供便捷的汇编反汇编工具。 支持多种架构（如 x86、x64、ARM、MIPS 等）。 提供网络通信工具（如 socket 操作）。 自动化调试和漏洞利用开发。 例：向远程服务发送 JSON 数据 from pwn import * # 导入 pwntools 库的所有功能import json # 导入 Python 的 json 模块，用于处理 JSON 数据的序列化和反序列化# 定义远程服务器的地址和端口号HOST = socket.cryptohack.org # 远程服务器的主机名PORT = 11112 # 远程服务器的端口号# 使用 pwntools 的 remote 函数建立与远程服务器的 TCP 连接r = remote(HOST, PORT) # 创建一个远程连接对象 r，用于与 socket.cryptohack.org:11112 通信# 定义一个函数，用于接收服务器发送的 JSON 数据def json_recv(): line = r.readline() # 使用 pwntools 的 readline 方法读取服务器发送的一行数据 return json.loads(line.decode()) # 将接收到的字节数据解码为字符串，并解析为 Python 的 JSON 对象（通常是字典）# 定义一个函数，用于向服务器发送 JSON 数据def json_send(hsh): request = json.dumps(hsh).encode() # 将 Python 字典 hsh 序列化为 JSON 字符串，并编码为字节 r.sendline(request) # 使用 pwntools 的 sendline 方法将字节数据发送到服务器，并自动添加换行符# 连续读取服务器发送的四行数据并打印# 这些行是服务器的欢迎信息、提示或其他初始输出print(r.readline()) # 读取并打印第一行数据（字节形式）print(r.readline()) # 读取并打印第二行数据print(r.readline()) # 读取并打印第三行数据print(r.readline()) # 读取并打印第四行数据# 创建一个 JSON 请求字典，表示购买 flagrequest = buy: flag # 构造一个字典，键为 buy，值为 flagjson_send(request) # 调用 json_send 函数，将请求序列化为 JSON 并发送到服务器# 接收服务器的响应并解析为 JSONresponse = json_recv() # 调用 json_recv 函数，接收服务器的响应并解析为 Python 字典# 打印服务器的响应print(response) # 输出服务器返回的 JSON 数据（通常是字典形式） 这里仅做介绍 编码知识所使用函数均来源于 python ASCII 编码chr()函数用于将 ASCII 码转换为字符 ord()执行相反操作 十六进制字符串编码 当我们对数据进行加密时，生成的密文通常是一些二进制数据，其中包含许多非可打印的 ASCII 字符 这些字符在屏幕上无法直接显示，也难以通过文本方式传输（比如通过邮件或聊天工具）。 所以可以将密文编码为十六进制字符串，用户友好且跨系统兼容 bytes.fromhex()函数可用于将十六进制转换为字节 .hex()可以对字节字符串调用实例方法来获取十六进制表示形式。 Base64编码Base64 使用一个由 64 个字符组成的字母表：A-Z（大写字母）、a-z（小写字母）、0-9、+ 和 每个字符代表一个 6 位的二进制值（从 000000 到 111111，十进制 0 到 63）。 4 个字符表示 3 个字节 在 Python 中，使用 导入 base64 模块后import base64，即可使用base64.b64encode()函数。 字节和大整数像 RSA 这样的密码系统只能处理数字，但消息是由字符组成的。 如何将消息转换成数字，以便进行数学运算呢？ 最常见的方法是取出消息的序数字节，将其转换为十六进制，然后连接起来。这可以解释为十六进制十六进制数，也可以表示为十进制十进制数。 消息：HELLOascii 字节：[72, 69, 76, 76, 79]十六进制字节：[0x48, 0x45, 0x4c, 0x4c, 0x4f]base-16：0x48454c4c4fbase-10：310400273487 Python 的 PyCryptodome 库通过方法bytes_to_long()和long_to_bytes()实现了这一点。 需要先安装 PyCryptodome 并使用 from Crypto.Util.number import *导入它 。 异或XOR交换律： A ⊕ B B ⊕ A结合律： A ⊕ (B ⊕ C) (A ⊕ B) ⊕ C恒等式：A ⊕ 0 A自逆： A ⊕ A 0 Python pwntools库中有一个方便的xor()函数，可以对不同类型和长度的数据进行异或运算。 例子0e0b213f26041e480b26217f27342e175d0e070a3c5b103e2526217f27342e175d0e077e263451150104 这是使用一个 密钥 对数据加密后的密文，提示说注意 flag 的提交格式 crypto 那就先把密文和 crypto 进行异或，发现输出前面几个字符刚好是 myXORke+y，有点奇怪 有理由怀疑密钥就是 myXORkey，试一试，将密文与密钥再异或，得到了明文 输出一直是一些奇怪字符，最后发现是系统终端 被某些字符影响了，重新打开终端重置状态就好了 很奇怪 附录：函数chr() # 将ASCII码转换为字符ord() # 将字符转换成ASCII码bytes.fromhex() # 将十六进制转换为字节.hex() # 对字节字符串调用实例方法来获取十六进制表示形式。base64.b64encode() # Base64编码 （import base64）bytes_to_long() # 十六字节字符拼接，转化成数字（from Crypto.Util.number import *）long_to_bytes() # 数字转化成十六进制，拆分成字节（from Crypto.Util.number import *）xor() # 对不同类型和长度的数据进行异或运算（from pwn import *）","categories":["CryptoHack"]},{"title":"Cyber Security 101 第六部分 密码学介绍(待更新)","path":"/Cyber-Security-101-6/","content":"探索各种对称和非对称加密算法。发现哈希算法在日常系统中的用途。 密码学仅作介绍，深入了解请看分类 CryptoHack 密码学基础知识密码学的最终目的是确保 在存在对手的情况下也能进行安全通信。 “安全”一词涵盖了通信数据的机密性和完整性。 密码学可以定义为在预期存在对手和第三方的情况下，安全通信和数据保护技术的实践和研究。换句话说，这些对手不应该能够泄露或更改消息的内容。 相关概念 明文Plaintext：加密前原始、可读的消息或数据，可以是文档、图像、多媒体文件或其他二进制数据。 密文Ciphertext：加密后不可读的、经过扰乱的消息版本。理想情况下，除大致大小外，无法从中获取关于明文的任何信息。 密码Cipher：将明文转换为密文并能逆向转换的算法或方法，通常由数学家开发。 密钥Key：密码用于加密或解密数据的一串比特。一般来说，使用的密码是公开知识，但密钥必须保密，除非是非对称加密中的公钥（后续任务将讨论非对称加密）。 加密Encryption：使用密码和密钥将明文转换为密文的过程。与密钥不同，密码的选择是公开的。 解密Decryption：加密的逆过程，使用密码和密钥将密文转换回明文。尽管密码是公开知识，但在不知道密钥的情况下恢复明文应是不可能的（不可行的）。 古典密码凯撒密码将明文的每个字母 按字母表 一起右移 X 位，作为 密文 英文字母表有 26 个字母，移动 26 位将使字母保持不变；因此，使用凯撒密码加密的有效密钥有 25 个。 按照今天的标准，由于密码是公开的，凯撒密码被认为是不安全的。 加密类型对称加密使用相同密钥对数据进行加密和解密。密钥必须保密 DES 3DES AES 非对称加密使用一对密钥，使用公钥对数据进行加密，私钥解密 RSADiffie-Hellman 密钥交换SSH数字签名和证书PGP和GPG哈希基础知识哈希函数存储密码的安全问题使用哈希算法进行安全密码存储识别密码哈希值密码破解完整性检查的哈希算法","categories":["Cyber Security 101"]},{"title":"Cyber Security 101 第五部分 网络(待更新)","path":"/Cyber-Security-101-5/","content":"了解 OSI 模型和 TCPIP模型。探索日常使用的各种网络协议以及WireShark、Tcpdump、Nmap的使用 第一部分 网络概念仅对基础知识做总结，不展开 OSI 模型 TCPIP 模型 应用层（OSI的应用层、表示层、会话层） 传输层 网络层 链路层 物理层 IP地址和子网IP 地址是网络上主机的标识符 分为 IPv4 （4字节）和 IPv6 （6字节） IPv4地址：192.168.1.10：网络地址255：广播地址 子网子网是为了缓解 IPv4 短缺的问题而设计 如图，该设备使用子网掩码 255.255.255.0 划分网络 设备的 IP 地址为：192.168.1.101/24 左边 24 位在整个子网内保持不变 子网 IP 地址范围为：192.168.1.1 ~ 192.168.1.254 192.168.66.0和192.168.66.255分别是网络地址和广播地址。 私有 IP 地址私有 IP 地址是根据 RFC 1918 定义的 IP 地址范围，专门用于私有网络（如家庭、办公室或企业内部网络）。 这些地址不会直接路由到公共互联网，只能在本地网络中使用。 缓解了IPv4地址短缺的问题 私有 IP 地址通常由路由器或网络设备通过 DHCP（动态主机配置协议）或静态分配给设备，用于内部通信。例如，电脑、手机或智能设备在家里连接 Wi-Fi 时，通常会被分配一个私有 IP 地址。 10.0.0.0- 10.255.255.255（10/8） 172.16.0.0- 172.31.255.255（172.16/12） 192.168.0.0- 192.168.255.255（192.168/16） UDP和TCPIP 地址标识主机，使用端口号区分进程，端口号使用两个字节，范围1 ~ 65535，0是保留端口 UDP无连接、不可靠的传输协议 缺点：不保证数据按序到达、不重传丢失数据、无流量控制 优点：速度快、开销低、支持多对多通信 TCP面向连接、可靠的传输协议 TCP连接通过三次握手建立。使用两个标志：SYN（同步）和 ACK（确认）。 SYN 数据包：客户端通过向服务器发送 SYN 数据包来发起连接。此数据包包含客户端随机选择的初始序列号。 SYN-ACK 数据包：服务器使用 SYN-ACK 数据包响应 SYN 数据包，该数据包添加了服务器随机选择的初始序列号。 ACK 数据包：当客户端发送 ACK 数据包以确认收到 SYN-ACK 数据包时，三次握手就完成了。 四次挥手关闭连接 数据传输：保证数据按序、无差错、不丢失地传输，提供错误检测和重传机制。 缺点：开销较大、速度较慢 优点：可靠性高 封装 用户数据 数据报（段）TCP segment UDP datagram 网络数据包 packet 数据链路帧 frame 远程登录TELNET（电传打字网络）协议是一种用于远程终端连接的网络协议。 TELNET 客户端允许您连接到远程系统并与之通信，以及发出文本命令。 telnet 10.10.30.254 13 # 连接到10.10.30.254的13端口 telnet 10.10.30.254 80 # 80端口：HTTP服务GET / HTTP/1.1 # /标识资源路径，为空表示访问服务器根目录Host: your_host # 正在请求的主机# 两次回车 第二部分 网络基础知识DHCP 动态主机配置协议服务器的网络配置通常固定，可以手动配置。但移动设备网络配置不固定。 DHCP：采用自动化方式配置联网设备 遵循四个步骤： DHCP发现：客户端广播 DHCPDISCOVER 消息，寻找本地DHCP服务器（如果存在）。 DHCP提供：服务器以 DHCPOFFER 消息进行响应，其中包含可供客户端接受的 IP 地址。 DHCP请求：客户端以 DHCPREQUEST 消息进行响应，表明它已接受提供的 IP。 DHCP确认：服务器以 DHCPACK 消息进行响应，以确认提供的 IP 地址现已分配给该客户端。 在四个步骤完成之前 客户端是没有 IP 配置的，使用 0.0.0.0 以及本机 MAC 地址向广播 IP 地址 255.255.255.255 和 广播 MAC 地址 ff:ff:ff:ff:ff:ff发送消息，服务器使用发送的 MAC 地址标识设备（链路层） DHCP 过程结束时，设备将收到访问互联网所需的所有配置： IP 地址 将数据包路由到本地网络之外的网关 用于解析域名的 DNS 服务器 ARP 地址解析协议 48位 MAC 地址 两种常用数据链路层：以太网、WIFI 同一以太网上的两台设备 需要知道 对方的IP地址和MAC地址才能一对一联系，一种思路是向 DHCP 服务器查询，另一种就是 ARP地址解析协议 ARP 地址解析协议 ARP 请求：请求者将 目的IP 地址发送到广播 MAC 地址，子网内所有联网设备都会受到请求 ARP 应答：目的 IP 地址受到请求后，答复 MAC 地址 ARP 请求或ARP 应答并非封装在 UDP 或 IP 数据包中，而是直接封装在以太网帧中。 ARP 允许从第 3 层网络层寻址到第 2 层链路层寻址的转换。 ARP协议的必要性在于它提供了一种简单、分布式、高效的 IP 到 MAC 地址解析机制，适用于各种网络环境（无论是否有DHCP服务器）。 直接从DHCP服务器获取MAC地址虽然理论上可行，但会引入额外的复杂性、延迟和单点故障风险，而ARP通过广播和缓存机制很好地解决了这些问题。 ICMP 互联网控制消息协议主要用于网络诊断和错误报告 ping：使用 ICMP 测试与目标系统的连接，测量往返时间 RTT traceroute：使用 ICMP 跟踪主机到目标的路由 路由协议 OSPF（开放最短路径优先）：OSPF 是一种路由协议，允许路由器共享网络拓扑信息，并计算出最高效的数据传输路径。它通过路由器之间交换其所连接链路和网络状态的更新来实现这一点。这样，每个路由器都拥有完整的网络地图，并可以确定到达任何目的地的最佳路由。 EIGRP（增强型内部网关路由协议）：EIGRP 是 Cisco 专有的路由协议，它融合了不同路由算法的诸多特性。它允许路由器共享其可到达网络的信息以及与这些路由相关的成本（例如带宽或延迟）。然后，路由器会利用这些信息来选择最高效的数据传输路径。 BGP（边界网关协议）：BGP 是互联网上使用的主要路由协议。它允许不同的网络（例如互联网服务提供商的网络）交换路由信息，并建立数据在这些网络之间传输的路径。BGP 有助于确保数据即使在跨越多个网络时也能在互联网上高效路由。 RIP（路由信息协议）：RIP 是一种简单的路由协议，常用于小型网络。运行 RIP 的路由器会共享它们可以到达的网络以及到达目标网络所需的跳数（路由器数）。因此，每个路由器都会根据这些信息构建路由表，选择到达每个目标网络的跳数最少的路由。 NAT解决 IPv4 地址耗尽的一种方法就是 网络地址转换 NAT NAT 的理念在于使用 一个公网 IP 地址 为 多个私有 IP 地址 提供互联网访问。 路由器维护一个表，将内部 IP 地址和端口号与其外部 IP 地址和端口号进行映射。 如图，从笔记本电脑的角度来看，该连接是从其 IP 地址192.168.0.129发起的，TCP 源端口号为15401； 然而，Web 服务器会将此连接视为从 212.3.4.5 TCP 端口号19273 建立的 路由器无缝地执行此地址转换。 这种转换受到路由器端口数限制，65536 第三部分 网络核心协议DNS 域名系统DNS 负责将域名映射到 IP 地址 DNS 流量默认使用UDP端口 53，并将TCP端口 53 作为默认回退端口。 DNS 有不同类型： A：将主机名映射到一个或多个 IPv4地址 AAAA：IPv6 CNAME：将域名映射到另一个域名 MX：指定负责处理域电子邮件的邮箱服务器 可以使用 nslookup在命令行中查找域的 IP 地址 WHOISWHOIS 记录提供了注册域名实体的信息 Linux 上可以使用 whois 查询域名信息 HTTP(S)启动浏览器时，主要使用HTTP和 HTTPS 协议。HTTP代表超文本传输协议；HTTPS 中的 S 代表安全。该协议依赖于TCP，并定义了 Web 浏览器与 Web 服务器的通信方式。 Web 浏览器通常向 Web 服务器发出的一些方法如下： GET从服务器检索数据，例如 HTML 文件或图像。 POST允许我们向服务器提交新数据，例如提交表单或上传文件。 PUT用于在服务器上创建新资源以及更新和覆盖现有信息。 DELETE，用于删除服务器上的指定文件或资源。 HTTP和 HTTPS 通常分别使用TCP端口 80 和 443，较少使用其他端口，例如 8080 和 8443。 GET /index.html HTTP/1.1Host: www.example.com FTP：传输文件与旨在检索网页的HTTP不同，文件传输协议 ( FTP ) 旨在传输文件。因此，FTP 的文件传输效率非常高，并且在所有条件相同的情况下，它可以实现比HTTP更高的速度。FTP 命令通常在命令行或专用软件中使用。 FTP协议定义的示例命令如下： USER用于输入用户名 PASS用于输入密码 RETR（retrieve）用于从FTP服务器下载文件到客户端。 STOR(store) 用于将文件从客户端上传到FTP服务器。 FTP服务器默认监听TCP端口 21；数据传输通过从客户端到服务器的另一个连接进行。 SMTP：发送电子邮件POP3：接收电子邮件IMAP：同步电子邮件第四部分 网络安全协议TLS（ transport Layer Security）安全套接字层 (SSL) 和传输层安全性 (TLS) 是用于加密客户端（例如 Web 浏览器）与服务器之间交换数据的协议。SSLTLS 可视为一种封装，它加密各种通信协议（例如HTTP和FTP），从而创建 HTTPS 和 FTPS。SSL 如今已不常用，因为 TLS 已逐渐取代它。 TLS 是传输层的加密协议，允许客户端和服务器在不安全的网络上进行安全通信。这里的 安全 指机密性、完整性 SSLTLS工作流程SSLTLS 握手用于通过以下步骤加密客户端与服务器之间的通信： 客户端问候消息：客户端向服务器发送问候消息，包含客户端支持的 TLS 版本、密码套件以及随机字节。 服务器问候消息：服务器回复问候消息，提供其证书、选定的密码套件和随机字节。 认证：客户端通过发行证书的证书颁发机构验证服务器的证书。例如，访问Google时，Google会分享其证书，浏览器通过预装的证书颁发机构证书进行验证。 预主密钥：客户端使用服务器的公钥（从服务器证书中获取）加密随机字节。 预主密钥解密：服务器使用其私钥解密预主密钥。 会话密钥生成：客户端和服务器基于客户端随机字节、服务器随机字节和预主密钥生成会话密钥。双方将得到相同的结果； 此会话密钥不传输，加密和解密基于此密钥。 准备消息：客户端和服务器使用会话密钥发送“完成”消息，表示会话已准备好传输。此时，客户端和服务器可以通过SSLTLS加密连接交换消息。 HTTPSSMTPS、POP3S、IMAPSSSHSFTP、FTPSVPN第五部分 WireShark第六部分 Tcpdump第七部分 Nmap","categories":["Cyber Security 101"]},{"title":"Cyber Security 101 第四部分 命令行","path":"/Cyber-Security-101-4/","content":"介绍 Windows 命令行和MS PoweShell，以及 Linux 操作系统中 Bash 的用法，包括编写 Shell 脚本 cmdCMD命令属于批处理语言（Batch Script），是一种基于 Windows 命令行环境的脚本语言。 Windows环境下默认命令行解释器是 cmd.exe 基本系统信息set # 检查路径ver # 确定操作系统版本systeminfo # 系统信息介绍cls # 清理cmd屏幕# 命令 | more # 一页一页输出 网络故障排除ipconfig # 检查网络信息，后可加/allping example.com # 检查服务器是否可访问tracert example.com # 跟踪到达目标所经过的网络路由nslookup example.com # 查找主机/域并返回其IP地址netstat # 显示当前网络连接和监听端口# -a显示所有已建立的连接和监听端口# -b显示与每个监听端口和已建立的连接相关的程序# -o显示与连接关联的进程 ID ( PID )# -n使用数字形式表示地址和端口号 文件和磁盘管理cd # 不带参数：显示当前驱动器和目录# 带参数（文件夹路径）：切换目录dir # 查看子目录 # /a 显示隐藏文件 # /s 显示当前目录和子目录所有文件tree # 以直观方式标识目录和子目录mkdir # 创建目录 makermdir # 删除目录 removetype # 查看文本文件内容copy # 复制文件move # 移动文件del # 删除文件erase # 删除文件 可以使用通配符 * 引用多个文件 # 将所有md文件复制到目录copy *.md C:\\Markdown 任务和流程管理tasklist # 列出正在运行的进程，支持筛选tasklist /？ # 查看帮助页面# 查找与notepad.exe相关进程tasklist /FI imagename eq notepad.exe taskkill /PID target_pid # 终止进程 其他命令chkdsk # 检查文件系统和磁盘卷 是否存在错误和坏扇区driverquery # 显示已安装的设备驱动程序列表sfc /sacnnow # 扫描系统文件是否有损坏，并尽可能修复 shutdown /? # 关机、重启、注销等等 PowerShellPowerShell 是一种功能更强大的脚本语言，基于 .NET 框架，专为 Windows 系统管理设计。 面向对象，可以处理复杂数据类型并与系统组件交互 基本语法PowerShell 命令 被称为cmdlets ，遵循一致的Verb-Noun命名约定 使用 Get-Command 查看所有 cmdlet，Alias，Function 使用 Get-Help 命令 可获得命令使用帮助 Get-Alias # 列出所有可使用的别名Get-Command -CommandType Function # 获取函数命令列表Get-Command -Verb Remove # 动词为 Remove 的命令Get-Command -Name Remove* # 使用通配符，同样查询以 Remove 开头的命令 PowerShell 还可以从在线存储库下载其他 cmdlet 来扩展其功能 Find-Module -Name “name” Install-Module -Name “name” 文件系统Get-ChildItem # 浏览目录并查看内容Set-Location # 更改当前目录New-Item -Path .\\file -ItemType Directory # 创建文件夹New-Item -Path .\\text.txt -ItemType File # 创建文件Remove-Item # 删除目录/文件Copy-Item # 相当于copyMove-Item # 相当于moveGet-Content # 相当于cat 管道运输、过滤、排序Get-ChildItem | Sort-Object LengthGet-ChildItem | Where-Object -Property Extension -eq .txt Get-ChildItem | Where-Object -Property Name -like ship* 管道运输符 | 将 Get-ChildItem 的执行结果 传输到后面 Get-ChildItem | Where-Object -Property Length -gt 10 # 筛选大于10的项目Get-ChildItem | Sort-Object Length -Descending | Select-Object -First 1 # 找出最大的项目 系统和网络信息Get-ComputerInfo # 查询全面的系统信息Get-LocalUser # 列出所有本地用户账户Get-NetIPConfiguration # 系统网络接口信息Get-NetIPAddress # 系统网络IP地址信息 实时系统分析Get-Process # 显示所有运行进程Get-Service # 显示所有服务Get-NetTCPConnection # 显示当前TCP连接Get-FileHash # 生成文件哈希 Get-FileHash -Path .\\ship-flag.txt # 生成文件哈希 脚本 对于事件响应人员、恶意软件分析师和威胁猎手等蓝队专业人员来说， PowerShell脚本可以自动执行许多不同的任务，包括日志分析、检测异常和提取入侵指标 (IOC)。这些脚本还可用于对恶意代码（恶意软件）进行逆向工程或自动扫描系统以查找入侵迹象。 对于红队（包括渗透测试人员和道德黑客）而言，PowerShell脚本可以自动执行诸如系统枚举、执行远程命令以及编写混淆脚本以绕过防御等任务。它与所有类型的系统深度集成，使其成为模拟攻击和测试系统抵御现实威胁能力的强大工具。 在网络安全的背景下，系统管理员可以利用PowerShell脚本自动执行完整性检查、管理系统配置和保护网络，尤其是在远程或大规模环境中。PowerShell脚本可以用于强制执行安全策略、监控系统健康状况并自动响应安全事件，从而增强整体安全态势。 编写脚本难度很高，暂时略过 Invoke-Command 它能够实现高效的远程管理，并结合脚本功能，实现跨多台计算机的任务自动化。此外，它还可用于在渗透测试人员（或攻击者）的攻击过程中在目标系统上执行有效载荷或命令。 Invoke-Command -ComputerName Server01 -Credential Domain01\\User01 -ScriptBlock Get-Service -Credential指凭据。远程连接设备 server01 并执行Get-service Linux Shell基础命令 pwdcd Filelscat filename.txtgrep THM file.txt # 在文本文件中搜索THM Linux Shell有多种类型 echo $SHELL # 查看当前Shell类型cat /etc/shells # 列出系统中可以用的终端 Bash 、 Fish 、 Zsh三种 Shell ： history # 查看命令历史记录# 上下键切换历史命令 Shell脚本创建一个Bash 脚本 frist_script.sh，扩展名为 .sh 首行 定义 脚本执行解释器 #!/bin/bash echo Hello,Whats your name?read nameecho Welcome,$name 使用 bash 执行 bash frist_script.sh 授予脚本执行权限然后直接执行 chmod +x frist_script.sh./frist_script.sh 变量your_name=yang # 变量名和等号间不能有空格echo $your_name # 使用变量需要加上 $echo $your_name # 帮助解释器识别变量的边界readonly your_name # 声明变量只读，后续无法修改unset your_name # 删除变量，但不能删除只读变量 变量类型：字符串、整数、数组、环境变量、特殊变量 my_string=Hello # 或单引号，或不用引号declare -i my_integer=42 # 声明变量为整数my_array=(1 2 3 4 5) echo $PATH # PATH是环境变量，包含了操作系统搜索可执行文件的路径 特殊变量： $0 表示脚本名称 ，$1、 $2 表示脚本参数 $# 表示传递给脚本的参数数量，$? 表示上一个命令的退出状态等 字符串变量，双引号内可以使用变量、转义字符，而单引号内所有内容都会原样输出 your_name=yangstring=Hello,$your_name ! # 字符串拼接（单引号也一样）echo $string read name # 接收用户的输入，存储在变量nameecho $#name # 获取字符串长度，$#name 等价于 $#name[0]echo $#name:1:3 # 从第2个字符开始截取3个字符 echo $array_name[@] # 获取数组中的所有元素 传递参数执行一个脚本，传递 1、2、3 三个参数 bash test.sh 1 2 3 在脚本内部，使用 $0 表示脚本名称 ，$1、 $2 、$3表示脚本参数 还可以用$# 表示传递给脚本的参数数量，$? 表示上一个命令的退出状态 $* 显示所有参数 $$ 获取脚本运行的当前进程ID Shell运算符介绍算术运算符、关系运算符、逻辑运算符 原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。 expr 是一款表达式计算工具，使用它能完成表达式的求值操作。 val=`expr 2 + 2` 常用算术运算符：+ - * / % = == != 关系运算符只支持数字，不支持字符串，除非字符串的值是数字。 常用关系运算符：-eq -ne -gt -lt -ge --le if [ $a -eq $b]then echo $a -eq $b : a 等于 belse echo $a -eq $b : a 不等于 bfi 逻辑运算符 || 还有字符串运算符、文件测试运算符、自增自减运算符等等 也可以使用 (()) 进行算术运算，也可直接使用 echoecho -n Loading... # 不换行输出echo -e First line Second line # 启用转义字符echo hello output.txt # 输出到文件并覆盖， 是追加# 彩色文本，\\033[0m 重置属性，42绿背景，31红字echo -e \\033[42;31mGreen Background with Red Text\\033[0m printf暂时略过 条件if conditionthen command1 command2 ... commandN else commandfi 代码块不可为空，要么就不写 else if condition1then command1elif condition2 then command2else commandNfi 循环#!/bin/bashfor i in 1..10;doecho $idone while conditiondo commanddone until conditiondo commanddone break 跳出所有循环 continue 跳出当前循环 case $value in value1) command1 command2 ... commandN ;;value2) command1 command2 ... commandN ;;esac Shell函数[ function ] funname [()] action; [return int;] 函数调用，像脚本一样传参 funname 1 2 3 示例： #!/bin/bashfunction demoFun1() echo 这是我的第一个 shell 函数! return `expr 1 + 1`demoFun1echo $?echo $? 第一个 echo 显示函数返回值2 第二个 echo 显示上一条命令正确执行的返回值 0 Shell 输入输出重定向 Shell 文件包含Shell 可以包含外部脚本 source ./test1.sh# 或. ./test1.sh","categories":["Cyber Security 101"]},{"title":"Cyber Security 101 第三部分 AD和Windows基础知识","path":"/Cyber-Security-101-3/","content":"先介绍Active Directory基础知识 再介绍 Windows 的 NTFS 文件系统、UAC权限控制、系统配置、资源监控、注册表以及安全相关功能。 第一部分 Active DirectoryActive Directory是Windows服务器环境中的目录服务。几乎任何中大型企业为了集中化管理，都会部署AD 本质上 AD 是一个分层式的、分布式的数据库，用于存储、组织并提供对网络环境中各种对象和资源信息的访问。 其核心协议是实现身份认证和授权的 LDAP (Lightweight Directory Access Protocol)。 逻辑结构： 域 Domain：使用DNS域名标识，是一个安全对象的集合，这些对象共享目录数据库和安全策略 树 Tree：一个或多个域的层次化组合，这些域共享一个连续的 DNS 命名空间 林 Forest：包含一个或多个共享共同架构 (Schema) 和全局编录 (Global Catalog) 的域。林内的所有域通过可传递的信任关系自动建立双向信任。 组织单位 OU：域内组织对象的最小单位，是应用组策略和委派管理权限的最小作用域单位。 物理结构： 域控制器 DC：运行Active Directory 服务的服务器 站点 Site Active Directory用户：用户是安全主体之一，是可以对网络中的资源进行操作的对象。 人员用户：用户通常代表组织中需要访问网络的人员，例如员工。 服务用户：每个服务都需要一个用户才能运行，这就是服务用户，只拥有运行特定服务所需的权限。 机器：每台加入 Active Directory 域的计算机都会创建一个计算机对象。计算机也被视为“安全主体”，机器账户本身指计算机的本地管理员。通常 计算机名称+$ 就是机器账户名。 安全组：类似用户组，可用于向用户授予特定权限。如域管理员、服务器操作员、备份操作员、账户操作员、域用户、域计算机、域控制器 登录域控制器，运行 Active Directory Users and Computers 。 组织单位 OU ：容器对象，可用于对用户和计算机进行分类。一个用户一次只能属于一个 OU 如图，THM 组织单元有5个子组织单元。图中四个用户 同属于 Sales 组织单元 OU 是应用组策略和委派管理权限的最小作用域单位。 组策略销售所需要的权限是相同的，应该给销售人员统一配置权限。 根据不同需要可以给不同 OU 分别配置不同权限策略，这就是组策略。 使用Group Policy Management工具查打开 组策略 配置操作界面 在 Group Policy Objects 目录下 创建组策略，然后就可以链接到其他 组织单元 （子组织单元也会影响） 图中 GPO 内有三个组策略，已经应用于 OU Security Filtering ：安全筛选，默认情况下组策略会应用到所有安全对象 Settings 栏里可以看到具体包含哪些权限 修改组策略，右键 选中 Edit，会弹出包含许多条目的新界面，如图 组策略分发域控制器上一个名为 SYSVOL 的特定网络共享文件夹，存放有 组策略对象 数据。 DC 上的默认路径：C:\\Windows\\SYSVOL\\sysvol\\ 域内的用户可以通过 域名\\SYSVOL 来访问 域成员会定期联系 DC 查询是否 需要更新GPO 也可以在 PoweShell 使用gpupdate /force来立即更新 Delegation 权限委派授予用户特定权限，让他们能在 OU 上执行高级任务，而无需域管理员介入。 右键 需要委派给其他人的 OU，选择 Delegate Control ，进入新界面进行具体操作。 被委派的用户由于没有打开 Active Directory Users and Computers 的权限，需要使用Powershell来执行操作。 设备管理身份验证Windows域中的网络身份验证 都需要 域控制器DC 来验证配置是否正确 使用两种协议： Kerberos：新的默认协议 NetNTLM：旧的身份验证协议，仍然兼容 KerberosKerberos 是 Windows 域环境中默认的身份验证协议，依赖于 KDC（密钥分发中心），通常运行在域控制器（DC）上。KDC 包含两个主要服务： 认证服务（AS，Authentication Service）：负责验证用户身份并颁发 TGT（Ticket Granting Ticket）。 票据授予服务（TGS，Ticket Granting Service）：根据 TGT 颁发特定服务的 服务票据（Service Ticket）。 TGT 作为用户身份的通用凭证，允许用户在有效期内多次请求服务票据 Kerberos 工作流程简述： 用户通过用户名和密码（或密钥）向 KDC 的认证服务（AS）请求身份验证。 KDC 验证用户身份后，返回一个 TGT，该票据包含用户的身份信息和时间戳，加密后存储在客户端。 当用户需要访问特定服务时，客户端使用 TGT 向 KDC 的票据授予服务（TGS）请求 服务票据。 TGS 返回一个针对特定服务的 服务票据，用户出示该票据给目标服务，服务验证票据后授予访问权限。 票据有效期：TGT 和服务票据都有时间限制（通常为 10 小时），到期后需续期或重新认证。 NetNTLMNetNTLM（也称为 NTLM，NT LAN Manager）是 Windows 域环境中较旧的身份验证协议，通常作为 Kerberos 的备用协议，用于不支持 Kerberos 的场景或向下兼容旧系统。 仅做介绍 树、林、信任关系AD支持集成多个域，将网络划分为可独立管理的单元。 树的每个域都有各自的 DC ，有各自的域管理员，以及可以控制企业中所有内容的 企业管理员。 不同的命名空间 也可以 统一管理。 将多个具有不同命名空间的树合并到同一个网络中，这种结构称为林 双向信任关系是域之间的一种认证机制，允许用户跨域被识别和授权，但它本身并不自动授予资源访问权限。 管理员需要进一步配置具体的访问权限，以决定哪些用户可以访问哪些资源，从而实现安全的资源共享和跨域协作。 第二部分 文件系统与权限文件系统：NTFSNTFS 被称为日志文件系统，发生故障可以使用日志中的信息自动修复磁盘上的文件 权限设置 Read Write Read Execute List Folder Contents Modify Full Control 继承性：子文件夹和文件继承父文件夹的权限 显式权限：可以为特定文件及文件夹设置独立权限，覆盖继承的权限 备用数据流ADS每个文件至少有一个默认数据流 $DATA，ADS 允许文件附加额外的命名数据流，与主数据流并存，可以存储独立的数据。 元数据存储：Windows 常使用 ADS 存储文件的元数据，如文件的摘要信息或缩略图。 安全和隐藏数据：ADS 可用于隐藏数据（例如，恶意软件可能利用 ADS 隐藏恶意代码）。 Windows\\System32C:\\Windows 即包含操作系统的文件夹，环境变量是 %windir% 环境变量存储有关操作系统环境的信息。此信息包括操作系统路径、操作系统使用的处理器数量以及临时文件夹的位置等详细信息 其中的 System32文件夹中的内容对操作系统至关重要。 账户 管理员：可以对系统进行更改。添加用户、删除用户、修改组、修改系统设置等。 标准用户：只能更改属于用户的文件夹文件，而不能执行系统级更改，例如安装程序。 创建用户账户时会为该用户创建一个配置文件。每个用户配置文件文件夹位于 C:\\Users。 每个用户配置文件都包含共同的文件夹：桌面、文件、下载、音乐、图片 在运行窗口：lusrmgr.msc 可以查看用户和群组的详细信息。 User Account Control（UAC）任意管理员用户都可以修改系统设置，引入 UAC 以限制权限滥用。 即管理员用户登录时，默认情况下会话不会以管理员权限运行。当需要执行需要更高级别权限的操作时，系统会提示用户确认是否允许该操作运行。 不适用于内置本地管理员账户，日常不会使用这个账户。 这就是一些安装程序图标右下角会有个盾牌的原因，因为它需要更高级别的权限来安装 UAC 可以设置控制强度 运行提示符：UserAccountControlSettings.exe 设置和控制面板设置日常使用更多 控制面板可以访问更复杂设置和执行复杂操作。 任务管理器Ctrl + Shift + Esc打开任务管理器 可以查看正在运行的程序、进程，以及性能、服务等详细信息。 第三部分 系统配置及相关工具简单介绍 系统配置MSConfig 程序（系统配置实用程序）用于高级故障排除，主要帮助诊断启动问题。 直接Windows搜索系统配置 常规：选择Windows启动时加载的设备和服务 引导：为操作系统定义各种启动选项 服务：列出系统配置的所有服务（服务是一种在后台运行的特殊应用程序） 启动：微软建议使用任务管理器来管理启动项 工具：列出各种实用程序，可以通过运行提示符（Win+R）、命令提示符和运行按钮来启动 运行提示符：control.exe 进入控制面板 计算机管理 compmgmt.msc 计算机管理实用程序 系统工具 任务计划程序：可以创建和管理常见任务，运行应用程序、脚本等，并且可以配置任务在任意时间点运行 事件查看器：可以记录五种类型的事件。这些事件记录可以被视为审计线索，用于了解计算机系统的活动。 共享文件夹：其他人可以连接的共享和文件夹的完整列表。 本地用户和组 性能：有 性能监视器 （perfmon）程序 设备管理器：查看和配置硬件，例如禁用连接到计算机的任何硬件。 存储 磁盘管理：执行高级存储任务，设置新驱动器、扩展或缩小分区、分配或更改驱动器号 服务和应用程序：可以查看服务 系统信息 msinfo32.exe 硬件资源：不懂硬件看不懂 组件：可以查看计算机上安装的硬件设备的具体信息 软件环境：可以查看操作系统内置软件以及您已安装软件的信息。此部分还显示其他详细信息，例如环境变量和网络连接。 资源监视器 resmon.exe 资源监视器显示每个进程以及CPU、内存、磁盘和网络使用情况的汇总信息，此外还提供有关哪些进程正在使用各个文件句柄和模块的详细信息。 高级筛选功能允许用户隔离与一个或多个进程（应用程序或服务）相关的数据，启动、停止、暂停和恢复服务，以及从用户界面关闭无响应的应用程序。它还包括一个进程分析功能，可以帮助识别死锁进程和文件锁定冲突 命令提示符 cmdhostname # 输出计算机名称whoami # 输出登录用户的名称ipconfig # 显示计算机的网络地址设置cls # 清除屏幕 clearnetstat # 显示协议统计信息和当前的 TCP/IP 网络连接net # 管理网络资源 使用 help (net help) 命令后加 /? 显示说明（net除外） 注册表编辑器 regedt32.exeWindows 注册表 是一个中央分层数据库，用于存储为一个或多个用户、应用程序和硬件设备配置系统所需的信息。 注册表包含 Windows 在运行期间不断引用的信息，例如： 每个用户的个人资料 计算机上安装的应用程序以及每个应用程序可以创建的文档类型 文件夹和应用程序图标的属性表设置 系统上有哪些硬件 正在使用的端口 第四部分 内置安全功能简单介绍 Windows更新Windows 更新是微软为 Windows 操作系统提供的补丁、功能更新和安全修复，旨在提升系统安全性、稳定性和性能。 更新可分为 安全更新、功能更新、质量更新、驱动更新 Windows 10 和 Windows 11 设计为强制更新，普通用户无法永久禁用更新，只能推迟。 WIndows安全 病毒和威胁防护 防火墙和网络保护 应用程序和浏览器控制 设备安全 病毒和威胁防护防火墙防火墙（Firewall）监控和控制通过端口进出的网络流量。检查每一个数据包，决定是允许通过、拒绝，还是丢弃。 Windows防火墙提供三种防火墙配置文件：域、私有和公共 域：域配置文件适用于主机系统可以向域控制器进行身份验证的网络。 私人：私人配置文件是用户分配的配置文件，用于指定私人或家庭网络。 公共：默认配置文件是公共配置文件，用于指定公共网络，例如咖啡店、机场和其他地点的 Wi-Fi 热点。 应用和浏览器控制设备安全 内核隔离：防止攻击将代码插入高安全性进程 安全处理器：使用可信平台模块 (TPM) 技术，提供基于硬件的安全相关功能。TPM 芯片是一种安全的加密处理器。该芯片包含多种物理安全机制，使其具有防篡改功能，恶意软件无法篡改 TPM 的安全功能 数据加密：BitLocker 驱动器加密是一种与操作系统集成的数据保护功能，可以解决丢失、被盗或不当退役的计算机造成的数据盗窃或泄露威胁 卷影复制服务 VSS该服务创建数据的一致性快照（也称为卷影副本或时间点副本）。这些快照可以在特定时间点捕获文件、文件夹或整个驱动器的数据状态，方便备份或恢复。 系统保护功能：通过VSS支持创建、配置和删除还原点，以及执行系统还原。 安全风险：勒索软件可能删除卷影副本，导致无法通过系统还原恢复数据。","categories":["Cyber Security 101"]},{"title":"Cyber Security 101 第二部分 Linux基础知识","path":"/Cyber-Security-101-2/","content":"介绍Linux基础知识：一些基本命令，使用SSH登录Linux设备，与文件系统交互，以及一些实用工具，进程，自动化，与包管理，日志相关知识 基本命令echo Hello # 输出提供的文本whoami # 输出当前登录的用户ls # 列出目录下的文件listing,默认参数是当前目录cd # 更改目录 change directorycat # 输出文件内容pwd # 打印完整工作目录路径 print working directory find -name passwords.txt # 在当前目录下查找文件find -name *.txt # 使用*来搜索所有txt文件 grep 81.143.211.90 access.log # 搜索文件内容，展示包含所需值的条目 # shell运算符 允许终端后台允许命令 将多个命令组合在一行 重定向 与相同，但是输出不覆盖而是添加在后面 echo Hello welcome # 将 Hello 输出到文本文件，内容将被覆盖echo World welcome # 将 World 添加到文本文件后（自动换行） 使用SSH登录Linux设备、执行命令、与文件系统交互 SSH（Secure Shell） ：连接远程Linux机器命令行并进行交互 ssh 账户用户名@远程机器IP地址# 然后还需输入密码 命令参数 ls -a # 将显示工作目录所有内容all，包括隐藏文件ls --help # manual使用帮助ls -lh # 列出当前目录下文件详细信息 long、human能阅读的方式 与文件系统交互 touch # 创建文件mkdir # make directory创建文件夹cp # copymv # moverm # removefile # 确定文件类型 rm note # 删除文件rm -R directory # 删除文件夹 cp note new_note # 复制时可以自动创建新文件 mv note new_note # 移动到新文件夹或新文件，不保留旧文件 file note # 确定文件类型 note: ASCII text # 表明是一个文本文件 权限ls -lh -rw-r--r-- 1 user group 4.5K Sep 2 14:30 example.txt drwxr-xr-x 2 user group 4.0K Sep 2 10:15 mydir 第1个字符：-普通文件，d目录，l符号链接 后9个字符：权限，分为三组，分别表示 文件拥有者权限、所属组权限、其他用户权限 硬链接数（如1或2）：普通文件通常为 1，目录为至少 2（包含自身和 . 目录）。 文件拥有者、文件所属组、文件大小、最后修改时间、文件名 切换用户需要知道用户名和密码 su 其他用户 Password:# 仅切换到目标身份，但保留当前用户的环境变量，且工作目录不变 su -l 用户名# 完全切换用户，并切换到HOME目录 目录 ETC：存储操作系统使用的系统文件 var：存储系统上运行的服务或应用经常访问或写入的数据，如日志文件/var/log root：root系统用户的主目录 tmp：用于存储只需访问几次的数据。重启将清除，任何用户默认都可以写入此文件夹，渗透测试中存储、枚举的理想场所 终端文本编辑器 nano vim 仅做了解 通用实用工具wgetwget 文件URL SCP（SSH）利用SSH协议在两台计算机之间传输文件，提供身份验证和加密 通过 SOURCE 和 DESTINATION 模型，SCP 允许您： 将文件和目录从当前系统复制到远程系统 scp test.txt user@IP_address:home/user/new.txt 将文件和目录从远程系统复制到当前系统 scp user@IP_address:home/user/test.txt new.txt WebPython3的“HTTPServer”会在当前目录进行文件服务 python3 -m http.server # 启动http服务（8000端口） wget http://10.10.135.215:8000/myfile 进程查看进程 所有进程（加上其他用户运行以及系统进程） ps aux top获取进程的实时统计信息 top 管理进程kill PID 在进程被终止时可以发送的一些信号： SIGTERM——终止进程，但允许它事先执行一些清理任务 SIGKILL - 终止进程 - 事后不做任何清理 SIGSTOP——停止暂停进程 进程的启动命名空间将进程彼此隔离，只有同一命名空间中的进程可以相互看到 PID为 0 的进程是系统启动时启动的 systemd是第一个启动的进程之一，管理系统进程的初始化系统。任何想要启动的进程都会作为 systemd 的子进程启动。 systemctl 是管理 systemd 服务的命令行工具，可以用于启用或停止、开机启用、禁止 服务 systemctl [option] [service]# start stop enable disable 前台和后台在命令中添加 会让进程在后台运行 CTRL + Z也可以将进程移到后台 fg 命令将后台进程重新带回前台（ foreground） 自动化cron 是一个 Linux 系统中的守护进程（daemon），在系统启动时自动运行，用于定时执行任务（称为 cron 作业，cron jobs）。 它根据预设的时间表（schedule）运行脚本、命令或程序，适合自动化任务，如定时备份、更新系统或启动应用程序。 使用 crontab（table）来管理定时任务 crontab -e # 编辑当前用户的crontabcrontab -l # 查看当前用户的crontab 格式 时 日 月 星期 命令 # *表示任意0 * * * * /usr/bin/google-chrome # 每个小时启动Google Chrome@reboot /var/opt/processes.sh # 系统启动或重启时执行脚本 包管理apt 是软件包管理命令，每当更新系统时，包含软件的仓库也会检查更新 apt updateapt install [software-name-here]apt remove [software-name-here] 仅做介绍 日志 varlogvar/log 存储各种日志 日志轮转：自动管理日志文件大小和存储，定期压缩旧日志、创建新日志、并删除过期日志 以三个日志为例： Apache2 Web服务器： /var/log/apache2/access.log：记录 Web 服务器的访问日志（每次 HTTP 请求的详细信息，如 IP、URL、状态码等）。 /var/log/apache2/error.log：记录 Apache2 的错误信息（如配置错误、页面未找到）。 fail2ban 服务：/var/log/fail2ban.log，记录 fail2ban 服务的运行状态和操作。 防止暴力破解，通过监控日志（如SSH登录）检测异常行为，并临时封禁异常IP UFW服务：/var/log/ufw.log，记录 UFW 防火墙的操作和事件。 仅做介绍","categories":["Cyber Security 101"]},{"title":"Cyber Security 101 第一部分 简介","path":"/Cyber-Security-101-1/","content":"介绍网络安全101课程，初步了解进攻性安全和防御性安全的概念，总结搜索技巧 Cyber Security 101本课程涵盖以下方面的基本概念和应用 计算机网络和密码学 MS Windows、Active Directory 和 Linux 基础知识 攻击性安全工具和系统利用 防御性安全解决方案和工具 网络安全职业 前面几部分是基础知识，网络安全相关部分在后面学习 进攻性安全进攻性安全是一种主动的安全测试方法，通过模拟黑客的攻击行为来识别和利用系统、应用程序或网络中的漏洞。其目标是发现潜在的安全弱点，从而在恶意攻击者利用之前进行修复。 示例：入侵一个 模拟的FakeBank： http://fake.bank.thm 使用 Gobuster 暴力查找银行所有页面 gobuster dir -u http://fake.bank.thm -w wordlist.txt # -u 声明正在扫描的网站# -w 采用单词列表遍历查找隐藏的页面 结果找到bank-transfer转账页面，状态200 OK，代表可以访问 访问http://fakebank.thm/bank-transfer 于是获取了转账权限（可以使用ID进行转账） 通过模拟黑客入侵银行系统，发现了未经授权就可以访问的转账页面 这是一种访问控制漏洞。具体来说是不安全的直接引用 通过操纵 URL 参数、表单数据或请求体中的标识符（如用户 ID、账户 ID 或交易 ID） 无需授权，直接访问或修改他人的资源 修复漏洞需要实施严格的访问控制检查 一个类似的漏洞示例： Optus 数据泄露（2022 年，澳大利亚电信巨头） https://www.upguard.com/blog/how-did-the-optus-data-breach-happen 报告总结了原因： 一个无需身份验证的API可以访问客户敏感信息 递增使用客户标识符（递增ID即可获取所有客户ID） GobusterGo语言编写的开源命令行工具 可以用于暴力枚举Web目录、文件、DNS子域名等 gobuster dir -u 网站域名 -w 爆破字典gobuster dns -d 网站域名 -w 爆破字典 后续进一步学习使用 防御安全简介防御安全：从保护、监控和维护的角度出发，通过收集情报、检测异常、响应威胁和修复漏洞来确保系统、应用程序和网络的安全。 与进攻性安全主动寻找漏洞不同，防御性安全侧重于构建和维护安全防线，防止攻击发生并在攻击发生时快速响应。 防御安全核心领域： Security Operations Center (SOC), where we cover Threat Intelligence 情报收集 Digital Forensics and Incident Response (DFIR), where we also cover Malware Analysis 数字取证、事件响应、恶意软件分析 事件响应流程： 现代安全管理使用 Security Information and Event Management (SIEM) 系统，这是一种集成的安全管理方案， 收集安全相关信息和事件并呈现，如果检测到可疑事件会发出警报 SIEM系统模拟： 多次登录失败不一定有问题，可能只是忘记密码 注意到 IP 143.110.250.149 尝试未授权登录，最终成功，这很可疑，利用一些网站查询该 IP。 查询结果显示非常可疑，并且登录成功，可能有危险，应该进行处理。选择 SOC Team lead ，负责初始的事件处理并报告，之后交给 DFIR 最后封锁这个IP 搜索技巧谷歌搜索: 双引号表示精确搜索 site: 限制域名 - 忽略特定词语 filetype:查找文件类型（而非网页） 专业搜索引擎： Shodan 搜索联网设备 Censys 搜索互联网资产 VirusTotal 文件病毒扫描服务 Have I Been Pwned 检测某个电子邮箱地址是否被泄露 常见漏洞CVE CVE系统，漏洞字典，用CVE ID标准化每个漏洞（https://nvd.nist.gov/） 漏洞数据库，可以找到来自不同作者的漏洞利用代码 查阅官方文档","categories":["Cyber Security 101"]}]